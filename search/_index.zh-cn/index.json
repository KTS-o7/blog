[{"categories":null,"content":"Problem Statement Link - Problem 1605 Question You are given two arrays rowSum and colSum of non-negative integers where rowSum[i] is the sum of the elements in the ith row and colSum[j] is the sum of the elements of the jth column of a 2D matrix. In other words, you do not know the elements of the matrix, but you do know the sums of each row and column.\nFind any matrix of non-negative integers of size rowSum.length x colSum.length that satisfies the rowSum and colSum requirements.\nReturn a 2D array representing any matrix that fulfills the requirements. It\u0026rsquo;s guaranteed that at least one matrix that fulfills the requirements exists.\nExample 1 Input: rowSum = [3,8], colSum = [4,7] Output: [[3,0], [1,7]] Explanation: 0th row: 3 + 0 = 3 == rowSum[0] 1st row: 1 + 7 = 8 == rowSum[1] 0th column: 3 + 1 = 4 == colSum[0] 1st column: 0 + 7 = 7 == colSum[1] The row and column sums match, and all matrix elements are non-negative. Another possible matrix is: [[1,2], [3,5]] Example 2 Input: rowSum = [5,7,10], colSum = [8,6,8] Output: [[0,5,0], [6,1,0], [2,0,8]] Constraints - `1 \u0026lt;= rowSum.length, colSum.length \u0026lt;= 500` - `0 \u0026lt;= rowSum[i], colSum[i] \u0026lt;= 10^8` - `sum(rowSum) == sum(colSum)` Solution class Solution { public: vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; restoreMatrix(vector\u0026lt;int\u0026gt;\u0026amp; rowSum, vector\u0026lt;int\u0026gt;\u0026amp; colSum) { int rows = rowSum.size(), cols = colSum.size(); vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;res(rows,vector\u0026lt;int\u0026gt;(cols,0)); for(int i = 0; i\u0026lt;rows; i++){ for(int j = 0; j\u0026lt;cols; j++){ res[i][j] = min(rowSum[i],colSum[j]); rowSum[i]-=res[i][j]; colSum[j]-=res[i][j]; } } return res; } }; Complexity Analysis | Algorithm | Time Complexity | Space Complexity | | ---------------- | --------------- | ---------------- | | Matrix Traversal | O(mn) | O(mn) | Explanation 1. Intuition - Seeing the problem statement it might seem its very hard. - We can use greedy method to solve this question. - Greedy works because of the following mathematical fact \u0026gt; If given a m variable system of equations and n constraints, if m\u0026gt;n, then the system is underdetermined and has infinite solutions. - We can use this fact to solve the problem. - If we can fix the value of one cell, we can derive the values of other cells. - First set the value of the cell to be the minimum of the rowSum and colSum. - Then subtract the value from the rowSum and colSum. - Continue this process until all the cells are filled. 2. Implementation - Initialize a result matrix `res` of size `rows x cols` with all values as 0. - Traverse the matrix and set the value of the cell to be the minimum of the rowSum and colSum. - Subtract the value from the rowSum and colSum. - Continue this process until all the cells are filled. ","permalink":"https://KTS-o7.github.io/blog/posts/daily_lc/problem-1605-find-valid-matrix-given-row-and-column-sums/","tags":["matrix","greedy"],"title":"Problem 1605 Find Valid Matrix Given Row and Column Sums"},{"categories":null,"content":"Problem Statement Link - Problem 1380 Question Given an m x n matrix of distinct numbers, return all lucky numbers in the matrix in any order.\nA lucky number is an element of the matrix such that it is the minimum element in its row and maximum in its column.\nExample 1 Input: matrix = [[3,7,8],[9,11,13],[15,16,17]] Output: [15] Explanation: 15 is the only lucky number since it is the minimum in its row and the maximum in its column. Example 2 Input: matrix = [[1,10,4,2],[9,3,8,7],[15,16,17,12]] Output: [12] Explanation: 12 is the only lucky number since it is the minimum in its row and the maximum in its column. Example 3 Input: matrix = [[7,8],[1,2]] Output: [7] Explanation: 7 is the only lucky number since it is the minimum in its row and the maximum in its column. Constraints - `m == mat.length` - `n == mat[i].length` - `1 \u0026lt;= n, m \u0026lt;= 50` - `1 \u0026lt;= matrix[i][j] \u0026lt;= 10^5.` - All elements in the matrix are distinct. Solution class Solution { public: vector\u0026lt;int\u0026gt; luckyNumbers (vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; matrix) { vector\u0026lt;int\u0026gt;rowMin(matrix.size(),INT_MAX); vector\u0026lt;int\u0026gt;colMax(matrix[0].size(),INT_MIN); int rows = matrix.size(); int cols = matrix[0].size(); for(int i = 0; i\u0026lt;rows; i++){ for(int j = 0; j\u0026lt;cols ; j++){ rowMin[i] = min(rowMin[i], matrix[i][j]); colMax[j] = max(colMax[j],matrix[i][j]); } } /*for(auto it:rowMin) cout\u0026lt;\u0026lt;it\u0026lt;\u0026lt;\u0026#34; \u0026#34;; cout\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;\u0026lt;\u0026lt;endl; for(auto it:colMax) cout\u0026lt;\u0026lt;it\u0026lt;\u0026lt;\u0026#34; \u0026#34;;*/ vector\u0026lt;int\u0026gt;ans; for(int i = 0; i\u0026lt;rows; i++){ for(int j=0; j\u0026lt;cols; j++){ if(matrix[i][j] == rowMin[i] \u0026amp;\u0026amp; matrix[i][j]==colMax[j]){ ans.push_back(matrix[i][j]); } } } return ans; } }; Complexity Analysis | Algorithm | Time Complexity | Space Complexity | | ---------------- | --------------- | ---------------- | | Matrix Traversal | O(N^2) | O(N) | Explanation 1. Intuition - We can store the row minimums and column maximums in two separate arrays. - Then we can check the each element of the matrix with the row minimum and column maximum of that row and column. - If the element is equal to both the row minimum and column maximum, then it is a lucky number. - We can store all the lucky numbers in a vector and return it. 2. Implementation - Initialize two vectors `rowMin` and `colMax` with INT_MAX and INT_MIN respectively. - Traverse the matrix and update the `rowMin` and `colMax` vectors. - Traverse the matrix again and check if the element is equal to the row minimum and column maximum. - If it is, then push the element into the answer vector. - Return the answer vector. Alternate Approach There is a more optimized approach to solve this problem. We can develop a Constant Space Complexity solution. But before that we need to prove that there is only one lucky number in the matrix.\nProof by Contradiction - Suppose we have an integer `X` which is the minimum in row `r1` and maximum in column `c1`. - Lets say there is another integer `Y` which is the minimum in row `r2` and maximum in column `c2`. Hence we can conclude that there can be only one lucky number in the matrix. - We can take advantage of the above fact as follows - The lucky number will always be the maximum of the minimums of Row and the minimum of the maximums of Column. - This is because every element is **unique** **Algorithm**: 1. iterate over each row and find the minimum element in that row. 2. then find the maximum of all the minimums. 3. iterate over each column and find the maximum element in that column. 4. then find the minimum of all the maximums. 5. if the maximum of minimums is equal to the minimum of maximums, then that element is the lucky number. 6. return the vector. Code class Solution { public: vector\u0026lt;int\u0026gt; luckyNumbers (vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; matrix) { int N = matrix.size(), M = matrix[0].size(); int rMinMax = INT_MIN; for (int i = 0; i \u0026lt; N; i++) { int rMin = INT_MAX; for (int j = 0; j \u0026lt; M; j++) { rMin = min(rMin, matrix[i][j]); } rMinMax = max(rMinMax, rMin); } int cMaxMin = INT_MAX; for (int i = 0; i \u0026lt; M; i++) { int cMax = INT_MIN; for (int j = 0; j \u0026lt; N; j++) { cMax = max(cMax, matrix[j][i]); } cMaxMin = min(cMaxMin, cMax); } if (rMinMax == cMaxMin) { return {rMinMax}; } return {}; } }; ","permalink":"https://KTS-o7.github.io/blog/posts/prev_solns/problem-lucky-number-in-a-matrix/","tags":["matrix","maxi-min","mini-max"],"title":"Problem 1380 Lucky Number in a Matrix"},{"categories":null,"content":"Problem Statement Link - Problem 1530 Question You are given the root of a binary tree and an integer distance. A pair of two different leaf nodes of a binary tree is said to be good if the length of the shortest path between them is less than or equal to distance.\nReturn the number of good leaf node pairs in the tree.\nExample 1 Input: root = [1,2,3,null,4], distance = 3 Output: 1 Explanation: The leaf nodes of the tree are 3 and 4 and the length of the shortest path between them is 3. This is the only good pair. Example 2 Input: root = [1,2,3,4,5,6,7], distance = 3 Output: 2 Explanation: The good pairs are [4,5] and [6,7] with shortest path = 2. The pair [4,6] is not good because the length of ther shortest path between them is 4. Example 3 Input: root = [7,1,4,6,null,5,3,null,null,null,null,null,2], distance = 3 Output: 1 Explanation: The only good pair is [2,5]. Constraints - The number of nodes in the tree is in the range `[1, 2^10]`. - `1 \u0026lt;= Node.val \u0026lt;= 100` - `1 \u0026lt;= distance \u0026lt;= 10` Solution /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: vector\u0026lt;int\u0026gt;countPair(TreeNode* root, int\u0026amp; dist, int\u0026amp; count){ if(!root) return {0}; if(root-\u0026gt;left == nullptr \u0026amp;\u0026amp; root-\u0026gt;right == nullptr) return {1}; vector\u0026lt;int\u0026gt; left = countPair(root-\u0026gt;left,dist,count); vector\u0026lt;int\u0026gt; right = countPair(root-\u0026gt;right,dist,count); for(int i:left){ for(int j:right){ if(i\u0026gt;0 \u0026amp;\u0026amp; j\u0026gt;0 \u0026amp;\u0026amp; i+j\u0026lt;=dist){ count++; } } } vector\u0026lt;int\u0026gt;ans; for(int i:left) if(i\u0026gt;0 \u0026amp;\u0026amp; i\u0026lt;dist) ans.push_back(i+1); for(int j:right) if(j\u0026gt;0 \u0026amp;\u0026amp; j\u0026lt;dist) ans.push_back(j+1); return ans; } int countPairs(TreeNode* root, int distance) { int count = 0; countPair(root,distance,count); return count; } }; Complexity Analysis | Algorithm | Time Complexity | Space Complexity | | --------- | --------------- | ---------------- | | DFS | O(n^2) | O(n) | Explanation 1. Intuition - We can count a good pair by checking the distance between the leaf nodes. - We need to build up the distance calculations from the leaf nodes to the root. - We can use a recursive approach to solve this problem. - If we can track the distances from leaf nodes to the current node, we can find out the combinations that match in that subtree - Return 1 if the node is a leaf node. - Return 0 if the node is null. - Keep track of the distances of the leaf nodes from left subtree of current node, and right subtree of the current node. - Now we can find out the good pairs by checking the distances of the leaf nodes in the left subtree and right subtree of the current node. - If the sum of the distances of the leaf nodes in the left subtree and right subtree is less than or equal to the distance, then we can increment the count. - We can return the distances of the leaf nodes from the current node to the parent node. 2. Implementation - Define a helper function `countPair` which takes the root node, distance and count as arguments. - If the root is null, return a vector with 0. - If the root is a leaf node, return a vector with 1. - Recursively call the function on the left and right child of the current node. - Store the distances of the leaf nodes of left subtree in the vector `left`. - Store the distances of the leaf nodes of right subtree in the vector `right`. - For each distance in the `left` vector, - For each distance in the `right` vector, - If the sum of the distances is less than or equal to the distance, increment the count. - Declare a vector `ans` to store the distances of the leaf nodes from the current node to the parent node. - For each distance in the `left` vector, - If the distance is greater than 0 and less than the distance, add the distance + 1 to the `ans` vector. - For each distance in the `right` vector, - If the distance is greater than 0 and less than the distance, add the distance + 1 to the `ans` vector. - This adding `1` basically says that there is a node between the leaf node and the parent node. - Return the `ans` vector. This is a good problem to understand the concept of DFS and how we can use it to solve problems related to binary trees.\n","permalink":"https://KTS-o7.github.io/blog/posts/prev_solns/problem-number-of-good-leaf-nodes-pairs/","tags":["binary-tree","dfs"],"title":"Problem 1530 Number of Good Leaf Nodes Pairs"},{"categories":null,"content":"Problem Statement Link - Problem 1110 Question Given the root of a binary tree, each node in the tree has a distinct value.\nAfter deleting all nodes with a value in to_delete, we are left with a forest (a disjoint union of trees).\nReturn the roots of the trees in the remaining forest. You may return the result in any order.\nExample 1 Input: root = [1,2,3,4,5,6,7], to_delete = [3,5] Output: [[1,2,null,4],[6],[7]] Example 2 Input: root = [1,2,4,null,3], to_delete = [3] Output: [[1,2,4]] Constraints - The number of nodes in the given tree is at most `1000`. - Each node has a distinct value between `1` and `1000`. - `to_delete.length \u0026lt;= 1000` - `to_delete` contains distinct values between `1` and `1000`. Solution /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: void delNode(TreeNode* \u0026amp;root, vector\u0026lt;bool\u0026gt;\u0026amp; todel, vector\u0026lt;TreeNode*\u0026gt;\u0026amp; result){ if(root != nullptr){ delNode(root-\u0026gt;left,todel,result); delNode(root-\u0026gt;right,todel,result); if(todel[root-\u0026gt;val] == true){ if(root-\u0026gt;left) result.push_back(root-\u0026gt;left); if(root-\u0026gt;right) result.push_back(root-\u0026gt;right); root = nullptr; } } else return; } vector\u0026lt;TreeNode*\u0026gt; delNodes(TreeNode* root, vector\u0026lt;int\u0026gt;\u0026amp; to_delete) { vector\u0026lt;bool\u0026gt;todel(1001,false); for(const auto it:to_delete) todel[it] = true; vector\u0026lt;TreeNode*\u0026gt;res; delNode(root,todel,res); if(root) res.push_back(root); return res; } }; Complexity Analysis | Algorithm | Time Complexity | Space Complexity | | --------- | --------------- | ---------------- | | DFS | O(n) | O(n) | Explanation 1. Intuition - We can recursively traverse the tree and delete the nodes which are present in the `to_delete` vector. - Once we delete the node, we can add the left and right child of the node to the result vector. - But this pruning should be done in a post-order traversal so that we can delete nodes from the leaf nodes back to root. 2. Implementation - Since we know that the values of the nodes are distinct, we can use a vector of size 1001 to store the nodes to delete. - Declare a vector `toDel` of size 1001 and initialize it to false. - For each value in the `to_delete` vector, set the value at that index to true. - Declare a vector of TreeNode `res` to store the result. - Call the `delNode` function with the root, `toDel`, and `res` as arguments. - Helper function `delNode`: - If the root is not null, recursively call the function on the left and right child. - If the value of the root is present in the `toDel` vector, add the left and right child to the result vector and set the root to null. - once the `delNode` function is called, check if the root is not null and add it to the result vector. - Return the result vector. ","permalink":"https://KTS-o7.github.io/blog/posts/prev_solns/problem-delete-nodes-and-return-forest/","tags":["binary-tree","pointers","dfs"],"title":"Problem 1110 Delete Nodes and Return Forest"},{"categories":null,"content":"Problem Statement Link - Problem 2096 Question You are given the root of a binary tree with n nodes. Each node is uniquely assigned a value from 1 to n. You are also given an integer startValue representing the value of the start node s, and a different integer destValue representing the value of the destination node t.\nFind the shortest path starting from node s and ending at node t. Generate step-by-step directions of such path as a string consisting of only the uppercase letters 'L', 'R', and 'U'. Each letter indicates a specific direction:\n'L' means to go from a node to its left child node. 'R' means to go from a node to its right child node. 'U' means to go from a node to its parent node. Return the step-by-step directions of the shortest path from node s to node t.\nExample 1 Input: root = [5,1,2,3,null,6,4], startValue = 3, destValue = 6 Output: \u0026#34;UURL\u0026#34; Explanation: The shortest path is: 3 → 1 → 5 → 2 → 6. Example 2 Input: root = [2,1], startValue = 2, destValue = 1 Output: \u0026#34;L\u0026#34; Explanation: The shortest path is: 2 → 1. Constraints - The number of nodes in the tree is `n`. - `2 \u0026lt;= n \u0026lt;= 10^5` - `1 \u0026lt;= Node.val \u0026lt;= n` - All the values in the tree are `unique`. - `1 \u0026lt;= startValue, destValue \u0026lt;= n` - `startValue != destValue` Solution /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: TreeNode* LCA(TreeNode* root, int\u0026amp; p, int\u0026amp; q){ if(root == nullptr || root-\u0026gt;val == p || root-\u0026gt;val == q) return root; TreeNode* left = LCA(root-\u0026gt;left,p,q); TreeNode* right = LCA(root-\u0026gt;right,p,q); if (left == nullptr) return right; if (right == nullptr) return left; return root; } bool dfs(TreeNode* root, int x, string\u0026amp; path, bool rev) { if (root == NULL) return 0; if (root-\u0026gt;val == x) return 1; path += (rev ? \u0026#39;U\u0026#39; : \u0026#39;L\u0026#39;); if (dfs(root-\u0026gt;left, x, path, rev)) return 1; path.pop_back(); path += (rev ? \u0026#39;U\u0026#39; : \u0026#39;R\u0026#39;); if (dfs(root-\u0026gt;right, x, path, rev)) return 1; path.pop_back(); return 0; } string getDirections(TreeNode* root, int startValue, int destValue) { std::ios::sync_with_stdio(false); root = LCA(root, startValue, destValue); string pathFrom = \u0026#34;\u0026#34;, pathTo = \u0026#34;\u0026#34;; dfs(root,startValue,pathFrom,1); dfs(root,destValue,pathTo,0); return pathFrom + pathTo; } }; Complexity Analysis | Time Complexity | Space Complexity | | --------------- | ---------------- | | O(N) | O(N) | Explanation 1. Intuition - The idea is to find the Lowest Common Ancestor of the two nodes. - This will help us to find the shortest path as the shortest path must pass through the LCA. - Once we find the shortest path, we can find the directions from the start node to the LCA and from the LCA to the destination node. - We need to build these paths as strings and return the concatenated string. - How do we build a path ? - Remember that from source to LCA it will always be `\u0026#39;U\u0026#39;` and `\u0026#39;L\u0026#39;` or `\u0026#39;R\u0026#39;` for LCA to destination. - So we need to keep track of direction which we are finding the path. - Use DFS, if we are going from LCA to Source append `\u0026#39;U\u0026#39;` else append `\u0026#39;L\u0026#39;` or `\u0026#39;R\u0026#39;` appropriately. - We first try to append the direction to `path` and then try to find the path in the left subtree. If not found then we pop the last character from the path and append the direction to the right subtree. If not found then we pop the last character from the path. 2. Implementation - Define a function `LCA` to find the Lowest Common Ancestor of the two nodes. 1. `LCA` - If the `root` is `NULL` or the value of the root is equal to `p` or `q` return the root. - Recursively find the LCA in the left and right subtree. - If the left is `NULL` return right. - If the right is `NULL` return left. - Return the `root`. 2. DFS to find the path, this is a boolean function - If `root` is `NULL` return `0`. It means the path is not found. - If the value of the root is equal to `x` return `1`. - If `root` is not the target nor the leaf node then - Append `\u0026#39;U\u0026#39;` or `\u0026#39;L\u0026#39;` based on the `rev` flag. - Recursively find the path in the left subtree. - If the path is found return `1`. - Pop the last character from the path. - Append `\u0026#39;U\u0026#39;` or `\u0026#39;R\u0026#39;` based on the `rev` flag. - Recursively find the path in the right subtree. - If the path is found return `1`. - Pop the last character from the path. - Return `0`. - In the main function `getDirections` - Find the LCA of the two nodes. - Initialize two strings `pathFrom` and `pathTo`. - Find the path from the source to the LCA and append it to `pathFrom`. - Find the path from the LCA to the destination and append it to `pathTo`. - Return the concatenated string of `pathFrom` and `pathTo`. ","permalink":"https://KTS-o7.github.io/blog/posts/prev_solns/problem-step-by-step-directions-from-a-binary-tree-node-to-another/","tags":["binary-tree","dfs","string"],"title":"Problem 2096 Step by Step Directions From a Binary Tree Node to Another"},{"categories":null,"content":"Problem Statement Link - Problem 2196 Question You are given a 2D integer array descriptions where descriptions[i] = [parenti, childi, isLefti] indicates that parenti is the parent of childi in a binary tree of unique values. Furthermore,\nIf isLefti == 1, then childi is the left child of parenti. If isLefti == 0, then childi is the right child of parenti. Construct the binary tree described by descriptions and return its root.\nThe test cases will be generated such that the binary tree is valid.\nExample 1 graph TD A((50)) --\u003e B((20)) A --\u003e C((80)) B --\u003e D((15)) B --\u003e E((17)) C --\u003e F((19)) Input: descriptions = [[20,15,1],[20,17,0],[50,20,1],[50,80,0],[80,19,1]] Output: [50,20,80,15,17,19] Explanation: The root node is the node with value 50 since it has no parent. The resulting binary tree is shown in the diagram. Example 2 graph TD A((1)) --\u003e B((2)) B((2)) --\u003e C((3)) C((3)) --\u003e D((4)) Input: descriptions = [[1,2,1],[2,3,0],[3,4,1]] Output: [1,2,null,null,3,4] Explanation: The root node is the node with value 1 since it has no parent. The resulting binary tree is shown in the diagram. Constraints - `1 \u0026lt;= descriptions.length \u0026lt;= 10^4` - `descriptions[i].length == 3` - `1 \u0026lt;= parenti, childi \u0026lt;= 10^5` - ` 0 \u0026lt;= isLefti \u0026lt;= 1` - The binary tree described by `descriptions` is valid. Solution /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: TreeNode* createBinaryTree(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; descriptions) { std::ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); unordered_map\u0026lt;int,TreeNode*\u0026gt; mp; unordered_set\u0026lt;int\u0026gt;isChild; for(auto \u0026amp;it:descriptions){ if(mp.find(it[0]) == mp.end()){ mp[it[0]] = new TreeNode(it[0]); } if(mp.find(it[1])==mp.end()){ mp[it[1]] = new TreeNode(it[1]); } if(it[2]){ mp[it[0]]-\u0026gt;left = mp[it[1]]; } else{ mp[it[0]]-\u0026gt;right = mp[it[1]]; } isChild.insert(it[1]); } TreeNode* root = nullptr; for(auto \u0026amp;it : descriptions){ if(isChild.find(it[0]) == isChild.end()){ root = mp[it[0]]; return root; } } return root; } }; Complexity Analysis Time Complexity : O(N) Space Complexity : O(N) Explanation 1. Intuition - Root node will be the node which has no parent. - So we need to maintain a set of nodes which are child nodes. - First create a map of all nodes and form the tree. - To find the root node, iterate over the set of nodes and find the node which is not a child node. 2. Implementation - Initialize a map `mp` to store the nodes. - Initialize a set `isChild` to store the child nodes. - Traverse the `descriptions` array. - If the parent node is not present in the map, then create a new node and add it to the map. - If the child node is not present in the map, then create a new node and add it to the map. - If the child node is a left child, then add the child node to the left of the parent node. - If the child node is a right child, then add the child node to the right of the parent node. - Add the child node to the set of child nodes. - Finally, iterate over the `descriptions` array. - Find the node which is not a child node. - Return the root node. The key idea is to find the node which is not a child node and return it as the root node.\n","permalink":"https://KTS-o7.github.io/blog/posts/prev_solns/problem-create-binary-tree-from-descriptions/","tags":["binary-tree","hashmap"],"title":"Problem 2196 Create Binary Tree From Descriptions"},{"categories":null,"content":"Problem Statement Link - Problem 726 Question Given a string formula representing a chemical formula, return the count of each atom.\nThe atomic element always starts with an uppercase character, then zero or more lowercase letters, representing the name.\nOne or more digits representing that element\u0026rsquo;s count may follow if the count is greater than 1. If the count is 1, no digits will follow.\nFor example, \u0026quot;H2O\u0026quot; and \u0026quot;H2O2\u0026quot; are possible, but \u0026quot;H1O2\u0026quot; is impossible. Two formulas are concatenated together to produce another formula.\nFor example, \u0026quot;H2O2He3Mg4\u0026quot; is also a formula. A formula placed in parentheses, and a count (optionally added) is also a formula.\nFor example, \u0026quot;(H2O2)\u0026quot; and \u0026quot;(H2O2)3\u0026quot; are formulas. Return the count of all elements as a string in the following form: the first name (in sorted order), followed by its count (if that count is more than 1), followed by the second name (in sorted order), followed by its count (if that count is more than 1), and so on.\nThe test cases are generated so that all the values in the output fit in a 32-bit integer.\nExample 1 Input: formula = \u0026#34;H2O\u0026#34; Output: \u0026#34;H2O\u0026#34; Explanation: The count of elements are {\u0026#39;H\u0026#39;: 2, \u0026#39;O\u0026#39;: 1}. Example 2 Input: formula = \u0026#34;Mg(OH)2\u0026#34; Output: \u0026#34;H2MgO2\u0026#34; Explanation: The count of elements are {\u0026#39;H\u0026#39;: 2, \u0026#39;Mg\u0026#39;: 1, \u0026#39;O\u0026#39;: 2}. Example 3 Input: formula = \u0026#34;K4(ON(SO3)2)2\u0026#34; Output: \u0026#34;K4N2O14S4\u0026#34; Explanation: The count of elements are {\u0026#39;K\u0026#39;: 4, \u0026#39;N\u0026#39;: 2, \u0026#39;O\u0026#39;: 14, \u0026#39;S\u0026#39;: 4}. Constraints - `1 \u0026lt;= formula.length \u0026lt;= 1000` - `formula` consists of English letters, digits, `\u0026#39;(\u0026#39;`, and `\u0026#39;)\u0026#39;`. - `formula` is always valid. Solution class Solution { public: string countOfAtoms(string formula) { stack\u0026lt;unordered_map\u0026lt;string, int\u0026gt;\u0026gt; stack; stack.push(unordered_map\u0026lt;string, int\u0026gt;()); int index = 0; while (index \u0026lt; formula.length()) { if (formula[index] == \u0026#39;(\u0026#39;) { stack.push(unordered_map\u0026lt;string, int\u0026gt;()); index++; } else if (formula[index] == \u0026#39;)\u0026#39;) { unordered_map\u0026lt;string, int\u0026gt; currMap = stack.top(); stack.pop(); index++; string multiplier; while (index \u0026lt; formula.length() \u0026amp;\u0026amp; isdigit(formula[index])) { multiplier += formula[index]; index++; } if (!multiplier.empty()) { int mult = stoi(multiplier); for (auto\u0026amp; [atom, count] : currMap) { currMap[atom] = count * mult; } } for (auto\u0026amp; [atom, count] : currMap) { stack.top()[atom] += count; } } else { string currAtom; currAtom += formula[index]; index++; while (index \u0026lt; formula.length() \u0026amp;\u0026amp; islower(formula[index])) { currAtom += formula[index]; index++; } string currCount; while (index \u0026lt; formula.length() \u0026amp;\u0026amp; isdigit(formula[index])) { currCount += formula[index]; index++; } int count = currCount.empty() ? 1 : stoi(currCount); stack.top()[currAtom] += count; } } map\u0026lt;string, int\u0026gt; finalMap(stack.top().begin(), stack.top().end()); string ans; for (auto\u0026amp; [atom, count] : finalMap) { ans += atom; if (count \u0026gt; 1) { ans += to_string(count); } } return ans; } }; Complexity Analysis Time Complexity : O(N) Space Complexity : O(N) Explanation 1. Intuition - Given a string `formula` representing a chemical formula, we need to return the count of each atom. - We need to recursively parse the formula to get proper count of each atom. - We can use hash maps to count the atoms inbetween a given set of parenthesis. - We can use stack to keep track of the hash maps which has been used to so far. - First have a hashmaps to keep track of the count of each atom. - Push it into the stack. - Traverse the formula string. - If we encounter a `(`, then push an empty hashmap into the stack. - If we encounter a `)`, then pop the top hashmap from the stack. - If there is a number after the `)`, then multiply the count of each atom in the popped hashmap with the number. - Add the count of each atom in the popped hashmap to the top hashmap in the stack. - If we encounter a character, then add the count of the atom to the top hashmap in the stack. - Finally, we will have the count of each atom in the top hashmap in the stack. - Convert the hashmap to a map and then iterate over the map to get the final answer as a string 2. Implementation - Initialize a stack of hashmaps `stack` and push an empty hashmap into the stack. - Initialize an integer `index` to 0. - Traverse the formula string until the end. - If the character at the `index` is `(`, then push an empty hashmap into the `stack` and increment the `index`. - If the character at the `index` is `)`, then pop the top hashmap from the `stack` and increment the `index`. - Initialize a string `multiplier` to empty. - Traverse the formula string until the end and the character at the `index` is a digit. - Add the digit to the `multiplier` and increment the `index`. - If the `multiplier` is not empty, then convert the `multiplier` to an integer `mult`. - Multiply the count of each atom in the popped hashmap with the `mult`. - Add the count of each atom in the popped hashmap to the top hashmap in the stack. - If the character at the `index` is a character, then initialize a string `currAtom` with the character at the `index` and increment the `index`. - Traverse the formula string until the end and the character at the `index` is a lowercase character. - Add the lowercase character to the `currAtom` and increment the `index`. - Initialize a string `currCount` to empty. - Traverse the formula string until the end and the character at the `index` is a digit. - Add the digit to the `currCount` and increment the `index`. - If the `currCount` is empty, then convert the `currCount` to an integer `count`. - Add the `count` to the `currAtom` in the top hashmap in the stack. - Convert the top hashmap in the stack to a map `finalMap`. - Initialize a string `ans` to empty. - Iterate over the `finalMap` and add the atom to the `ans`. - If the count of the atom is greater than 1, then add the count to the `ans`. - Return the `ans`. This is indeed a tricky question but has a lot of edge cases.\n","permalink":"https://KTS-o7.github.io/blog/posts/prev_solns/problem-number-of-atoms/","tags":["string","stack","hashmap"],"title":"Problem 726 Number of Atoms"},{"categories":null,"content":"Problem Statement Link - Problem 2751 Question There are n 1-indexed robots, each having a position on a line, health, and movement direction.\nYou are given 0-indexed integer arrays positions, healths, and a string directions (directions[i] is either \u0026lsquo;L\u0026rsquo; for left or \u0026lsquo;R\u0026rsquo; for right). All integers in positions are unique.\nAll robots start moving on the line simultaneously at the same speed in their given directions. If two robots ever share the same position while moving, they will collide.\nIf two robots collide, the robot with lower health is removed from the line, and the health of the other robot decreases by one. The surviving robot continues in the same direction it was going. If both robots have the same health, they are both removed from the line.\nYour task is to determine the health of the robots that survive the collisions, in the same order that the robots were given, i.e. final heath of robot 1 (if survived), final health of robot 2 (if survived), and so on. If there are no survivors, return an empty array.\nReturn an array containing the health of the remaining robots (in the order they were given in the input), after no further collisions can occur.\nNote: The positions may be unsorted.\nExample 1 Input: positions = [5,4,3,2,1], healths = [2,17,9,15,10], directions = \u0026#34;RRRRR\u0026#34; Output: [2,17,9,15,10] Explanation: No collision occurs in this example, since all robots are moving in the same direction. So, the health of the robots in order from the first robot is returned, [2, 17, 9, 15, 10]. Example 2 Input: positions = [3,5,2,6], healths = [10,10,15,12], directions = \u0026#34;RLRL\u0026#34; Output: [14] Explanation: There are 2 collisions in this example. Firstly, robot 1 and robot 2 will collide, and since both have the same health, they will be removed from the line. Next, robot 3 and robot 4 will collide and since robot 4\u0026#39;s health is smaller, it gets removed, and robot 3\u0026#39;s health becomes 15 - 1 = 14. Only robot 3 remains, so we return [14]. Example 3 Input: positions = [1,2,5,6], healths = [10,10,11,11], directions = \u0026#34;RLRL\u0026#34; Output: [] Explanation: Robot 1 and robot 2 will collide and since both have the same health, they are both removed. Robot 3 and 4 will collide and since both have the same health, they are both removed. So, we return an empty array, []. Constraints - `1 \u0026lt;= positions.length == healths.length == directions.length == n \u0026lt;= 10^5` - `1 \u0026lt;= positions[i], healths[i] \u0026lt;= 10^9` - `directions[i] == \u0026#39;L\u0026#39; or directions[i] == \u0026#39;R\u0026#39;` - All values in `positions` are distinct Solution class Solution { public: vector\u0026lt;int\u0026gt; survivedRobotsHealths(vector\u0026lt;int\u0026gt;\u0026amp; positions, vector\u0026lt;int\u0026gt;\u0026amp; healths, string directions) { int size = positions.size(); vector\u0026lt;int\u0026gt;indices(size), result; stack\u0026lt;int\u0026gt;st; for(int ind = 0; ind\u0026lt;size; ind++){ indices[ind] = ind; } sort(indices.begin(), indices.end(),[\u0026amp;](int lhs, int rhs) { return positions[lhs] \u0026lt; positions[rhs]; }); for(int currInd:indices){ if(directions[currInd] == \u0026#39;R\u0026#39;){ st.push(currInd); } else{ int topInd; while(!st.empty() \u0026amp;\u0026amp; healths[currInd]\u0026gt;0){ topInd = st.top(); st.pop(); if(healths[currInd]\u0026gt; healths[topInd]){ healths[currInd] -=1; healths[topInd] = 0; } else if(healths[currInd]\u0026lt;healths[topInd]){ healths[currInd] = 0; healths[topInd]-=1; st.push(topInd); } else{ healths[currInd] = 0; healths[topInd] = 0; } } } } for(int ind = 0; ind\u0026lt;size; ind++){ if(healths[ind]\u0026gt;0){ result.push_back(healths[ind]); } } return result; } }; Complexity Analysis Time Complexity : O(nlogn) Space Complexity : O(n) Explanation 1. Intuition - Given the problem we can make the following observations. 1. A right going robot will never collide with another right going robot. 2. A left going robot will never collide with another left going robot. 3. A right going robot will collide with a left going robot only if the left going robot is to the right of the right going robot. - Based on the above observations we can sort the robots based on their positions. - Sorted array will contain the robots in the order which they are placed on the line. - Now we can iterate over the sorted array and simulate the collisions. - We need to calculate the collisions only between right and left going robots. - We can use a stack to store the right going robots. - If a left going robot is encountered we can check if there are any right going robots in the stack. - If there are right going robots in the stack we can simulate the collision. - If the left going robot has more health than the right going robot we can reduce the health of the left going robot by 1. - If the left going robot has less health than the right going robot we can reduce the health of the right going robot by 1. - If both the robots have the same health we can remove both the robots. - We can continue this process until we reach the end of the sorted array. - Finally, we can return the health of the robots that survived the collisions. 2. Implementation - Initialize a vector `indices` of `size = positions.size()` to store the order of the robots. - Initialize a stack `st` to store the positions of the right going robots. - Sort the `indices` based on the positions of the robots. - Iterate over the `indices` array. - Assign the current index to `currInd`. - If the current robot is right going push the `currInd` to the stack. - Else do 1. While `st` is not empty and `healths[currInd]` is greater than 0. - Pop the top index from the stack and assign it to `topInd`. - If `healths[currInd]` is greater than `healths[topInd]` reduce the health of `currInd` by 1 and set the health of `topInd` to 0. - If `healths[currInd]` is less than `healths[topInd]` reduce the health of `topInd` by 1,set the health of `currInd` to 0 and push the `topInd` to the stack. This shows that \u0026#39;right going robot is still alive\u0026#39;. - If `healths[currInd]` is equal to `healths[topInd]` set the health of both `currInd` and `topInd` to 0. - Iterate over the `healths` array and push the health of the robots that survived the collisions to the `result` array. - Return the `result` array. The above method will preserve the initial order of the robots.\nNote - The key point was to figure out the fact that the robots will collide only if they are moving in opposite directions and the left going robot is to the right of the right going robot. Also this fact can be used to sort the robots based on their positions and simulate the collisions.\n","permalink":"https://KTS-o7.github.io/blog/posts/prev_solns/problem-robot-collisions/","tags":["stack","array"],"title":"Problem 2751 Robot Collisions"},{"categories":null,"content":"Problem Statement Link - Problem 297 Question Serialization is the process of converting a data structure or object into a sequence of bits so that it can be stored in a file or memory buffer, or transmitted across a network connection link to be reconstructed later in the same or another computer environment.\nDesign an algorithm to serialize and deserialize a binary tree. There is no restriction on how your serialization/deserialization algorithm should work. You just need to ensure that a binary tree can be serialized to a string and this string can be deserialized to the original tree structure.\nExample 1 Input: root = [1,2,3,null,null,4,5] Output: [1,2,3,null,null,4,5] Example 2 Input: root = [] Output: [] Constraints - The number of nodes in the tree is in the range `[0, 10^4]`. - `-1000 \u0026lt;= Node.val \u0026lt;= 1000` Solution /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Codec { public: string serialize(TreeNode* root) { string ans = \u0026#34;\u0026#34;; TreeNode* temp = root; queue\u0026lt;TreeNode*\u0026gt;q; q.push(temp); while(!q.empty()) { for(int i = 0; i\u0026lt;q.size(); i++) { if(q.front() != nullptr) { ans+=to_string(q.front()-\u0026gt;val); ans+=\u0026#39;#\u0026#39;; q.push(q.front()-\u0026gt;left); q.push(q.front()-\u0026gt;right); } else { ans+=\u0026#34;null#\u0026#34;; } q.pop(); } } return ans; } TreeNode* deserialize(string data) { vector\u0026lt;string\u0026gt; nodes; int l = 0, r = 0; while (l \u0026lt; data.size()) { while (r \u0026lt; data.size() \u0026amp;\u0026amp; data[r] != \u0026#39;#\u0026#39;) { r++; } nodes.push_back(data.substr(l, r - l)); l = r + 1; r = l; } if(nodes[0] == \u0026#34;null\u0026#34;) return nullptr; TreeNode* root = new TreeNode(stoi(nodes[0])); queue\u0026lt;TreeNode*\u0026gt;q; q.push(root); int ind = 1; while(!q.empty()) { TreeNode* curr = q.front(); q.pop(); if(nodes[ind]!=\u0026#34;null\u0026#34;) { TreeNode* temp = new TreeNode(stoi(nodes[ind])); curr-\u0026gt;left = temp; q.push(temp); } else { curr-\u0026gt;left = nullptr; } ind++; if(nodes[ind]!=\u0026#34;null\u0026#34;) { TreeNode* temp = new TreeNode(stoi(nodes[ind])); curr-\u0026gt;right = temp; q.push(temp); } else { curr-\u0026gt;right = nullptr; } ind++; } return root; } }; // Your Codec object will be instantiated and called as such: // Codec ser, deser; // TreeNode* ans = deser.deserialize(ser.serialize(root)); Complexity Analysis Time Complexity : O(n) where n is the number of nodes in the tree. Space Complexity : O(n) where n is the number of nodes in the tree. Explanation 1. Intuition 1. Serialization : - We can serialize a binary tree using level order traversal. - Use a queue to store the nodes of the tree. - If the node is not null, push the value of the node to the string and push the left and right child of the node to the queue. - If the node is null, push \u0026#34;null\u0026#34; to the string. - Use an appropriate delimiter to separate the values of the nodes. 2. Deserialization : - Split the string using the delimiter and store the values in a vector. - Create a queue and push the root node to the queue. - Iterate over the vector and create the left and right child of the current node. - Push the left and right child to the queue. - Return the root node. 2. Implementation 1. Serialization : - Initialize a string `ans` and a queue `q`. - Push the root node to the queue. - Iterate over the queue and check if the front of the queue is not null. - If the front of the queue is not null, push the value of the node to the string and push the left and right child of the node to the queue. - append the delimiter `#` to the string. - If the front of the queue is null, push \u0026#34;`null#`\u0026#34; to the string. - Return the string. 2. Deserialization : - Split the string using the delimiter `#` and store the values in a vector `nodes`. - If the first element of the vector is `\u0026#34;null\u0026#34;`, return `nullptr`. - Create a root node with the value of the first element of the vector. - Create a queue `q` and push the root node to the queue. - Initialize an index `ind` to 1. - Iterate over the queue and create the left and right child of the current node in the following manner - If the value at index `ind` is not `\u0026#34;null\u0026#34;`, create a new node with the value and assign it as the left child of the current node. - Push the left child to the queue. - Increment the index `ind`. - If the value at index `ind` is not `\u0026#34;null\u0026#34;`, create a new node with the value and assign it as the right child of the current node. - Push the right child to the queue. - Increment the index `ind`. - Return the root node. Picture credits : LeetCode\n","permalink":"https://KTS-o7.github.io/blog/posts/prev_solns/problem-serialize-and-deserialize-binary-tree/","tags":["binary-tree","string","queue","level-order-traversal","bfs"],"title":"Problem 297 Serialize and Deserialize Binary Tree"},{"categories":null,"content":"Problem Statement Link - Problem 1717 Question You are given a string s and two integers x and y. You can perform two types of operations any number of times.\nRemove substring \u0026quot;ab\u0026quot; and gain x points. For example, when removing \u0026quot;ab\u0026quot; from \u0026quot;cabxbae\u0026quot; it becomes \u0026quot;cxbae\u0026quot;. Remove substring \u0026quot;ba\u0026quot; and gain y points. For example, when removing \u0026quot;ba\u0026quot; from \u0026quot;cabxbae\u0026quot; it becomes \u0026quot;cabxe\u0026quot;. Return the maximum points you can gain after applying the above operations on s.\nExample 1 Input: s = \u0026#34;cdbcbbaaabab\u0026#34;, x = 4, y = 5 Output: 19 - Remove \u0026#34;ba\u0026#34; at index 5\u0026amp;6, s = \u0026#34;cdbcbaabab\u0026#34;, score = 5. - Remove \u0026#34;ba\u0026#34; at index 4\u0026amp;5 s = \u0026#34;cdbcabab\u0026#34;, score = 10. - Remove \u0026#34;ba\u0026#34; at index 5\u0026amp;6, s = \u0026#34;cdbcab\u0026#34;, score = 15. - Remove \u0026#34;ab\u0026#34; at index 4\u0026amp;5, s = \u0026#34;cdcb\u0026#34;, score = 19. Total score = 5 + 4 + 5 + 5 = 19. Example 2 Input: s = \u0026#34;aabbaaxybbaabb\u0026#34;, x = 5, y = 4 Output: 20 Explanation: - Remove the \u0026#34;ab\u0026#34; at index 1\u0026amp;2, s = \u0026#34;abaaxybbaabb\u0026#34;, score = 5. - Remove the \u0026#34;ab\u0026#34; at index 0\u0026amp;1, s = \u0026#34;aaxybbaabb\u0026#34;, score = 10. - Remove the \u0026#34;ab\u0026#34; at index 7\u0026amp;8, s = \u0026#34;aaxybbab\u0026#34;, score = 15. - Remove the \u0026#34;ab\u0026#34; at index 6\u0026amp;7, s = \u0026#34;aaxybb\u0026#34;, score = 20. Total score = 5 + 5 + 5 + 5 = 20. Constraints - `1 \u0026lt;= s.length \u0026lt;= 10^5` - `1 \u0026lt;= x, y \u0026lt;= 10^4` - `s` consists of lowercase English letters. Note By seeing the constraints we can say that the solution should be of linear time complexity. hence DP is not a good choice. We can solve this problem using stack. We will be using a greedy algorithm to solve this problem.\nWhy greedy? We can show the following :\nOnly \u0026#34;aba\u0026#34; and \u0026#34;bab\u0026#34; substrings can potentially lead to a different final score. Why only those? Because it is possible to remove either \u0026#34;ab\u0026#34; or \u0026#34;ba\u0026#34; in only in those cases. Now to the proof part: Assume we have string S. Consider any substring \u0026#34;aba\u0026#34; (or \u0026#34;bab\u0026#34;) in it: prefix of S | aba | suffix of S notice that removing either ab or ba leads to the same string : prefix of S | a | suffix of S (or prefix of S | b | suffix of S) This shows that we must always go for a replacement with the higher value. Solution class Solution { public: int maximumGain(string s, int x, int y) { std::ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); int res = 0; string top, bot; int top_score, bot_score; if (y \u0026gt; x) { top = \u0026#34;ba\u0026#34;; top_score = y; bot = \u0026#34;ab\u0026#34;; bot_score = x; } else { top = \u0026#34;ab\u0026#34;; top_score = x; bot = \u0026#34;ba\u0026#34;; bot_score = y; } stack\u0026lt;char\u0026gt;st; for(char ch:s){ if(ch == top[1] \u0026amp;\u0026amp; !st.empty() \u0026amp;\u0026amp; st.top() == top[0]){ res+=top_score; st.pop(); } else{ st.push(ch); } } stack\u0026lt;char\u0026gt;newst; char ch; while(!st.empty()){ ch = st.top(); st.pop(); if(ch == bot[0] \u0026amp;\u0026amp; !newst.empty() \u0026amp;\u0026amp; newst.top()==bot[1]){ res+=bot_score; newst.pop(); } else{ newst.push(ch); } } return res; } }; Complexity Analysis Time Complexity : O(N) Because we are iterating over the string once. Space Complexity : O(N) Explanation 1. Intuition - First we need to check which substring has higher score. - Set the `top` string to the substring with higher score. - Set the `bot` string to the substring with lower score. - Iterate over the string and check if the top substring can be formed. - If yes, then add the score to the result. - Else push the character to the stack. - Iterate over the stack and check if the bot substring can be formed. - If yes, then add the score to the result. - Else push the character to the new stack. - Return the result. 2. Implementation - Initialize the result `res` to 0. - Initialize the `top` and `bot` substrings and their respective scores. - Check which substring has higher score and set the `top` and `bot` substrings accordingly. - Initialize a stack `st` and iterate over the string `s`. - Check if the character is the second character of the `top` substring and the top of the stack is the first character of the `top` substring. - This is because stack stores the string in reverse order. - If the condition is true, then add the score to the result and pop the top of the stack. - Else push the character to the stack. - Initialize a new stack `newst` and a character `ch`. - Iterate over the stack `st` and check if the character is the first character of the `bot` substring and the top of the new stack is the second character of the `bot` substring. - If the condition is true, then add the score to the result and pop the top of the new stack. - Else push the character to the new stack. - Return the result. ","permalink":"https://KTS-o7.github.io/blog/posts/prev_solns/problem-maximum-score-from-removing-substrings/","tags":["stack","string"],"title":"Problem 1717 Maximum Score From Removing Substrings"},{"categories":null,"content":"Problem Statement Link - Problem 1190 Question You are given a string s that consists of lower case English letters and brackets.\nReverse the strings in each pair of matching parentheses, starting from the innermost one.\nYour result should not contain any brackets.\nExample 1 Input: s = \u0026#34;(abcd)\u0026#34; Output: \u0026#34;dcba\u0026#34; Example 2 Input: s = \u0026#34;(u(love)i)\u0026#34; Output: \u0026#34;iloveu\u0026#34; Explanation: The substring \u0026#34;love\u0026#34; is reversed first, then the whole string is reversed. Example 3 Input: s = \u0026#34;(ed(et(oc))el)\u0026#34; Output: \u0026#34;leetcode\u0026#34; Explanation: First, we reverse the substring \u0026#34;oc\u0026#34;, then \u0026#34;etco\u0026#34;, and finally, the whole string. Constraints - `1 \u0026lt;= s.length \u0026lt;= 2000` - `s` only contains lower case English characters and parentheses. - It is guaranteed that all parentheses are balanced. Solution class Solution { public: string reverseParentheses(string s) { stack\u0026lt;char\u0026gt; st; queue\u0026lt;char\u0026gt; q; string ans; for(char i : s){ if(i!=\u0026#39;)\u0026#39;) st.push(i); else{ while(st.top()!=\u0026#39;(\u0026#39;){ q.push(st.top()); st.pop(); } st.pop(); while(!q.empty()){ st.push(q.front()); q.pop(); } } } while(!st.empty()){ ans.push_back(st.top()); st.pop(); } reverse(ans.begin(),ans.end()); return ans; } }; Complexity Analysis Time Complexity : O(N) Because we are iterating over the string once. Space Complexity : O(N) Explanation 1. Intuition - We can use a stack and a queue to solve this problem. - We can iterate over the string and push the characters into the stack. - Till we encounter a closing bracket, we keep pushing the characters into the stack. - Once we encounter a closing bracket, we pop the characters from the stack and push them into the queue till we encounter an opening bracket. - Once we encounter an opening bracket, we pop the opening bracket from the stack. - We then push the characters from the queue back into the stack. - This will effectively reverse the characters between the brackets. - Once we process the entire string, we can pop the characters from the stack and append them to the answer string. - Finally, we reverse the answer string and return it. 2. Implementation - Initialize a stack `st`, a queue `q`, and a string `ans`. - Iterate over the string `s` and check if the character is not a closing bracket, then push it into the stack. - If the character is a closing bracket, then pop the characters from the stack and push them into the queue till we encounter an opening bracket. - Once we encounter an opening bracket, pop the opening bracket from the stack. - Push the characters from the queue back into the stack. - Once we process the entire string, pop the characters from the stack and append them to the answer string. - Reverse the answer string and return it. ","permalink":"https://KTS-o7.github.io/blog/posts/prev_solns/problem-reverse-substrings-between-each-pair-of-parentheses/","tags":["string","stack","queue"],"title":"Problem 1190 Reverse Substrings Between Each Pair of Parentheses"},{"categories":null,"content":"Problem Statement Link - Problem 1598 Question The Leetcode file system keeps a log each time some user performs a change folder operation.\nThe operations are described below:\n\u0026quot;../\u0026quot; : Move to the parent folder of the current folder. (If you are already in the main folder, remain in the same folder). \u0026quot;./\u0026quot; : Remain in the same folder. \u0026quot;x/\u0026quot; : Move to the child folder named x (This folder is guaranteed to always exist). You are given a list of strings logs where logs[i] is the operation performed by the user at the ith step. The file system starts in the main folder, then the operations in logs are performed.\nReturn the minimum number of operations needed to go back to the main folder after the change folder operations.\nExample 1 Input: logs = [\u0026#34;d1/\u0026#34;,\u0026#34;d2/\u0026#34;,\u0026#34;../\u0026#34;,\u0026#34;d21/\u0026#34;,\u0026#34;./\u0026#34;] Output: 2 Explanation: Use this change folder operation \u0026#34;../\u0026#34; 2 times and go back to the main folder. Example 2 Input: logs = [\u0026#34;d1/\u0026#34;,\u0026#34;d2/\u0026#34;,\u0026#34;./\u0026#34;,\u0026#34;d3/\u0026#34;,\u0026#34;../\u0026#34;,\u0026#34;d31/\u0026#34;] Output: 3 Example 3 Input: logs = [\u0026#34;d1/\u0026#34;,\u0026#34;../\u0026#34;,\u0026#34;../\u0026#34;,\u0026#34;../\u0026#34;] Output: 0 Constraints - `1 \u0026lt;= logs.length \u0026lt;= 10^3` - `2 \u0026lt;= logs[i].length \u0026lt;= 10` - logs[i] contains lowercase English letters, digits, \u0026#39;.\u0026#39;, and \u0026#39;/\u0026#39;. - logs[i] follows the format described in the statement. - Folder names consist of lowercase English letters and digits. Solution class Solution { public: int minOperations(vector\u0026lt;string\u0026gt;\u0026amp; logs) { int count = 0; std::ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); for(string it:logs) { if(it == \u0026#34;../\u0026#34;) { count--; if(count\u0026lt;0) count = 0; } else if(it != \u0026#34;./\u0026#34;) count++; } return count; } }; Complexity Analysis Time Complexity : O(N) Space Complexity : O(1) Explanation 1. Intuition - Since the directory is Linear in the given problem, we can keep track of the count of the operations. - If the operation is `../` then we decrement the count and if the count is less than 0, we reset it to 0. - If the operation is not `./` then we increment the count. - Finally, we return the count. 2. Implementation - Initialize the `count` to 0. - Iterate over the `logs` and check if the operation is `../` then decrement the `count` and reset it to 0 if it is less than 0. - If the operation is not `./` then increment the `count`. - Finally, return the `count`. ","permalink":"https://KTS-o7.github.io/blog/posts/prev_solns/problem-crawler-log-folder/","tags":["math","string"],"title":"Problem 1598 Crawler Log Folder"},{"categories":null,"content":"Problem Statement Link - Problem 1701 Question There is a restaurant with a single chef. You are given an array customers, where customers[i] = [arrivali, timei]:\n- arrivali is the arrival time of the ith customer. The arrival times are sorted in non-decreasing order.\ntimei is the time needed to prepare the order of the ith customer. When a customer arrives, he gives the chef his order, and the chef starts preparing it once he is idle. The customer waits till the chef finishes preparing his order. The chef does not prepare food for more than one customer at a time. The chef prepares food for customers in the order they were given in the input.\nReturn the average waiting time of all customers. Solutions within 10^-5 from the actual answer are considered accepted.\nExample 1 Input: customers = [[1,2],[2,5],[4,3]] Output: 5.00000 Explanation: 1. The first customer arrives at time 1, the chef takes his order and starts preparing it immediately at time 1, and finishes at time 3, so the waiting time of the first customer is 3 - 1 = 2. 2. The second customer arrives at time 2, the chef takes his order and starts preparing it at time 3, and finishes at time 8, so the waiting time of the second customer is 8 - 2 = 6. 3. The third customer arrives at time 4, the chef takes his order and starts preparing it at time 8, and finishes at time 11, so the waiting time of the third customer is 11 - 4 = 7. So the average waiting time = (2 + 6 + 7) / 3 = 5. Example 2 Input: customers = [[5,2],[5,4],[10,3],[20,1]] Output: 3.25000 Explanation: 1. The first customer arrives at time 5, the chef takes his order and starts preparing it immediately at time 5, and finishes at time 7, so the waiting time of the first customer is 7 - 5 = 2. 2. The second customer arrives at time 5, the chef takes his order and starts preparing it at time 7, and finishes at time 11, so the waiting time of the second customer is 11 - 5 = 6. 3. The third customer arrives at time 10, the chef takes his order and starts preparing it at time 11, and finishes at time 14, so the waiting time of the third customer is 14 - 10 = 4. 4. The fourth customer arrives at time 20, the chef takes his order and starts preparing it immediately at time 20, and finishes at time 21, so the waiting time of the fourth customer is 21 - 20 = 1. So the average waiting time = (2 + 6 + 4 + 1) / 4 = 3.25. Constraints - `1 \u0026lt;= customers.length \u0026lt;= 10^5` - `1 \u0026lt;= arrivali, timei \u0026lt;= 10^4` - `arrival(i) \u0026lt;= arrival(i+1)` Solution class Solution { public: double averageWaitingTime(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; customers) { std::ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); long long int endTime = customers[0][0] + customers[0][1]; double waitTime = customers[0][1]; int arrivalTime, time; vector\u0026lt;int\u0026gt; it; for(int i = 1; i\u0026lt;customers.size();i++) { it = customers[i]; arrivalTime = it[0]; time = it[1]; if(arrivalTime\u0026gt;endTime) { endTime = arrivalTime; } endTime += time; waitTime += endTime - arrivalTime; } return waitTime/customers.size(); } }; Complexity Analysis Time Complexity : O(N) Space Complexity : O(1) Explanation 1. Intuition - This just a calculation of FCFS scheduling. - Technically we are calculating the average turnaround time. - We know that `turn around time = end time - arrival time`. - `end time = service time + max(arrival time, previous end time)`. - So we need accumulate the turn around time and divide it by the number of customers. 2. Implementation - Initialize the `endTime` and `waitTime` with the first customer\u0026#39;s total time and service time respectively. - Iterate over the customers from the second customer. - Calculate the `arrivalTime` and `time` of the current customer. - If the `arrivalTime` is greater than the `endTime`, update the `endTime` with the `arrivalTime`. - This shows that chef is idle and had to wait for the customer to arrive. - Update the `endTime` with the `time` of the current customer. - Add the `endTime - arrivalTime` to the `waitTime`. - Return the `waitTime` divided by the number of customers. ","permalink":"https://KTS-o7.github.io/blog/posts/prev_solns/problem-average-waiting-time/","tags":["array","simulation"],"title":"Problem 1701 Average Waiting Time"},{"categories":null,"content":"Problem Statement Link - Problem 1823 Question There are n friends that are playing a game. The friends are sitting in a circle and are numbered from 1 to n in clockwise order. More formally, moving clockwise from the ith friend brings you to the (i+1)th friend for 1 \u0026lt;= i \u0026lt; n, and moving clockwise from the nth friend brings you to the 1st friend.\nThe rules of the game are as follows:\nStart at the 1st friend. Count the next k friends in the clockwise direction including the friend you started at. The counting wraps around the circle and may count some friends more than once. The last friend you counted leaves the circle and loses the game. If there is still more than one friend in the circle, go back to step 2 starting from the friend immediately clockwise of the friend who just lost and repeat. Else, the last friend in the circle wins the game. Given the number of friends, n, and an integer k, return the winner of the game. Note This is exactly the same as the Josephus problem, but with a different name. It is also called the n-people game.\nExample 1 Input: n = 5, k = 2 Output: 3 Explanation: Here are the steps of the game: 1. Start at friend 1. 2. Count 2 friends clockwise, which are friends 1 and 2. 3. Friend 2 leaves the circle. Next start is friend 3. 4. Count 2 friends clockwise, which are friends 3 and 4. 5. Friend 4 leaves the circle. Next start is friend 5. 6. Count 2 friends clockwise, which are friends 5 and 1. 7. Friend 1 leaves the circle. Next start is friend 3. 8. Count 2 friends clockwise, which are friends 3 and 5. 9. Friend 5 leaves the circle. Only friend 3 is left, so they are the winner. Example 2 Input: n = 6, k = 5 Output: 1 Explanation: The friends leave in this order: 5, 4, 6, 2, 3. The winner is friend 1. Constraints - `1 \u0026lt;= k \u0026lt;= n \u0026lt;= 500` Solution class Solution { public: int findTheWinner(int N, int k) { int i = 1, ans = 0; while (i \u0026lt;= N) { ans = (ans + k) % i; i++; } return ans + 1; } }; Complexity Analysis Time Complexity : O(N) Space Complexity : (1) Explanation 1. Intuition - We know that we can find the winner by simulating the result of each round from 1 to N. - We will count `k` friends in the clockwise direction including the friend we started at. - The quantity `ans` will store the index of the winner of each round. - We will return the winner of the last round. - The value `(ans+k)%i` will give us the index of the winner of the next round. - How does it give the index of winner ? - Let\u0026#39;s say we have `i` friends and we are at the `jth` friend. - We need to find the index of the winner of the next round. - We know that the winner of the next round will be the winner of the current round plus `k` friends. - but since the friends are being removed from the circle, we need to take the modulo of the number of friends got removed. - This will give us how many indexes we need to move from the current index to get the winner of the next round. TLDR - When there are n people, the person leaving is (k-1) positions away from the current starting person. - The new starting position is the next person clockwise after the person who leaves. - The winner for n people can be found using the winner of n-1 people adjusted by the counting step k. - Don\u0026#39;t forget to re-index to 1-indexing. Add 1 to the final answer. 2. Implementation - Initialize the variables `i` and `ans` to 1 and 0 respectively. - Iterate from 1 to N. - Update the value of `ans` to `(ans+k)%i`. - Return the value of `ans+1`. Alternate Approach class Solution { public: int findTheWinner(int n, int k) { // Initialize vector of N friends, labeled from 1-N vector\u0026lt;int\u0026gt; circle; for (int i = 1; i \u0026lt;= n; i++) { circle.push_back(i); } // Maintain the index of the friend to start the count on int startIndex = 0; // Perform eliminations while there is more than 1 friend left while (circle.size() \u0026gt; 1) { // Calculate the index of the friend to be removed int removalIndex = (startIndex + k - 1) % circle.size(); // Erase the friend at removalIndex circle.erase(circle.begin() + removalIndex); // Update startIndex for the next round startIndex = removalIndex; } return circle.front(); } }; Time Complexity: O(N^2) Space Complexity: O(N) Explanation - Just simulate the game by removing the friends one by one. - Keep track of the index of the friend to start the count on. - Calculate the index of the friend to be removed. - Erase the friend at the removal index. - Update the startIndex for the next round. - Return the winner of the game. ","permalink":"https://KTS-o7.github.io/blog/posts/prev_solns/problem-find-the-winner-of-the-circular-game/","tags":["math","iteration"],"title":"Problem 1823 Find the Winner of the Circular Game"},{"categories":null,"content":"Problem Statement Link - Problem 1518 Question There are numBottles water bottles that are initially full of water. You can exchange bumExchange empty water bottles for one full water bottle. The operation of drinking a full water bottle turns it into an empty bottle.\nGiven two integers numBottles and numExchange, return the maximum number of water bottles you can drink.\nExample 1 Input: numBottles = 9, numExchange = 3 Output: 13 Explanation: You can exchange 3 empty bottles to get 1 full water bottle. Number of water bottles you can drink: 9 + 3 + 1 = 13. Example 2 Input: numBottles = 15, numExchange = 4 Output: 19 Explanation: You can exchange 4 empty bottles to get 1 full water bottle. Number of water bottles you can drink: 15 + 3 + 1 = 19. Constraints - `1 \u0026lt;= numBottles \u0026lt;= 100` - `2 \u0026lt;= numExchange \u0026lt;= 100` Solution class Solution { public: int numWaterBottles(int numBottles, int numExchange) { int numEmpty = 0, res = 0; while (numBottles) { res += numBottles; numEmpty += numBottles; numBottles = numEmpty / numExchange; numEmpty = numEmpty % numExchange; } return res; } }; Complexity Analysis Time Complexity : O(N) Space Complexity : O(1) Explanation 1. Intuition - We need to calculate the maximum number of water bottles we can drink. - First assign the number of empty bottles to 0 and the result to 0. - While the number of bottles is not 0, add the number of bottles to the result.(Simulates drinking the water) - Add the number of bottles to the number of empty bottles.(Simulates the number of empty bottles generated) - Calculate the number of bottles that can be exchanged for full bottles and the number of empty bottles left. - This will be empty bottles/numExchange. - Calculate the left over empty bottles. - This will be empty bottles%numExchange. - Continue the process until the number of bottles is not 0. 2. Implementation - Assign the number of empty bottles `numEmpty` to 0 and the result `res` to 0. - While `numBottles` is not 0, do: 1. Add the `numBottles` to the `res`. 2. Add the `numBottles` to the `numEmpty`. 3. Update the `numBottles` to `numEmpty/numExchange`. - This simulates the number of bottles that can be exchanged for full bottles. 4. Update the `numEmpty` to `numEmpty%numExchange`. - This simulates the number of empty bottles left after exchanging. 5. Continue the process until the number of bottles is not 0. - Return the result. Mathematical solution class Solution { public: int numWaterBottles(int numBottles, int numExchange) { return numBottles + (numBottles - 1) / (numExchange - 1); } }; Explanation - The mathematical solution is derived from the fact that we can drink all the water bottles and exchange the empty bottles for full bottles. - How many empty bottles can we exchange for full bottles? - If we give `numExchange` empty bottles, we can get 1 full bottle. - Then its same as giving out `numExchange - 1` empty bottles to get a refill. - If we keep aside 1 bottle to fill the refill, we can exchange `numBottles-1`. - Hence, the total number of bottles we can drink = `numBottles + (numBottles - 1) / (numExchange - 1)`. ","permalink":"https://KTS-o7.github.io/blog/posts/prev_solns/problem-water-bottles/","tags":["math"],"title":"Problem 1518 Water Bottles"},{"categories":null,"content":"Problem Statement Link - Problem 2582 Question There are n people standing in a line labeled from 1 to n. The first person in the line is holding a pillow initially. Every second, the person holding the pillow passes it to the next person standing in the line. Once the pillow reaches the end of the line, the direction changes, and people continue passing the pillow in the opposite direction.\nFor example, once the pillow reaches the nth person they pass it to the n - 1th person, then to the n - 2th person and so on. Given the two positive integers n and time, return the index of the person holding the pillow after time seconds.\nExample 1 Input: n = 4, time = 5 Output: 2 Explanation: People pass the pillow in the following way: 1 -\u0026gt; 2 -\u0026gt; 3 -\u0026gt; 4 -\u0026gt; 3 -\u0026gt; 2. After five seconds, the 2nd person is holding the pillow. Example 2 Input: n = 3, time = 2 Output: 3 Explanation: People pass the pillow in the following way: 1 -\u0026gt; 2 -\u0026gt; 3. After two seconds, the 3rd person is holding the pillow. Constraints - 2 \u0026lt;= n \u0026lt;= 1000 - 1 \u0026lt;= time \u0026lt;= 1000 Solution class Solution { public: int passThePillow(int n, int time) { int direc = time/(n-1); int pos = time%(n-1); if(direc%2==0) return pos+1; else return n-pos; } }; Complexity Analysis Time Complexity : O(1) Space Complexity : O(1) Explanation 1. Intuition - Since the pillow is passed in a cyclic manner, we can calculate the direction and position of the person holding the pillow after time seconds. - The pillow changes direction after every n-1 seconds. - This can be proved by taking an example of n=4 and time=5. - at 0th second, the pillow is at 1st position. - at 1st second, the pillow is at 2nd position. - at 2nd second, the pillow is at 3rd position. - at 3rd second, the pillow is at 4th position. - at 4th second, the pillow is at 3rd position. - at 5th second, the pillow is at 2nd position. - Hence, the pillow changes direction after every n-1 seconds. - If we calculate the number of times the pillow changes direction, we can calculate the position of the person holding the pillow after time seconds. - Number of times the pillow changes direction = time/(n-1). - The relative position of the person holding the pillow after time seconds = time%(n-1). - If the direction is even, the position of the person holding the pillow = pos+1. (this means the pillow was moving from left to right) - If the direction is odd, the position of the person holding the pillow = n-pos. (this means the pillow was moving from right to left) 2. Implementation - declare a variable `direc` = time/(n-1). - This will give the number of times the pillow changes direction. - declare a variable `pos` = time%(n-1). - This will give the relative position of the person holding the pillow after time seconds. - If the direction is even, return pos+1. - If the direction is odd, return n-pos. ","permalink":"https://KTS-o7.github.io/blog/posts/prev_solns/problem-pass-the-pillow/","tags":["math"],"title":"Problem 2582 Pass the Pillow"},{"categories":null,"content":"Problem Statement Link - Problem 2058 Question A critical point in a linked list is defined as either a local maxima or a local minima.\nA node is a local maxima if the current node has a value strictly greater than the previous node and the next node.\nA node is a local minima if the current node has a value strictly smaller than the previous node and the next node.\nNote that a node can only be a local maxima/minima if there exists both a previous node and a next node.\nGiven a linked list head, return an array of length 2 containing [minDistance, maxDistance] where minDistance is the minimum distance between any two distinct critical points and maxDistance is the maximum distance between any two distinct critical points. If there are fewer than two critical points, return [-1, -1].\nExample 1 graph LR A((3)) --\u003e B((1)) Input: head = [3,1] Output: [-1,-1] Explanation: There are no critical points in [3,1]. Example 2 graph LR A((5)) --\u003e B((3)) B --\u003e C((1)) C --\u003e D((2)) D --\u003e E((5)) E --\u003e F((1)) F --\u003e G((2)) Input: head = [5,3,1,2,5,1,2] Output: [1,3] Explanation: There are three critical points: - [5,3,1,2,5,1,2]: The third node is a local minima because 1 is less than 3 and 2. - [5,3,1,2,5,1,2]: The fifth node is a local maxima because 5 is greater than 2 and 1. - [5,3,1,2,5,1,2]: The sixth node is a local minima because 1 is less than 5 and 2. The minimum distance is between the fifth and the sixth node. minDistance = 6 - 5 = 1. The maximum distance is between the third and the sixth node. maxDistance = 6 - 3 = 3. Example 3 graph LR A((1)) --\u003e B((3)) B --\u003e C((2)) C --\u003e D((2)) D --\u003e E((3)) E --\u003e F((2)) F --\u003e G((2)) G --\u003e H((2)) H --\u003e I((7)) Input: head = [1,3,2,2,3,2,2,2,7] Output: [3,3] Explanation: There are two critical points: - [1,3,2,2,3,2,2,2,7]: The second node is a local maxima because 3 is greater than 1 and 2. - [1,3,2,2,3,2,2,2,7]: The fifth node is a local maxima because 3 is greater than 2 and 2. Both the minimum and maximum distances are between the second and the fifth node. Thus, minDistance and maxDistance is 5 - 2 = 3. Note that the last node is not considered a local maxima because it does not have a next node. Constraints - The number of nodes in the list is in the range `[2, 10^5]`. - `1 \u0026lt;= Node.val \u0026lt;= 10^5` Solution /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ class Solution { public: vector\u0026lt;int\u0026gt; nodesBetweenCriticalPoints(ListNode* head) { std::ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); ListNode* prev = head; ListNode* curr = head-\u0026gt;next; if(head-\u0026gt;next == nullptr) return {-1,-1}; vector\u0026lt;int\u0026gt;positions; int ind = 1; while(curr-\u0026gt;next!=nullptr) { if((prev-\u0026gt;val\u0026lt;curr-\u0026gt;val \u0026amp;\u0026amp; curr-\u0026gt;val\u0026gt;curr-\u0026gt;next-\u0026gt;val)||(prev-\u0026gt;val\u0026gt;curr-\u0026gt;val \u0026amp;\u0026amp; curr-\u0026gt;val\u0026lt;curr-\u0026gt;next-\u0026gt;val)) { positions.push_back(ind); } ind++; prev = curr; curr =curr-\u0026gt;next; } if(positions.size()\u0026lt;2) return {-1,-1}; int mini = INT_MAX; for(int i = 1;i\u0026lt;positions.size();i++) mini = min(mini,positions[i]-positions[i-1]); return {mini,positions.back() - positions.front()}; } }; Complexity Analysis Time Complexity : O(n) Space Complexity : O(1) excluding the space for the output list. Explanation 1. Intuition - We need to find the critical points in the linked list and then find the minimum and maximum distance between them. - That means first we have to find the indexes of the critical points. - Then we can find the minimum and maximum distance between them. - We can find the critical points by comparing the current node with the previous and the next node. - Create an ascending sequence of the indexes of the critical points. - Maximum will be the difference between the last and the first index. - Minimum will be the minimum difference between the indexes. - Edge cases are when there are no critical points or only one critical point. - When there is less than 3 nodes in the linked list, there will be no critical points. 2. Implementation - Delcare two pointers `prev` and `curr` to traverse the linked list. - `prev` will point to the `head` and `curr` will point to the next node. - If there are less than 2 nodes in the linked list, return `[-1,-1]`. - Declare a vector `positions` to store the indexes of the critical points. - Declare an integer `ind` to store the index of the current node, initialize it to 1. - While `curr-\u0026gt;next` is not `nullptr` 1. If the current node is a critical point, add the index to the `positions` vector. 2. Increment the index `ind`. 3. Move the `prev` and `curr` pointers to the next node. - If there are less than 2 critical points, return `[-1,-1]`. - Initialize an integer `mini` to `INT_MAX`. - Iterate over the `positions` vector from the second element to the last element. 1. Find the minimum difference between the indexes of the critical points. - Return the minimum and maximum distance between the critical points. ","permalink":"https://KTS-o7.github.io/blog/posts/prev_solns/problem-find-the-minimum-and-maximum-number-of-nodes-between-critical-points/","tags":["linked-list","pointers","math"],"title":"Problem 2058 Find the Minimum and Maximum Number of Nodes Between Critical Points"},{"categories":null,"content":"Problem Statement Link - Problem 2181 Question You are given the head of a linked list, which contains a series of integers separated by 0\u0026rsquo;s. The beginning and end of the linked list will have Node.val == 0.\nFor every two consecutive 0\u0026rsquo;s, merge all the nodes lying in between them into a single node whose value is the sum of all the merged nodes. The modified list should not contain any 0\u0026rsquo;s.\nReturn the head of the modified linked list.\nExample 1 graph LR A((0))--\u003eB((3)) B--\u003eC((1)) C--\u003eD((0)) D--\u003eE((4)) E--\u003eF((5)) F--\u003eG((2)) G--\u003eH((0)) Input: head = [0,3,1,0,4,5,2,0] Output: [4,11] Explanation: The above figure represents the given linked list. The modified list contains - The sum of the nodes marked in green: 3 + 1 = 4. - The sum of the nodes marked in red: 4 + 5 + 2 = 11. Example 2 graph LR A((0))--\u003eB((1)) B--\u003eC((0)) C--\u003eD((3)) D--\u003eE((0)) E--\u003eF((2)) F--\u003eG((2)) G--\u003eH((0)) Input: head = [0,1,0,3,0,2,2,0] Output: [1,3,4] Explanation: The above figure represents the given linked list. The modified list contains - The sum of the nodes marked in green: 1 = 1. - The sum of the nodes marked in red: 3 = 3. - The sum of the nodes marked in yellow: 2 + 2 = 4. Constraints - The number of nodes in the list is in the range `[3, 2 * 10^5]`. - `0 \u0026lt;= Node.val \u0026lt;= 1000` - There are no two consecutive nodes with` Node.val == 0`. - The beginning and end of the linked list have `Node.val == 0`. Solution /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ class Solution { public: ListNode* mergeNodes(ListNode* head) { std::ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); ListNode* dummy = new ListNode(0); ListNode* prev = dummy; int sum; ListNode* curr = head; while (curr != nullptr) { sum = 0; while (curr != nullptr \u0026amp;\u0026amp; curr-\u0026gt;val == 0) { curr = curr-\u0026gt;next; } while (curr != nullptr \u0026amp;\u0026amp; curr-\u0026gt;val != 0) { sum += curr-\u0026gt;val; curr = curr-\u0026gt;next; } if (sum != 0) { prev-\u0026gt;next = new ListNode(sum); prev = prev-\u0026gt;next; } } return dummy-\u0026gt;next; } }; Complexity Analysis Time Complexity : O(n) Space Complexity : O(1) excluding the space for the output list. Explanation 1. Intuition - We can use the zeroes as the delimiter to merge the nodes in between them. - Use one pointer to traverse the list. If value is zero skip the current node and start adding the values of the nodes until the next zero is encountered. - Once we encounter the next zero, we can add the sum of the nodes to the output list. - Keep repeating the above steps until the end of the list is reached. - Return the output list. 2. Implementation - Initialize a `dummy` node to 0. - Initialize a `prev` pointer to `dummy`. - Initialize a `sum` variable to 0. - Initialize a `curr` pointer to `head`. - Traverse the list until the end of the list is reached. - While traversing the list 1. Skip the current node till the value is zero. 2. Add the values of the nodes until the next zero is encountered. 3. If the sum is not zero then add the sum to the output list. - Return the output list. ","permalink":"https://KTS-o7.github.io/blog/posts/prev_solns/problem-merge-nodes-in-between-zeros/","tags":["linked-list","pointers"],"title":"Problem 2181 Merge Nodes in Between Zeros"},{"categories":null,"content":"Problem Statement Link - Problem 1509 Question You are given an integer array nums.\nIn one move, you can choose one element of nums and change it to any value.\nReturn the minimum difference between the largest and smallest value of nums after performing at most three moves\nExample 1 Input: nums = [5,3,2,4] Output: 0 Explanation: We can make at most 3 moves. In the first move, change 2 to 3. nums becomes [5,3,3,4]. In the second move, change 4 to 3. nums becomes [5,3,3,3]. In the third move, change 5 to 3. nums becomes [3,3,3,3]. After performing 3 moves, the difference between the minimum and maximum is 3 - 3 = 0 Example 2 Input: nums = [1,5,0,10,14] Output: 1 Explanation: We can make at most 3 moves. In the first move, change 5 to 0. nums becomes [1,0,0,10,14]. In the second move, change 10 to 0. nums becomes [1,0,0,0,14]. In the third move, change 14 to 1. nums becomes [1,0,0,0,1]. After performing 3 moves, the difference between the minimum and maximum is 1 - 0 = 1. It can be shown that there is no way to make the difference 0 in 3 moves. Example 3 Input: nums = [6,6,0,1,1,4,6] Output: 2 Explanation: We can make at most 3 moves. In the first move change 0 to 6 In the second move change 1 to 6 In the third move change 1 to 6 After performing 3 moves, the difference between the minimum and maximum is 6 - 4 = 2 Constraints - 1 \u0026lt;= nums.length \u0026lt;= 10^5 - -10^9 \u0026lt;= nums[i] \u0026lt;= 10^9 Solution class Solution { public: int minDifference(vector\u0026lt;int\u0026gt;\u0026amp; nums) { if(nums.size()\u0026lt;=4) return 0; std::ios::sync_with_stdio(false); sort(nums.begin(),nums.end()); int ans = INT_MAX; for(int i = 0; i \u0026lt;= 3; i++) { ans = min(ans, nums[nums.size() -1 -(3 - i)] - nums[i]); } return ans; } }; Complexity Analysis Time Complexity : O(nlogn) Space Complexity : O(1) Explanation 1. Intuition - To get the minimum difference between the largest and smallest value we have the following logic. - If the size of array is less than or equal to 4 then we can change every element to the same value, hence difference will be 0. - If the size of the array is greater than 4 then we need to sort the array. - Since we have 3 moves it means we can change 3 numbers. - These are the possible combinations we can do to find a lower difference. 1. make the last 3 elements same as first element.(equivalent of removing last 3 elements.) then the difference will be nums[nums.size() - 4] - nums[0] 2. make the first 3 elements same as last element. (equivalent of removing first 3 elements.) then the difference will be nums[nums.size() - 1] - nums[3] 3. make first 2 elements and last element same.(equivalent of removing first 2 elements and last element) then the difference will be nums[nums.size()-2]-nums[2] 4. make the last 2 elements and first element same.(equivalent of removing last 2 elements and first element) then difference will be nums[nums.size()-3]-nums[1] - The answer will be minimum of these 4. 2. Implementation - If the size of `nums` is less than or equal to 4 then return 0. - Else sort the array. - Initialize `ans` to `INT_MAX`. - Iterate from 0 to 3. - Update `ans` to minimum of `ans` and `nums[nums.size() -1 -(3 - i)] - nums[i]`. - This will calculate the above mentioned 4 combinations and return the minimum difference. ","permalink":"https://KTS-o7.github.io/blog/posts/prev_solns/problem-minimum-difference-between-largest-and-smallest-value-in-three-moves/","tags":["sorting","greedy"],"title":"Problem 1509 Minimum Difference Between Largest and Smallest Value in Three Moves"},{"categories":null,"content":"Problem Statement Link - Problem 350 Question Given two integer arrays nums1 and nums2, return an array of their intersection. Each element in the result must appear as many times as it shows in both arrays and you may return the result in any order.\nExample 1 Input: nums1 = [1,2,2,1], nums2 = [2,2] Output: [2,2] Example 2 Input: nums1 = [4,9,5], nums2 = [9,4,9,8,4] Output: [4,9] Explanation: [9,4] is also accepted.r Constraints - 1 \u0026lt;= nums1.length, nums2.length \u0026lt;= 1000 - 0 \u0026lt;= nums1[i], nums2[i] \u0026lt;= 1000 Solution // Iterative Solution class Solution { public: vector\u0026lt;int\u0026gt; intersect(vector\u0026lt;int\u0026gt;\u0026amp; nums1, vector\u0026lt;int\u0026gt;\u0026amp; nums2) { vector\u0026lt;int\u0026gt;freq(1001,0); for(int it:nums1){ freq[it]++; } vector\u0026lt;int\u0026gt;ans; for(int it:nums2){ if(freq[it]\u0026gt;0){ ans.push_back(it); freq[it]--; } } return ans; } }; Complexity Analysis Time Complexity : O(n) Space Complexity : O(n) Explanation 1. Intuition - We just need to copy the repeated elements from both arrays to the resultant array. - We can use a hashmap to store the frequency of elements in the first array. - Then we can iterate over the second array and check if the element is present in the hashmap. - If it is present, we can copy it to the resultant array and decrement the frequency in the hashmap. - Finally, we return the resultant array. 2. Implementation - Initialize a hashmap `freq` to store the frequency of elements in the first array. - Iterate over the first array and store the frequency of each element in the hashmap. - Initialize an empty vector `ans` to store the resultant array. - Iterate over the second array and check if the element is present in the hashmap. - If it is present, copy it to the resultant array and decrement the frequency in the hashmap. - Finally, return the resultant array. Binary Search Solution // Binary Search Solution class Solution { public: static vector\u0026lt;int\u0026gt; intersect(vector\u0026lt;int\u0026gt;\u0026amp; nums1, vector\u0026lt;int\u0026gt;\u0026amp; nums2) { if (nums1.size()\u0026lt;nums2.size()) return intersect(nums2, nums1); sort(nums1.begin(), nums1.end()); sort(nums2.begin(), nums2.end()); int sz=0, n1=nums1.size(), n2=nums2.size(); for (int i = 0, j = 0; i \u0026lt; n1 \u0026amp;\u0026amp; j \u0026lt; n2;) { int x=nums1[i], y=nums2[j]; if (x==y){ nums2[sz++] = x; i++; j++; } else if (x\u0026lt;y)// move i such that nums1[i]\u0026gt;=y i=lower_bound(nums1.begin()+i+1, nums1.end(), y)-nums1.begin(); else // x\u0026gt;y. Move j such that nums2[j]\u0026gt;=x j=lower_bound(nums2.begin()+j+1, nums2.end(), x)-nums2.begin(); } nums2.resize(sz); return nums2; } }; Explanation - We first sort both arrays. - We then iterate over both arrays using two pointers. - If the elements at the two pointers are equal, we copy the element to the resultant array and increment both pointers. - If the element in the first array is less than the element in the second array, we move the first pointer to the next element that is greater than or equal to the element in the second array. - If the element in the first array is greater than the element in the second array, we move the second pointer to the next element that is greater than or equal to the element in the first array. - Finally, we resize the resultant array to the size of the intersection and return it. Time Complexity: O(nlogn) Space Complexity: O(1) ","permalink":"https://KTS-o7.github.io/blog/posts/prev_solns/problem-intersection-of-two-arrays-ii/","tags":["arrays","hashmap","binary-search","sorting","two-pointer"],"title":"Problem 350 Intersection of Two Arrays II"},{"categories":null,"content":"Problem Statement Link - Problem 1550 Question Given an integer array arr, return true if there are three consecutive odd numbers in the array. Otherwise, return false.\nExample 1 Input: arr = [2,6,4,1] Output: false Explanation: There are no three consecutive odds. Example 2 Input: arr = [1,2,34,3,4,5,7,23,12] Output: true Explanation: [5,7,23] are three consecutive odds. Constraints - `1 \u0026lt;= arr.length \u0026lt;= 1000` - `1 \u0026lt;= arr[i] \u0026lt;= 1000` Solution class Solution { public: bool threeConsecutiveOdds(vector\u0026lt;int\u0026gt;\u0026amp; arr) { if(arr.size()==1||arr.size()==2) return false; for(int i=0;i\u0026lt;arr.size()-2;i++) { if(arr[i]%2!=0) { if(arr[i+1]%2 !=0 \u0026amp;\u0026amp; arr[i+2]%2 !=0) { return true; } } } return false; } }; Complexity Analysis Time Complexity : O(n) Space Complexity : O(1) Explanation 1. Intuition - We just need to check if there are three consecutive odd numbers in the array. - If we find such a sequence, we return true. - Otherwise, we return false. - If we find the current number to be odd check if next two numbers are also odd. 2. Implementation - If the size of the array is less than 3, return false. - Iterate from `0` to `n-2`. - Check if `arr[i]` is odd. - If it is odd, check if `arr[i+1]` and `arr[i+2]` are also odd. - If they are, return true. - If no such sequence is found, return false. ","permalink":"https://KTS-o7.github.io/blog/posts/prev_solns/problem-three-consecutive-odds/","tags":["array","parity"],"title":"Problem 1550 Three Consecutive Odds"},{"categories":null,"content":"Problem Statement Link - Problem 226 Question Given the root of a binary tree, invert the tree and return its root.\nExample 1 Input: root = [4,2,7,1,3,6,9] Output: [4,7,2,9,6,3,1] Input: graph TD 4 --- 2 4 --- 7 2 --- 1 2 --- 3 7 --- 6 7 --- 9 Output : graph TD 4 --- 7 4 --- 2 7 --- 9 7 --- 6 2 --- 3 2 --- 1 Example 2 Input: root = [2,1,3] Output: [2,3,1] Input : graph TD 2 --- 1 2 --- 3 Output : graph TD 2 --- 3 2 --- 1 Example 3 Input: root = [] Output: [] Constraints - The number of nodes in the tree is in the range `[0, 100]`. - `-100 \u0026lt;= Node.val \u0026lt;= 100` Solution /* * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: void invert(TreeNode* root) { if(root) { swap(root-\u0026gt;left,root-\u0026gt;right); invert(root-\u0026gt;left); invert(root-\u0026gt;right); } else return; } TreeNode* invertTree(TreeNode* root) { invert(root); return root; } }; Complexity Analysis Time Complexity : O(N) Space Complexity : O(N) Explanation 1. Intuition - We need to produce a mirror image of the binary tree. - To do this we just need to swap the left and right subtrees recursively. 2. Implementation - Define a helper function `invert` which takes a `TreeNode*` as input. - If the root is not null, swap the left and right subtrees. - Recursively call the `invert` function on the left and right subtrees. - Return the root. ","permalink":"https://KTS-o7.github.io/blog/posts/prev_solns/problem-invert-binary-tree/","tags":["binary-tree","tree","recursion"],"title":"Problem 226 Invert Binary Tree"},{"categories":null,"content":"Problem Statement Link - Problem 2192 Question You are given a positive integer n representing the number of nodes of a Directed Acyclic Graph (DAG). The nodes are numbered from 0 to n - 1 (inclusive).\nYou are also given a 2D integer array edges, where edges[i] = [fromi, toi] denotes that there is a unidirectional edge from fromi to toi in the graph.\nReturn a list answer, where answer[i] is the list of ancestors of the ith node, sorted in ascending order.\nA node u is an ancestor of another node v if u can reach v via a set of edges.\nExample 1 Input: n = 8, edgeList = [[0,3],[0,4],[1,3],[2,4],[2,7],[3,5],[3,6],[3,7],[4,6]] Output: [[],[],[],[0,1],[0,2],[0,1,3],[0,1,2,3,4],[0,1,2,3]] Explanation: The above diagram represents the input graph. - Nodes 0, 1, and 2 do not have any ancestors. - Node 3 has two ancestors 0 and 1. - Node 4 has two ancestors 0 and 2. - Node 5 has three ancestors 0, 1, and 3. - Node 6 has five ancestors 0, 1, 2, 3, and 4. - Node 7 has four ancestors 0, 1, 2, and 3. graph TD 0 --\u003e 3 0 --\u003e 4 1 --\u003e 3 2 --\u003e 4 2 --\u003e 7 3 --\u003e 5 3 --\u003e 6 3 --\u003e 7 4 --\u003e 6 Example 2 Input: n = 5, edgeList = [[0,1],[0,2],[0,3],[0,4],[1,2],[1,3],[1,4],[2,3],[2,4],[3,4]] Output: [[],[0],[0,1],[0,1,2],[0,1,2,3]] Explanation: The above diagram represents the input graph. - Node 0 does not have any ancestor. - Node 1 has one ancestor 0. - Node 2 has two ancestors 0 and 1. - Node 3 has three ancestors 0, 1, and 2. - Node 4 has four ancestors 0, 1, 2, and 3. graph TD 0 --\u003e 1 0 --\u003e 2 0 --\u003e 3 0 --\u003e 4 1 --\u003e 2 1 --\u003e 3 1 --\u003e 4 2 --\u003e 3 2 --\u003e 4 3 --\u003e 4 Constraints - `1 \u0026lt;= n \u0026lt;= 1000` - `0 \u0026lt;= edges.length \u0026lt;= min(2000, n * (n - 1) / 2)` - `edges[i].length == 2` - `0 \u0026lt;= fromi, toi \u0026lt;= n - 1` - `fromi != toi` - There are no duplicate edges. - The graph is **directed** and **acyclic** Solution class Solution { public: void dfs(vector\u0026lt;bool\u0026gt;\u0026amp; visited, vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; adjList, vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; ancestor ,int parent, int curr) { visited[curr] = true; for( int forward:adjList[curr]) { if(!visited[forward]) { ancestor[forward].push_back(parent); dfs(visited,adjList,ancestor,parent,forward); } } } vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; getAncestors(int n, vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; edges) { std::ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; adjList(n); vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; ancestor(n); for (const auto\u0026amp; edge : edges) { adjList[edge[0]].push_back(edge[1]); } for(int i = 0; i\u0026lt;n; i++){ vector\u0026lt;bool\u0026gt;visited(n,false); dfs(visited,adjList,ancestor,i,i); } //for(int i = 0;i \u0026lt;n; i++) //sort(ancestor[i].begin(),ancestor[i].end()); return ancestor; } }; Complexity Analysis Time Complexity : O(n) - where n is the number of nodes in the graph Space Complexity : O(n) - where n is the number of nodes in the graph Explanation 1. Intuition - We need to find the ancestors of each node in the graph and store it in sorted order in form of a list. - To find the ancestors of a node we can perform a DFS traversal of the graph. - We can start the DFS traversal from each node and keep track of the parent node. - For each children nodes which is reachable from the current node, we can add the parent node as an ancestor. - To prevent multiple visits to the same node we can use a visited array. 2. Implementation - We can create an adjacency list `adjList` to store the graph. - We can create a 2D vector `ancestor` to store the ancestors of each node. - Now we will perform the DFS traversal of the graph. - For each node from `0` to `n-1` , create a new `visted` array and call the `dfs` function. - DFS Function - Input : `visited` array, `adjList`, `ancestor` array, `parent` node, `current` node - Output : void - mark the current node as visited - for each forward node reachable from the current node - if the forward node is not visited - add the parent node as an ancestor of the forward node - call the dfs function recursively for the forward node 3. Dry Run - Let\u0026#39;s dry run the first example to understand the solution better. - We have `n = 8` and `edgeList = [[0,3],[0,4],[1,3],[2,4],[2,7],[3,5],[3,6],[3,7],[4,6]]` - The adjaceny list is as follows: - 0 -\u0026gt; 3,4 - 1 -\u0026gt; 3 - 2 -\u0026gt; 4,7 - 3 -\u0026gt; 5,6,7 - 4 -\u0026gt; 6 - 5 -\u0026gt; - 6 -\u0026gt; - 7 -\u0026gt; - We will start the DFS traversal from each node and find the ancestors. - For node 0, the ancestors are [] - For node 1, the ancestors are [] - For node 2, the ancestors are [] - For node 3, the ancestors are [0,1] - For node 4, the ancestors are [0,2] - For node 5, the ancestors are [0,1,3] - For node 6, the ancestors are [0,1,2,3,4] - For node 7, the ancestors are [0,1,2,3] The solution automatically gives the output in sorted form because the order of parent nodes is maintained while performing the DFS traversal.\n","permalink":"https://KTS-o7.github.io/blog/posts/prev_solns/problem-all-ancestors-of-a-node-in-a-dag/","tags":["graph","dfs","DAG","adjacency-list"],"title":"Problem 2192 All Ancestors of a Node in a DAG"},{"categories":null,"content":"Problem Statement Link - Problem 2285 Question You are given an integer n denoting the number of cities in a country. The cities are numbered from 0 to n - 1.\nYou are also given a 2D integer array roads where roads[i] = [ai, bi] denotes that there exists a bidirectional road connecting cities ai and bi.\nYou need to assign each city with an integer value from 1 to n, where each value can only be used once. The importance of a road is then defined as the sum of the values of the two cities it connects.\nReturn the maximum total importance of all roads possible after assigning the values optimally.\nExample 1 Input: n = 5, roads = [[0,1],[1,2],[2,3],[0,2],[1,3],[2,4]] Output: 43 Explanation: The figure above shows the country and the assigned values of [2,4,5,3,1]. - The road (0,1) has an importance of 2 + 4 = 6. - The road (1,2) has an importance of 4 + 5 = 9. - The road (2,3) has an importance of 5 + 3 = 8. - The road (0,2) has an importance of 2 + 5 = 7. - The road (1,3) has an importance of 4 + 3 = 7. - The road (2,4) has an importance of 5 + 1 = 6. The total importance of all roads is 6 + 9 + 8 + 7 + 7 + 6 = 43. It can be shown that we cannot obtain a greater total importance than 43. 1 / | \\ 0 --|-- 2 -- 4 \\ | / 3 Example 2 Input: n = 5, roads = [[0,3],[2,4],[1,3]] Output: 20 Explanation: The figure above shows the country and the assigned values of [4,3,2,5,1]. - The road (0,3) has an importance of 4 + 5 = 9. - The road (2,4) has an importance of 2 + 1 = 3. - The road (1,3) has an importance of 3 + 5 = 8. The total importance of all roads is 9 + 3 + 8 = 20. It can be shown that we cannot obtain a greater total importance than 20. 3 2 / \\ | 0 1 4 Constraints - `2 \u0026lt;= n \u0026lt;= 5 * 10^4` - `1 \u0026lt;= roads.length \u0026lt;= 5 * 10^4` - `roads[i].length == 2` - `0 \u0026lt;= ai, bi \u0026lt;= n - 1` - `ai != bi` - There are no duplicate `roads`. Solution class Solution { public: long long maximumImportance(int n, vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; roads) { std::ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); vector\u0026lt;long long int\u0026gt;freq(n,0); for(const vector\u0026lt;int\u0026gt;\u0026amp; it:roads) { freq[it[0]]++; freq[it[1]]++; } sort(freq.begin(),freq.end()); long long int ans = 0; /*priority_queue\u0026lt;pair\u0026lt;long long int,int\u0026gt;\u0026gt;pq; for(int i = 0;i\u0026lt;n;i++) pq.push({freq[i],i}); for(int i = n;i\u0026gt;0;i--) { ans += pq.top().first * i; pq.pop(); }*/ for(int i =n;i\u0026gt;0;i--) { ans+=freq[i-1]*i; } return ans; } }; Complexity Analysis Time Complexity : O(nlogn) Space Complexity : O(n) Explanation 1. Intuition - Looking at the problem we can see that importance of a node is directly proportional to the number of roads connected to it. - So the node with highest number of roads must have higher importance. - We know that each edge will connect 2 nodes and there are no duplicate edges. - We can get the maximum sum when we assign the importance from `n` to `1` in the order of highly connected nodes to sparsely connected nodes. 2. Implementation - Initialize a frequency vector `freq` of size `n` with all elements as `0`. - Iterate over the `roads` vector and increment the frequency of the nodes connected by the road. - Sort the `freq` vector in ascending order. - Initialize a variable `ans` of datatype `long long` to store the maximum importance. - Iterate from the last element of the `freq` vector to the first element (`i=n to i=1`). - Here `i` represents the importance of the node. - `freq[i-1]` represents the number of roads connected to the `i-1`th node. - Add the product of `freq[i-1]` and `i` to the `ans` - Return the `ans`. This is a relatively simple problem where we need to assign importance to the nodes based on the number of roads connected to them. We can get the maximum importance by assigning the importance from n to 1 in the order of highly connected nodes to sparsely connected nodes.\n","permalink":"https://KTS-o7.github.io/blog/posts/prev_solns/problem-maximum-total-importance-of-roads/","tags":["sorting","undirected-graph","graph","vector"],"title":"Problem 2285 Maximum Total Importance of Roads"},{"categories":null,"content":"Problem Statement Link - Problem 1791 Question There is an undirected star graph consisting of n nodes labeled from 1 to n. A star graph is a graph where there is one center node and exactly n - 1 edges that connect the center node with every other node.\nYou are given a 2D integer array edges where each edges[i] = [ui, vi] indicates that there is an edge between the nodes ui and vi. Return the center of the given star graph.\nExample 1 Input: edges = [[1,2],[2,3],[4,2]] Output: 2 Explanation: As shown in the figure above, node 2 is connected to every other node, so 2 is the center. graph TD A((1)) --- B((2)) B --- C((3)) D((4)) --- B Example 2 Input: edges = [[1,2],[5,1],[1,3],[1,4]] Output: 1 graph TD A((2)) --- B((1)) A --- C((3)) A --- D((4)) E((5)) --- A Constraints - `3 \u0026lt;= n \u0026lt;= 10^5` - `edges.length == n - 1` - `edges[i].length == 2` - `1 \u0026lt;= ui, vi \u0026lt;= n` - `ui != vi` - The given `edges` represent a valid star graph. Solution class Solution { public: int findCenter(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; edges) { std::ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); return edges[0][0]==edges[1][0] || edges[0][0] == edges[1][1]?edges[0][0]:edges[0][1]; } }; Complexity Analysis Time Complexity : O(1) Space Complexity : O(1) Explanation 1. Intuition - Since it\u0026#39;s a star graph it means that the center node will have the maximum degree. - `Also none of the other nodes will have degree more than 1.` - So we can just check the first two edges and return the node which is common in both the edges. 2. Implementation - We can just check the first two edges and return the node which is common in both the edges. Simple graph question which teaches the characteristics of a star graph.\n","permalink":"https://KTS-o7.github.io/blog/posts/prev_solns/problem-find-center-of-star-graph/","tags":["graph","star-graph","degree"],"title":"Problem 1791 Find Center of Star Graph"},{"categories":null,"content":"Problem Statement Link - Problem 1382 Question Given the root of a binary search tree, return a balanced binary search tree with the same node values. If there is more than one answer, return any of them.\nA binary search tree is balanced if the depth of the two subtrees of every node never differs by more than 1.\nExample 1 Input: root = [1,null,2,null,3,null,4,null,null] Output: [2,1,3,null,null,null,4] Explanation: This is not the only correct answer, [3,1,4,null,2] is also correct. Input graph TD A((1)) --\u003e B((2)) B --\u003e C((3)) C--\u003e D((4)) Output graph TD A((2)) --\u003e B((1)) A --\u003e C((3)) C --\u003e D((4)) Example 2 Input: root = [2,1,3] Output: [2,1,3] Input graph TD A((2)) --\u003e B((1)) A --\u003e C((3)) Output graph TD A((2)) --\u003e B((1)) A --\u003e C((3)) Constraints The number of nodes in the tree is in the range [1, 10^4]. 1 \u0026lt;= Node.val \u0026lt;= 10^5 Solution class Solution { public: TreeNode* balanceBST(TreeNode* root) { vector\u0026lt;int\u0026gt; sortedElements; std::ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); inOrderTraversal(root, sortedElements); return buildBalancedBST(sortedElements, 0, sortedElements.size() - 1); } private: void inOrderTraversal(TreeNode* node, vector\u0026lt;int\u0026gt;\u0026amp; sortedElements) { if (!node) { return; } inOrderTraversal(node-\u0026gt;left, sortedElements); sortedElements.push_back(node-\u0026gt;val); inOrderTraversal(node-\u0026gt;right, sortedElements); } TreeNode* buildBalancedBST(const vector\u0026lt;int\u0026gt;\u0026amp; elements, int start, int end) { if (start \u0026gt; end) { return nullptr; } int mid = start + (end - start) / 2; TreeNode* node = new TreeNode(elements[mid]); node-\u0026gt;left = buildBalancedBST(elements, start, mid - 1); node-\u0026gt;right = buildBalancedBST(elements, mid + 1, end); return node; } }; Complexity Analysis Time Complexity : O(n) Space Complexity : O(n) Explanation 1. Intuition - The given input is already sorted so if we perform an inorder traversal we will get the sorted elements. - To build a balanced BST we need the root value to be from middle of the sorted elements. - Tree can be recursively built by dividing the sorted elements into two halves. 2. Implementation - Using the `inOrderTraversal` function we can get the sorted elements. - Using the `buildBalancedBST` function we can build the balanced BST. - The `buildBalancedBST` function is a recursive function that takes the sorted elements and the start and end index. - The mid value is calculated as the middle of the start and end index. - The mid value is used as the root value and the left and right subtrees are recursively built. - The base case is when the start index is greater than the end index. - Then return `nullptr`. ","permalink":"https://KTS-o7.github.io/blog/posts/prev_solns/problem-balance-a-binary-search-tree/","tags":["binary-search-tree","binary-tree","recursion","inorder"],"title":"Problem 1382 Balance a Binary Search Tree"},{"categories":null,"content":"Problem Statement Link - Problem 1038 Question Given the root of a Binary Search Tree (BST), convert it to a Greater Tree such that every key of the original BST is changed to the original key plus the sum of all keys greater than the original key in BST.\nAs a reminder, a binary search tree is a tree that satisfies these constraints:\nThe left subtree of a node contains only nodes with keys less than the node\u0026rsquo;s key. The right subtree of a node contains only nodes with keys greater than the node\u0026rsquo;s key. Both the left and right subtrees must also be binary search trees. Note The question is a bit confusing. Lets De-Leetcodify it. We need to convert the given Binary Search Tree to a Greater Sum Tree. In a Greater Sum Tree, every node\u0026rsquo;s value is changed to the sum of all nodes greater than the node\u0026rsquo;s value in the BST. To convert the BST to Greater Sum Tree, we need to do a reverse inorder traversal of the BST. Example 1 Input: root = [4,1,6,0,2,5,7,null,null,null,3,null,null,null,8] Output: [30,36,21,36,35,26,15,null,null,null,33,null,null,null,8] Input: graph TD A((4)) --\u003e B((1)) A --\u003e C((6)) B --\u003e D((0)) B --\u003e E((2)) C --\u003e F((5)) C --\u003e G((7)) E --\u003e H((3)) G --\u003e I((8)) Output: graph TD A((30)) --\u003e B((36)) A --\u003e C((21)) B --\u003e D((36)) B --\u003e E((35)) C --\u003e F((26)) C --\u003e G((15)) E --\u003e H((33)) G --\u003e I((8)) Example 2 Input: root = [0,null,1] Output: [1,null,1] Input: graph TD A((0)) --\u003e C((1)) Output: graph TD A((1)) --\u003e C((1)) Constraints The number of nodes in the tree is in the range [1, 100]. 0 \u0026lt;= Node.val \u0026lt;= 100 All the values in the tree are unique. Solution /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: int sum = 0; TreeNode* helper(TreeNode* root) { if(root == nullptr) return root; helper(root-\u0026gt;right); sum+=root-\u0026gt;val; root-\u0026gt;val=sum; helper(root-\u0026gt;left); return root; } TreeNode* bstToGst(TreeNode* root) { std::ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); return helper(root); } }; Complexity Analysis Time Complexity : O(n) Space Complexity : O(n) Explanation 1. Intuition - To generate a Greater Sum Tree, we need to do a reverse inorder traversal of the BST. - What is a reverse inorder traversal? - In a reverse inorder traversal, we visit the right subtree first, then the root, and then the left subtree. - We can use this to visit the right most leaf node first, then the parent node, and then the left child node. - Now we can obtain the sum of all the nodes greater than the current node. 2. Implementation - Define a global variable `sum` to store the sum of all the nodes greater than the current node. - Define a `helper` function that takes the `root` node as an argument. - In the `helper` function, check if the `root` is `nullptr`, if so return the `root`. - Recursively call the `helper` function with the right child of the `root`. - Add the value of the `root` to the `sum`. - Update the value of the `root` to the `sum`. - Recursively call the `helper` function with the left child of the `root`. - Return the `root`. This problem is exactly same as the Problem 538 . The only difference is the name of the function. The problem statement is exactly the same. So, the solution is also the same.\n","permalink":"https://KTS-o7.github.io/blog/posts/prev_solns/problem-binary-search-tree-to-greater-sum-tree/","tags":["binary-tree","binary-search-tree","recursion","reverse-inorder"],"title":"Problem 1038 Binary Search Tree to Greater Sum Tree"},{"categories":null,"content":"Problem Statement Link - Problem 1552 Question In the universe Earth C-137, Rick discovered a special form of magnetic force between two balls if they are put in his new invented basket. Rick has n empty baskets, the ith basket is at position[i], Morty has m balls and needs to distribute the balls into the baskets such that the minimum magnetic force between any two balls is maximum.\nRick stated that magnetic force between two different balls at positions x and y is |x - y|.\nGiven the integer array position and the integer m. Return the required force.\nNote This problem explaination is absolute trash. Lets De-Leetcodify it. Lets say we have n baskets and m balls. We need to distribute the m balls in the n baskets such that the minimum distance between any two balls is maximum. We need to find the maximum distance between any two balls such that we can distribute the balls in the baskets such that the minimum distance between any two balls is maximum. Example 1 Input: position = [1,2,3,4,7], m = 3 Output: 3 Explanation: Distributing the 3 balls into baskets 1, 4 and 7 will make the magnetic force between ball pairs [3, 3, 6]. The minimum magnetic force is 3. We cannot achieve a larger minimum magnetic force than 3. Example 2 Input: position = [5,4,3,2,1,1000000000], m = 2 Output: 999999999 Explanation: We can use baskets 1 and 1000000000 Constraints - `n == position.length` - `2 \u0026lt;= n \u0026lt;= 10^5` - `1 \u0026lt;= position[i] \u0026lt;= 10^9` - All integers in `position` are `distinct`. - `2 \u0026lt;= m \u0026lt;= position.length` Solution class Solution { public: int maxDistance(vector\u0026lt;int\u0026gt;\u0026amp; position, int m) { sort(position.begin(), position.end()); int l = 1, r = position[position.size()-1]; int ans = -1; while(l \u0026lt;= r) { int mid = l + (r - l) / 2; int lastPosition = position[0], balls = 1; for(int i = 1; i \u0026lt; position.size(); i++) { if(position[i] - lastPosition \u0026gt;= mid) { lastPosition = position[i]; balls++; } } if(balls \u0026gt;= m) { ans = mid; l = mid + 1; } else { r = mid - 1; } } return ans; } }; Complexity Analysis Time Complexity : O(nlogn) Space Complexity : O(1) Explanation 1. Intuition - Lets find out a strategy to accomplish this question. - First find the maximum possible distance between any two balls. - Then first place the first ball at the first position. - Then try to place the next ball at the maximum possible distance from the first ball. - If we can place all the balls at the maximum possible distance then we can say that the maximum possible distance is the answer. - If we cannot place all the balls at the maximum possible distance then we need to reduce the maximum possible distance and try again. 2. Implementation - Sort the `position` array in increasing order. - Set the `l` to 1 and `r` to the last element of the `position` array. - Set the `ans` to -1. - Run a binary search loop until `l` is less than or equal to `r`. - Calculate the `mid` as `l + (r - l) / 2`. - Set the `lastPosition` to the first element of the `position` array and `balls` to 1. - The variable `lastPosition` will store the last position where we placed the ball. - `balls` is set to `1` because we have already placed the first ball. - Run a loop from `1` to `position.size()`. - If the difference between the current position and the `lastPosition` is greater than or equal to `mid` then we can place the ball at the current position. - This will tell us in which position we can place the ball. - Update the value of `lastPosition` to the current position and increment the value of `balls`. - Once the loop is over check if the value of `balls` is greater than or equal to `m`. - If yes then set the `ans` to `mid` and set `l` to `mid + 1`. - This will check if we can increase the distance between the balls. - If no then set `r` to `mid - 1`. - This will check if we can decrease the distance between the balls. - Finally return the value of `ans`. This problem is similar to yesterday\u0026rsquo;s problem. We are trying to find the maximum distance between any two balls such that we can place the balls in the baskets such that the minimum distance between any two balls is maximum. We are using binary search to find the maximum distance between any two balls. This is a very good example of binary search on answer.\n","permalink":"https://KTS-o7.github.io/blog/posts/prev_solns/problem-magnetic-force-between-two-balls/","tags":["binary-search","array","binary-search-on-answer"],"title":"Problem 1552 Magnetic Force Between Two Balls"},{"categories":null,"content":"Problem Statement Link - Problem 1482 Question You are given an integer array bloomDay, an integer m and an integer k.\nYou want to make m bouquets. To make a bouquet, you need to use k adjacent flowers from the garden.\nThe garden consists of n flowers, the ith flower will bloom in the bloomDay[i] and then can be used in exactly one bouquet.\nReturn the minimum number of days you need to wait to be able to make m bouquets from the garden. If it is impossible to make m bouquets return -1.\nNote Problem description hides 2 crucial points\nwe need to collect m bouquests on the SAME given day. Can\u0026rsquo;t collect m-x bouqets on some day, then collect more on another, till we reach m. This can be understood only from the examples. Once flower bloomed but we can\u0026rsquo;t collect m bouquets -\u0026gt; that flower stays in the garden in the \u0026lsquo;bloomed\u0026rsquo; status. Solution is inspired from Problem 278 Example 1 Input: bloomDay = [1,10,3,10,2], m = 3, k = 1 Output: 3 Explanation: Let us see what happened in the first three days. x means flower bloomed and _ means flower did not bloom in the garden. We need 3 bouquets each should contain 1 flower. After day 1: [x, _, _, _, _] // we can only make one bouquet. After day 2: [x, _, _, _, x] // we can only make two bouquets. After day 3: [x, _, x, _, x] // we can make 3 bouquets. The answer is 3. Example 2 Input: bloomDay = [1,10,3,10,2], m = 3, k = 2 Output: -1 Explanation: We need 3 bouquets each has 2 flowers, that means we need 6 flowers. We only have 5 flowers so it is impossible to get the needed bouquets and we return -1. Example 3 Input: bloomDay = [7,7,7,7,12,7,7], m = 2, k = 3 Output: 12 Explanation: We need 2 bouquets each should have 3 flowers. Here is the garden after the 7 and 12 days: After day 7: [x, x, x, x, _, x, x] We can make one bouquet of the first three flowers that bloomed. We cannot make another bouquet from the last three flowers that bloomed because they are not adjacent. After day 12: [x, x, x, x, x, x, x] It is obvious that we can make two bouquets in different ways. Constraints - `bloomDay.length == n` - `1 \u0026lt;= n \u0026lt;= 10^5` - `1 \u0026lt;= bloomDay[i] \u0026lt;= 10^9` - `1 \u0026lt;= m \u0026lt;= 10^6` - `1 \u0026lt;= k \u0026lt;= n` Solution class Solution { public: int minDays(vector\u0026lt;int\u0026gt;\u0026amp; bloomDay, int m, int k) { int l = 1, r = 1e9; int ans = -1; while(l \u0026lt;= r) { int mid = l + (r - l) / 2; int consecutiveLength = 0, boquets = 0; for(int i = 0; i \u0026lt; bloomDay.size(); i++) { if(bloomDay[i] \u0026lt;= mid) { consecutiveLength++; if(consecutiveLength \u0026gt;= k) { consecutiveLength = 0; boquets++; } } else { consecutiveLength = 0; } } if(boquets \u0026gt;= m) { ans = mid; r = mid - 1; } else { l = mid + 1; } } return ans; } }; Complexity Analysis Time Complexity : O(nlogn) Space Complexity : O(1) Explanation 1. Intuition - If we know how many flowers are blooming on a given day, we can easily calculate the number of bouquets we can make. - Ask this question: Is `x` days sufficient to make `m` bouquets? - If yes it means that we can make `m` bouquets in `x+t` days where `t` is any number of days greater than `x`. - Hence we need to find the minimum number of days to make `m` bouquets. 2. Implementation - Initialize `l` and `r` as 1 and 1e9 respectively. - They represent the minimum and maximum number of days required to make `m` bouquets. (according to the constraints) - Initialize `ans` as -1. - This will represent the minimum number of days required to make `m` bouquets. - Run a while loop till `l \u0026lt;= r`. - Calculate the mid value as `l + (r - l) / 2`. - Initialize `consecutiveLength` and `boquets` as 0. - Run a loop for all the flowers in the garden. - If the flower blooms on the `mid` day, increment the `consecutiveLength`. This represents the number of flowers blooming consecutively. - If the `consecutiveLength` is greater than or equal to `k`, reset the `consecutiveLength` and increment the `boquets`. - If the flower does not bloom on the `mid` day, reset the `consecutiveLength`. - Once the for loop ends, check if the number of `boquets` is greater than or equal to `m`. - If yes, update the `ans` as `mid` and update `r` as `mid - 1`. - This shows that we can make `m` bouquets in `mid` days. So we need to check if they can be made in less than `mid` days. - If no, update `l` as `mid + 1`. - This shows that we cannot make `m` bouquets in `mid` days. So we need to check if they can be made in more than `mid` days. - Return the `ans`. This is a very good problem to understand the power of binary search. In this problem we use binary search to find the point after which the required condition will always be true. We are trying to use the leftmost binary search to find the minimum number of days required to make m bouquets. This is a very good example of binary search on answer.\n","permalink":"https://KTS-o7.github.io/blog/posts/prev_solns/problem-minimum-number-of-days-to-make-m-bouquets/","tags":["binary-search","array","binary-search-on-answer"],"title":"Problem 1482 Minimum Number of Days to Make M Bouquets"},{"categories":null,"content":"Problem Statement Link - Problem 826 Question You have n jobs and m workers. You are given three arrays: difficulty, profit, and worker where:\ndifficulty[i] and profit[i] are the difficulty and the profit of the ith job, and\nworker[j] is the ability of jth worker (i.e., the jth worker can only complete a job with difficulty at most worker[j]). Every worker can be assigned at most one job, but one job can be completed multiple times.\nFor example, if three workers attempt the same job that pays $1, then the total profit will be $3. If a worker cannot complete any job, their profit is $0. Return the maximum profit we can achieve after assigning the workers to the jobs.\nExample 1 Input: difficulty = [2,4,6,8,10], profit = [10,20,30,40,50], worker = [4,5,6,7] Output: 100 Explanation: Workers are assigned jobs of difficulty [4,4,6,6] and they get a profit of [20,20,30,30] separately. Example 2 Input: difficulty = [85,47,57], profit = [24,66,99], worker = [40,25,25] Output: 0 Constraints - n == difficulty.length - n == profit.length - m == worker.length - 1 \u0026lt;= n, m \u0026lt;= 10^4 - 1 \u0026lt;= difficulty[i], profit[i], worker[i] \u0026lt;= 10^5 Solution class Solution { public: int maxProfitAssignment(vector\u0026lt;int\u0026gt;\u0026amp; difficulty, vector\u0026lt;int\u0026gt;\u0026amp; profit, vector\u0026lt;int\u0026gt;\u0026amp; worker) { std::ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); vector\u0026lt;pair\u0026lt;int,int\u0026gt;\u0026gt;pq(profit.size()); for (int i = 0; i \u0026lt; profit.size(); i++) { pq[i]= {profit[i], difficulty[i]} ; } int wsize = worker.size(), pqsize = pq.size(),i =0, j=0, ans = 0; sort(worker.begin(), worker.end(), greater\u0026lt;int\u0026gt;()); sort(pq.begin(),pq.end(),greater\u0026lt;pair\u0026lt;int,int\u0026gt;\u0026gt;()); while (i \u0026lt; wsize \u0026amp;\u0026amp; j \u0026lt; pqsize) { while(j\u0026lt;pqsize \u0026amp;\u0026amp; pq[j].second\u0026gt;worker[i]) j++; if(i == wsize || j == pqsize) break; while(i\u0026lt;wsize \u0026amp;\u0026amp; j\u0026lt;pqsize \u0026amp;\u0026amp; pq[j].second \u0026lt;= worker[i]) { // cout\u0026lt;\u0026lt;j\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;\u0026#34; \u0026#34;\u0026lt;\u0026lt;pq[j].first\u0026lt;\u0026lt;endl; ans+=pq[j].first; i++; } } return ans; } }; Complexity Analysis Time Complexity : O(nlogn) Space Complexity : O(n) Explanation 1. Intuition - We can get maximum profit if we keep assigning the maximum profit job repeatedly. - But we need to ensure that the worker can complete the job. - So we can create pairs of profit and difficulty and sort them in descending order. - We can sort the workers in descending order. - Now we find the first job that the worker can complete and assign it to him. - We try to assign the same job to all the workers who can complete the job; this way, we can get the maximum profit. - If a worker cannot complete any job, we move to the next possible job. 2. Implementation - Initialize a vector of pairs `pq` of size `profit.size()`. - Fill the vector with pairs of profit and difficulty. - Initialize `wsize = worker.size()`, `pqsize = pq.size()`, `i = 0`, `j = 0`, and `ans = 0`. - Sort the workers and the pairs in descending order. - Run a while loop till `i \u0026lt; wsize` and `j \u0026lt; pqsize`. - Run a while loop till `j \u0026lt; pqsize` and `pq[j].second \u0026gt; worker[i]`. - Keep incrementing `j` till we find the first job that the worker can complete. - This loop will find the first possible job that the worker can complete. - If `i == wsize` or `j == pqsize`, break. - This loop will break if we reach the end of the workers or the pairs of jobs. - Run a while loop till `i \u0026lt; wsize` and `j \u0026lt; pqsize` and `pq[j].second \u0026lt;= worker[i]`. - This loop represents the assignment of jobs to workers. - Same job will be assigned to all the workers who can complete the job. - Increment `i` and add the profit to `ans`. - Return `ans`. Note - The code can be optimized by using a priority queue instead of sorting the pairs. Also this problem can be solved using a greedy approach as shown.\n","permalink":"https://KTS-o7.github.io/blog/posts/prev_solns/problem-most-profit-assigning-work/","tags":["sorting","heap","max-heap","greedy"],"title":"Problem 826 Most Profit Assigning Work"},{"categories":null,"content":"Problem Statement Link - Problem 633 Question Given a non-negative integer c, decide whether there are two integers a and b such that a^2 + b^2 = c.\nNote Even thought it doesn\u0026rsquo;t say in the question , the numbers can be equal, ie a=b is valid. since we are talking about square sums, it is safe to say that values of any one of variable can be atmost sqrt(c) Example 1 Input: c = 5 Output: true Explanation: 1 * 1 + 2 * 2 = 5 Example 2 Input: c = 3 Output: false Constraints 0 \u0026lt;= c \u0026lt;= 2^31 - 1 Solution class Solution { public: bool judgeSquareSum(int c) { long long int l =0,r = sqrt(c); long long int sum; while(l\u0026lt;=r) { sum = l*l + r*r; if(sum == c) return true; else if(sum\u0026gt;c) r--; else l++; } return false; } }; Complexity Analysis Time Complexity : O(sqrt(n)) Space Complexity : O(1) Explanation 1. Intuition - The equation `a^2 + b^2 = c` can be resolved into a two pointer problem. - We know that one of the values of `a` and `b` can be atmost `sqrt(c)`. - When `l` and `r` are at the extreme ends, the sum of squares will be maximum. - So we can start from `l=0` and `r=sqrt(c)` and keep moving the pointers based on the sum. - If the sum is greater than `c`, we need to reduce the sum, so we decrement `r`. - If the sum is lesser than `c`, we need to increase the sum, so we increment `l`. - If the sum is equal to `c`, we return true. - If the pointers cross each other, we return false. 2. Implementation - Initialize `long long int l =0,r = sqrt(c);` and `long long int sum;`. - Run a while loop till `l\u0026lt;=r`. - Calculate the sum of squares `sum = l*l + r*r`. - If the sum is equal to `c`, return true. - If the sum is greater than `c`, decrement `r`. - If the sum is lesser than `c`, increment `l`. - If the loop ends, return false. Mathematical Solution There is a pure mathematical solution to this problem. Fermat\u0026rsquo;s Theorem on Sum of Two Squares Any positive number `n` is expressible as a sum of two squares if and only if the prime factorization of `n`, every prime of the form `(4k+3)` occurs an even number of times. Using the above theorem we can check if any of the prime factors of c which is of the form (4k+3) occurs an odd number of times. If yes, then we can return false. If no, then we need to check if the number c itself is of form (4k+3). If yes, then we can return false. If no, then we can return true. Code public class Solution { public boolean judgeSquareSum(int c) { for (int i = 2; i * i \u0026lt;= c; i++) { int count = 0; if (c % i == 0) { while (c % i == 0) { count++; c /= i; } if (i % 4 == 3 \u0026amp;\u0026amp; count % 2 != 0) return false; } } return c % 4 != 3; } } Complexity Time Complexity : O(sqrt(n)) Space Complexity : O(1) The wikipedia article for this theorem is here ","permalink":"https://KTS-o7.github.io/blog/posts/prev_solns/problem-sum-of-square-numbers/","tags":["two-pointer","math"],"title":"Problem 633 Sum of Square Numbers"},{"categories":null,"content":"Problem Statement Link - Problem 502 Question Suppose LeetCode will start its IPO soon. In order to sell a good price of its shares to Venture Capital, LeetCode would like to work on some projects to increase its capital before the IPO. Since it has limited resources, it can only finish at most k distinct projects before the IPO. Help LeetCode design the best way to maximize its total capital after finishing at most k distinct projects.\nYou are given n projects where the ith project has a pure profit profits[i] and a minimum capital of capital[i] is needed to start it.\nInitially, you have w capital. When you finish a project, you will obtain its pure profit and the profit will be added to your total capital.\nPick a list of at most k distinct projects from given projects to maximize your final capital, and return the final maximized capital.\nThe answer is guaranteed to fit in a 32-bit signed integer.\nNote This question says Pure profit, which means the capital is not getting deducted for performing the project. if we are able to perform a project , we will get the profit directly added to current capital. We can perform a project only once. Example 1 Input: k = 2, w = 0, profits = [1,2,3], capital = [0,1,1] Output: 4 Explanation: Since your initial capital is 0, you can only start the project indexed 0. After finishing it you will obtain profit 1 and your capital becomes 1. With capital 1, you can either start the project indexed 1 or the project indexed 2. Since you can choose at most 2 projects, you need to finish the project indexed 2 to get the maximum capital. Therefore, output the final maximized capital, which is 0 + 1 + 3 = 4. Example 2 Input : k = 4, w = 0, profits = [1,2,3,4], capital = [0,1,2,3] Output : 10 Explanation : Since your initial capital is 0, you can only start the project indexed 0. After finishing it you will obtain profit 1 and your capital becomes 1. With capital 1 , we can start the project indexed 1, now capital becomes 3. With capital 3, we can start the project indexed 2, now capital becomes 6. With capital 6, we can start the project indexed 3, now capital becomes 10. Constraints - `1 \u0026lt;= k \u0026lt;= 10^5` - `0 \u0026lt;= w \u0026lt;= 10^9` - `n == profits.length` - `n == capital.length` - `1 \u0026lt;= n \u0026lt;= 10^5` - `0 \u0026lt;= profits[i] \u0026lt;= 10^4` - `0 \u0026lt;= capital[i] \u0026lt;= 10^9` Solution class Solution { public: int findMaximizedCapital(int k, int w, vector\u0026lt;int\u0026gt;\u0026amp; profits, vector\u0026lt;int\u0026gt;\u0026amp; capital) { std::ios::sync_with_stdio(false); vector\u0026lt;pair\u0026lt;int,int\u0026gt;\u0026gt;job; for(int i = 0; i\u0026lt;profits.size();i++) job.push_back({capital[i],profits[i]}); sort(job.begin(),job.end()); priority_queue\u0026lt;int\u0026gt; maxProfit; int i = 0; while(k\u0026gt;0) { while(i\u0026lt;profits.size() \u0026amp;\u0026amp; job[i].first\u0026lt;=w) { maxProfit.push(job[i].second); i++; } if(maxProfit.empty()) break; w+=maxProfit.top(); maxProfit.pop(); k--; } return w; } }; Complexity Analysis Time Complexity : O(nlogn) Space Complexity : O(n) Explanation 1. Intuition - We need to find the maximum possible profit for a given capital. - For this if we pair the capital and profit and sort them based on capital. - We can then iterate over the projects and check if the capital is less than or equal to the current capital. - If yes then we can add the profit to the max heap. - We can then pop the top element from the max heap and add it to the capital. - We can repeat this process until we have performed k projects. 2. Implementation - Pair the capital and profit and sort them, store them in a vector of pairs called `job`. - Initialize a max heap called `maxProfit`. - Initialize a variable `i` to 0. - Iterate over the projects until `k` becomes 0. - Check if the capital is less than or equal to the current capital and `i` is less than the size of the projects. - If yes then add the profit to the `maxProfit` heap. - Increment `i`. - This will add all the projects which can be performed with the current capital. - If the `maxProfit` heap is empty then break. - Add the top element of the `maxProfit` heap to the capital. - Pop the top element from the `maxProfit` heap. - Decrement `k`. - Return the final capital. This is a greedy approach where we are trying to maximize the profit by selecting the projects which can be performed with the current capital.\n","permalink":"https://KTS-o7.github.io/blog/posts/prev_solns/problem-ipo/","tags":["greedy","max-heap","array","min-heap"],"title":"Problem 502 IPO"},{"categories":null,"content":"Problem Statement Link - Problem 945 Question You are given an integer array nums. In one move, you can pick an index i where 0 \u0026lt;= i \u0026lt; nums.length and increment nums[i] by 1.\nReturn the minimum number of moves to make every value in nums unique.\nThe test cases are generated so that the answer fits in a 32-bit integer.\nExample 1 Input: nums = [1,2,2] Output: 1 Explanation: After 1 move, the array could be [1, 2, 3]. Example 2 Input: nums = [3,2,1,2,1,7] Output: 6 Explanation: After 6 moves, the array could be [3, 4, 1, 2, 5, 7]. Constraints 0 \u0026lt;= nums[i] \u0026lt;= 10^5 1 \u0026lt;= nums.length \u0026lt;= 10^5 Solution class Solution { public: int minIncrementForUnique(vector\u0026lt;int\u0026gt;\u0026amp; nums) { std::ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); sort(nums.begin(),nums.end()); int ans = 0,diff=0; for(int i = 1;i\u0026lt;nums.size();i++) { if(nums[i]\u0026lt;=nums[i-1]) { diff = nums[i-1]-nums[i]+1; ans+= diff; nums[i]+=diff; } } return ans; } }; Complexity Analysis Time Complexity : O(nlogn) Space Complexity : O(1) Explanation 1. Intuition - If the array is sorted, we need to check the if current element is less than or equal to the previous element. - If yes then we need to increment the current element by the difference of previous element and current element + 1. - We add 1 just to make it unique. 2. Implementation - Sort the array. - Initialize the answer `ans` and difference `diff` variable to 0. - Iterate over the array from 1 to n. - if `nums[i]` is less than or equal to `nums[i-1]` then calculate the difference. - Difference is the difference between the previous element and the current element + 1. - Increment the answer by the difference. - Increment the current element by the difference. - Return the answer. Alternate Approach Code class Solution { public: int minIncrementForUnique(vector\u0026lt;int\u0026gt;\u0026amp; nums) { int n = nums.size(); int max_val = 0; int minIncrements = 0; // Find maximum value in nums using a loop for (int val : nums) { max_val = max(max_val, val); } // Create a frequencyCount vector to store the frequency of each value in nums vector\u0026lt;int\u0026gt; frequencyCount(n + max_val + 1, 0); // Populate frequencyCount vector with the frequency of each value in nums for (int val : nums) { frequencyCount[val]++; } // Iterate over the frequencyCount vector to make all values unique for (int i = 0; i \u0026lt; frequencyCount.size(); i++) { if (frequencyCount[i] \u0026lt;= 1) continue; // Determine excess occurrences, carry them over to the next value, // ensure single occurrence for current value, and update minIncrements. int duplicates = frequencyCount[i] - 1; frequencyCount[i + 1] += duplicates; frequencyCount[i] = 1; minIncrements += duplicates; } return minIncrements; } }; // Time Complexity: O(n + max_val) // Space Complexity: O(n + max_val) Approach : Counting Another way to track duplicates is to use an array called frequencyCount. In this array, each index represents a unique value from our given array, nums, and the value at each index represents the count of occurrences of that value in nums.\nFor example: if 3 appears in nums twice, frequencyCount[3] would equal 2.\nnums = [1,3,3,5,5] frequencyCount = [0, 1, 0, 2, 0, 2] We know nums contains all unique values when none of the values in frequencyCount is greater than 1.\nOnce we\u0026rsquo;ve created the frequencyCount array from nums, we can iterate through it and simulate the process used in Approach 1 to increment each duplicate value until all values become unique.\nSo elements with a count of 1 or less will remain unchanged. Upon encountering a duplicate, we\u0026rsquo;ll calculate the surplus of elements with that value, carry that count to the next index, and set the current index value to 1.\nWe\u0026rsquo;ll keep a running count for the number that we carry over to the next index; that equals how many moves it will take to make each value of nums unique.\nWe want to initialize frequencyCount with the largest possible range that could be needed to solve the problem. How do we determine this range?\nThe minimum length of frequencyCount would be the largest value in nums, and it must be long enough to hold the new values we get from incrementing any duplicates. Keep in mind that the maximum number of duplicates that we could possibly have is equal to the length of nums.\nIn problems like this, we can determine the longest possible length needed by considering a worst-case scenario. For instance, take the edge case where nums = [4, 4, 4, 4, 4].\nThe frequencyCount array for this would be:\nfrequencyCount = [0, 0, 0, 0, 5]\nIf we make every element unique, the frequencyCount array transforms to:\nfrequencyCount = [0, 0, 0, 0, 5, 6, 7, 8, 9]\nAs you can observe, the size of the frequencyCount array is 9, which equals the length of the original nums array plus the largest value found in nums.\nAlgorithm Initialize variables: n as the length of nums. max to store the maximum value in nums. minIncrements to store the total number of increments needed. Find the maximum value in nums. Create an array frequencyCount to store the frequency of each element. Loop over nums and populate frequencyCount. Loop over the frequencyCount array. For each element: If the frequency is less than or equal to one, continue with the next iteration. Add the duplicates to the frequency of the next element. Set the frequency of the current element to one. Update minIncrements to account for the movement of the duplicates. Return minIncrements. ","permalink":"https://KTS-o7.github.io/blog/posts/prev_solns/problem-minimum-increment-to-make-array-unique/","tags":["greedy","sorting","array"],"title":"Problem 945 Minimum Increment to Make Array Unique"},{"categories":null,"content":"Problem Statement Link - Problem 2037 Question There are n seats and n students in a room. You are given an array seats of length n, where seats[i] is the position of the ith seat. You are also given the array students of length n, where students[j] is the position of the jth student.\nYou may perform the following move any number of times:\nIncrease or decrease the position of the ith student by 1 (i.e., moving the ith student from position x to x + 1 or x - 1) Return the minimum number of moves required to move each student to a seat such that no two students are in the same seat. Note that there may be multiple seats or students in the same position at the beginning.\nNote This question is very confusing, but the question is asking what is the number of moves required to seat all the students in the seats such that no two students are in the same seat. Also the to get minimum moves we need to make sure the student is matched to the seat which is closest to him. Example 1 Input: seats = [3,1,5], students = [2,7,4] Output: 4 Explanation: The students are moved as follows: - The first student is moved from from position 2 to position 1 using 1 move. - The second student is moved from from position 7 to position 5 using 2 moves. - The third student is moved from from position 4 to position 3 using 1 move. In total, 1 + 2 + 1 = 4 moves were used. Example 2 Input: seats = [4,1,5,9], students = [1,3,2,6] Output: 7 Explanation: The students are moved as follows: - The first student is not moved. - The second student is moved from from position 3 to position 4 using 1 move. - The third student is moved from from position 2 to position 5 using 3 moves. - The fourth student is moved from from position 6 to position 9 using 3 moves. In total, 0 + 1 + 3 + 3 = 7 moves were used. Example 3 Input: seats = [2,2,6,6], students = [1,3,2,6] Output: 4 Explanation: Note that there are two seats at position 2 and two seats at position 6. The students are moved as follows: - The first student is moved from from position 1 to position 2 using 1 move. - The second student is moved from from position 3 to position 6 using 3 moves. - The third student is not moved. - The fourth student is not moved. In total, 1 + 3 + 0 + 0 = 4 moves were used. Constraints n == seats.length == students.length 1 \u0026lt;= n \u0026lt;= 100 1 \u0026lt;= seats[i], students[j] \u0026lt;= 100 Solution class Solution { public: int minMovesToSeat(vector\u0026lt;int\u0026gt;\u0026amp; seats, vector\u0026lt;int\u0026gt;\u0026amp; students) { sort(students.begin(),students.end()); sort(seats.begin(),seats.end()); int answer = 0; for(int i =0;i\u0026lt;seats.size();i++) { answer+=abs(seats[i]-students[i]); } return answer; } }; Complexity Analysis Time Complexity : O(NlogN) Space Complexity : O(1) Explanation 1. Intuition - We need to implement a greedy approach to solve this problem. - We need to sort the students and seats array. - Then we can match the students to the seats which are closest to them. 2. Implementation - First we sort the students and seats array. - Then we iterate over the seats array and calculate the absolute difference between the seat and student. - We add the difference to the answer. - Finally we return the answer. ","permalink":"https://KTS-o7.github.io/blog/posts/prev_solns/problem-minimum-number-of-moves-to-seat-everyone/","tags":["greedy","sorting","array"],"title":"Problem 2037 Minimum Number of Moves to Seat Everyone"},{"categories":null,"content":"Problem Statement Link - Problem 75 Question Given an array nums with n objects colored red, white, or blue, sort them in-place so that objects of the same color are adjacent, with the colors in the order red, white, and blue.\nWe will use the integers 0, 1, and 2 to represent the color red, white, and blue, respectively.\nYou must solve this problem without using the library\u0026rsquo;s sort function.\nExample 1 Input: nums = [2,0,2,1,1,0] Output: [0,0,1,1,2,2] Example 2 Input: nums = [2,0,1] Output: [0,1,2] Constraints n == nums.length 1 \u0026lt;= n \u0026lt;= 300 nums[i] is either 0, 1, or 2. Solution // Two loop solution class Solution { public: void sortColors(vector\u0026lt;int\u0026gt;\u0026amp; nums) { for(int i = 0;i\u0026lt;nums.size();i++) { for(int j = i+1;j\u0026lt;nums.size();j++) { if(nums[i]\u0026gt;nums[j]) { int temp = nums[i]; nums[i]=nums[j]; nums[j]=temp; } } } } }; Complexity Analysis Time Complexity : O(N^2) Space Complexity : O(1) Explanation 1. Intuition - Since they need it to be in-place, we can use two loops to sort the array. - This is similar to bubble sort. 2. Implementation - Outer loop runs from 0 to n-1. - Inner loop runs from i+1 to n. - If nums[i] \u0026gt; nums[j], then swap the elements. - Continue this process until the array is sorted. - This will ensure that the array is sorted in-place. Alternate Solution Dutch National Flag Algorithm class Solution { public: void sortColors(vector\u0026lt;int\u0026gt;\u0026amp; nums) { int low = 0; int mid = 0; int high = nums.size()-1; while(mid\u0026lt;=high) { if(nums[mid]==0) { swap(nums[low],nums[mid]); low++; mid++; } else if(nums[mid]==1) { mid++; } else { swap(nums[mid],nums[high]); high--; } } } }; Time Complexity : O(N) Space Complexity : O(1) Intuition - We can use the Dutch National Flag Algorithm to solve this problem. - We use three pointers to keep track of the elements. - We use `low` to keep track of the 0\u0026#39;s. - We use `mid` to keep track of the 1\u0026#39;s. - We use `high` to keep track of the 2\u0026#39;s. - We traverse through the array and swap the elements accordingly. Implementation - Initialize `low` to 0, `mid` to 0, and `high` to n-1. - Traverse through the array until `mid` is less than or equal to `high`. - If `nums[mid]` is 0, then swap `nums[low]` and `nums[mid]` and increment `low` and `mid`. - If `nums[mid]` is 1, then increment `mid`. - If `nums[mid]` is 2, then swap `nums[mid]` and `nums[high]` and decrement `high`. - Continue this process until `mid` is less than or equal to `high`. - This will ensure that the array is sorted according to the colors. Shows a similarity to count sort. We can use the same approach to solve this problem. We can count the number of 0\u0026rsquo;s, 1\u0026rsquo;s, and 2\u0026rsquo;s and then fill the array accordingly. This will also solve the problem in O(N) time complexity.\n","permalink":"https://KTS-o7.github.io/blog/posts/prev_solns/problem-sort-colors/","tags":["sorting","two-pointer","array"],"title":"Problem 75 Sort Colors"},{"categories":null,"content":"Problem Statement Link - Problem 1122 Question Given two arrays arr1 and arr2, the elements of arr2 are distinct, and all elements in arr2 are also in arr1.\nSort the elements of arr1 such that the relative ordering of items in arr1 are the same as in arr2. Elements that do not appear in arr2 should be placed at the end of arr1 in ascending order.\nExample 1 Input: arr1 = [2,3,1,3,2,4,6,7,9,2,19], arr2 = [2,1,4,3,9,6] Output: [2,2,2,1,4,3,3,9,6,7,19] Example 2 Input: arr1 = [28,6,22,8,44,17], arr2 = [22,28,8,6] Output: [22,28,8,6,17,44] Constraints 1 \u0026lt;= arr1.length, arr2.length \u0026lt;= 1000 0 \u0026lt;= arr1[i], arr2[i] \u0026lt;= 1000 All the elements of arr2 are distinct. Each arr2[i] is in arr1. Solution class Solution { public: vector\u0026lt;int\u0026gt; relativeSortArray(vector\u0026lt;int\u0026gt;\u0026amp; arr1, vector\u0026lt;int\u0026gt;\u0026amp; arr2) { vector\u0026lt;int\u0026gt;freqCount(1001,0); for(int i = 0;i\u0026lt;arr1.size();i++) { freqCount[arr1[i]]++; } int ansptr=0; for(int i=0; i\u0026lt;arr2.size();i++) { while(freqCount[arr2[i]]) { arr1[ansptr] = arr2[i]; ansptr++; freqCount[arr2[i]]--; } } for(int i = 0;i\u0026lt;freqCount.size();i++) { while(freqCount[i]) { arr1[ansptr] = i; ansptr++; freqCount[i]--; } } return arr1; } }; Complexity Analysis Time Complexity : O(N) Space Complexity : O(N) Explanation 1. Intuition - We need to know the count of elements in `arr1` - Hence we use `freqCount` vector to store frequency counts. - `arr2` will give us the order of insertion. 2. Implementation - First create a `freqCount` vector of size 1001 and initialize it with 0. - Traverse through `arr1` and increment the frequency count of each element. - Traverse through `arr2` and insert the elements in `arr1` in the order of `arr2`. - Traverse through `freqCount` and insert the remaining elements in `arr1`. - Now the array is sorted according to `arr2`. - Return `arr1`. Note Hashmap implementation class Solution{ public: vector\u0026lt;int\u0026gt; relativeSortArray(vector\u0026lt;int\u0026gt;\u0026amp; arr1, vector\u0026lt;int\u0026gt;\u0026amp; arr2) { map\u0026lt;int,int\u0026gt;freqCount; for(int i = 0;i\u0026lt;arr1.size();i++) { freqCount[arr1[i]]++; } int ansptr=0; for(int i=0; i\u0026lt;arr2.size();i++) { while(freqCount[arr2[i]]) { arr1[ansptr] = arr2[i]; ansptr++; freqCount[arr2[i]]--; } } for(auto i:freqCount) { while(i.second) { arr1[ansptr] = i.first; ansptr++; i.second--; } } return arr1; } }; ","permalink":"https://KTS-o7.github.io/blog/posts/prev_solns/problem-relative-sort-array/","tags":["vector","counting-sort","sorting","count-sort","hash-map"],"title":"Problem 1122 Relative Sort Array"},{"categories":null,"content":"Problem Statement Link - Problem 136 Question Given a non-empty array of integers nums, every element appears twice except for one. Find that single one.\nYou must implement a solution with a linear runtime complexity and use only constant extra space.\nNote We need O(1) space and O(n) time complexity. That means we cant use any other space to store frequency of elements and cant sort the array and check for the element which is not repeated. This hints that we need to manipulate the given array and find the single number. Example 1 Input: nums = [2,2,1] Output: 1 Example 2 Input: nums = [4,1,2,1,2] Output: 4 Example 3 Input: nums = [1] Output: 1 Constraints 1 \u0026lt;= nums.length \u0026lt;= 3 * 10^4 -3 * 10^4 \u0026lt;= nums[i] \u0026lt;= 3 * 10^4 Each element in the array appears twice except for one element which appears only once. Solution class Solution { public: int singleNumber(vector\u0026lt;int\u0026gt;\u0026amp; nums) { std::ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); int ans = nums[0]; for(int i= 1; i\u0026lt;nums.size(); i++) ans = ans^nums[i]; return ans; } }; Complexity Analysis Time Complexity : O(N) Space Complexity : O(1) Explanation 1. Intuition - We know that a number XOR with itself is 0. - So, if we XOR all the elements in the array, the elements which are repeated will cancel each other. - We will be left with the single number. 2. Implementation - Initialize a variable `ans` with the first element of the array. - Iterate over the array from the second element. - XOR the `ans` with the current element. - Return the `ans`. This solution shows the power of XOR operation. XOR operation is commutative and associative. So, we can use it to find the single number in the array.\n","permalink":"https://KTS-o7.github.io/blog/posts/prev_solns/problem-single-number/","tags":["bit-manipulation","vectors","bitwise-xor"],"title":"Problem 136 Single Number"},{"categories":null,"content":"Problem Statement Link - Problem 1051 Question A school is trying to take an annual photo of all the students. The students are asked to stand in a single file line in non-decreasing order by height. Let this ordering be represented by the integer array expected where expected[i] is the expected height of the ith student in line.\nYou are given an integer array heights representing the current order that the students are standing in. Each heights[i] is the height of the ith student in line (0-indexed).\nReturn the number of indices where heights[i] != expected[i].\nExample 1 Input: heights = [1,1,4,2,1,3] Output: 3 Explanation: heights: [1,1,4,2,1,3] expected: [1,1,1,2,3,4] Indices 2, 4, and 5 do not match. Example 2 Input: heights = [5,1,2,3,4] Output: 5 Explanation: heights: [5,1,2,3,4] expected: [1,2,3,4,5] All indices do not match. Example 3 Input: heights = [1,2,3,4,5] Output: 0 Explanation: heights: [1,2,3,4,5] expected: [1,2,3,4,5] All indices match. Constraints 1\u0026lt;= heights.length \u0026lt;= 100 1 \u0026lt;= heights[i] \u0026lt;= 100 Solution class Solution { public: int heightChecker(vector\u0026lt;int\u0026gt;\u0026amp; heights) { vector\u0026lt;int\u0026gt; ans; for(auto i : heights) ans.push_back(i); sort(ans.begin(), ans.end()); int count = 0; for(int i = 0 ; i \u0026lt; heights.size() ; i ++) if(heights[i] != ans[i]) count++; return count; } }; Complexity Analysis Time Complexity : O(NlogN) Space Complexity : O(N) Explanation 1. Intuition - We need to have a copy of the original array. - Sort the copy. - Compare the original array with the sorted array. - Count the number of mismatches. 2. Implementation - Create a copy of the `heights` array and name it `expected`. - Sort the `expected` array. - Compare the `heights` array with the `expected` array. - Count the number of mismatches. - Return the count. ","permalink":"https://KTS-o7.github.io/blog/posts/prev_solns/problem-height-checker/","tags":["vectors","sorting"],"title":"Problem 1051 Height Checker"},{"categories":null,"content":"Problem Statement Link - Problem 523 Question Given an integer array nums and an integer k, return true if nums has a good subarray or false otherwise.\nA good subarray is a subarray where:\nits length is at least two, and the sum of the elements of the subarray is a multiple of k.\nNote A subarray is a contiguous part of the array. An integer x is a multiple of k if there exists an integer n such that x = n * k. 0 is always a multiple of k. Example 1 Input: nums = [23,2,4,6,7], k = 6 Output: true Explanation: [2, 4] is a continuous subarray of size 2 whose elements sum up to 6. Example 2 Input: nums = [23,2,6,4,7], k = 6 Output: true Explanation: [23, 2, 6, 4, 7] is an continuous subarray of size 5 whose elements sum up to 42. 42 is a multiple of 6 because 42 = 7 * 6 and 7 is an integer. Example 3 Input: nums = [23,2,6,4,7], k = 13 Output: false Constraints - `1 \u0026lt;= nums.length \u0026lt;= 10^5` - `0 \u0026lt;= nums[i] \u0026lt;= 10^9` - `0 \u0026lt;= sum(nums[i]) \u0026lt;= 23^1 - 1` - `1 \u0026lt;= k \u0026lt;= 2^31 - 1` Solution A Brute force Solution // This code is practically useless for larger values of k and nums; class Solution { public: bool checkSubarraySum(vector\u0026lt;int\u0026gt;\u0026amp; nums,int k) { std::ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); int size = nums.size(); for(int i = 0; i\u0026lt;size; i++) { int sum = nums[i]; for(int j = i+1; j\u0026lt;size; j++) { sum+=nums[j]; if(k==0) { if(sum==0) return true; } else if(sum%k==0) return true; } } return false; } }; // Time complexity is O(N^2) // Space complexity is O(1) A Better Solution class Solution { public: bool checkSubarraySum(vector\u0026lt;int\u0026gt;\u0026amp; nums, int k) { std::ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); int size = nums.size(), sum = 0; unordered_map\u0026lt;int,int\u0026gt;indexOccured; indexOccured[0] = -1; for(int i= 0; i\u0026lt;size; i++) { sum+=nums[i]; if(indexOccured.find(sum%k) == indexOccured.end()) { indexOccured[sum%k] = i; } else { int found = indexOccured[sum%k]; if(i-found\u0026gt;1) return true; } } return false; } }; Complexity Analysis Time Complexity : O(n) Space Complexity : O(n) Explanation 1. Intuition - We need to find a subarray whose sum is a multiple of k and length is atleast 2. - We can use two loops to define start and end points of a subarray and calculate the sum. - If the sum is a multiple of k, we can return true. - But this solution is not optimal. - We can use a hashmap to store the sum%k and the index where it occured. This works for fast lookups. - So make it just a single loop to calculate the sum so far and store the sum%k in a hashmap. - If the sum%k is already present in the hashmap, we can check if the difference between the current index and the index where the sum%k occured is greater than 1. - if yes return true. If not continue. 2. Implementation - Intialize a hashmap `indexOccured` with key as 0 and value as -1. - This initialization is to prevent the edge case where the first element is a multiple of k. - Iterate over the array `nums` and calculate the `sum` so far. - If the `sum%k` is not present in the hashmap, add it to the hashmap with the index. - If the `sum%k` is already present in the hashmap: check if the difference between the current index and the index where the `sum%k` occured is greater than 1. - If yes return true. If not continue. - If we reach end of the loop, return false. A really good mathematical optimization problem. The hashmap is the key to this solution. The hashmap stores the sum%k and the index where it occured. If the sum%k is already present in the hashmap, we can check if the difference between the current index and the index where the sum%k occured is greater than 1.\n","permalink":"https://KTS-o7.github.io/blog/posts/prev_solns/problem-continuous-subarray-sum/","tags":["hashmap","prefix-sum","prefixsum","vector"],"title":"Problem 523 Continuous Subarray Sum"},{"categories":null,"content":"Problem Statement Link - Problem 1002 Question Given a string array words, return an array of all characters that show up in all strings within the words (including duplicates). You may return the answer in any order.\nExample 1 Input: words = [\u0026#34;bella\u0026#34;,\u0026#34;label\u0026#34;,\u0026#34;roller\u0026#34;] Output: [\u0026#34;e\u0026#34;,\u0026#34;l\u0026#34;,\u0026#34;l\u0026#34;] Example 2 Input: words = [\u0026#34;cool\u0026#34;,\u0026#34;lock\u0026#34;,\u0026#34;cook\u0026#34;] Output: [\u0026#34;c\u0026#34;,\u0026#34;o\u0026#34;] Constraints 1 \u0026lt;= words.length \u0026lt;= 100 1 \u0026lt;= words[i].length \u0026lt;= 100 words[i] consists of lowercase English letters. Solution class Solution { public: vector\u0026lt;string\u0026gt; commonChars(vector\u0026lt;string\u0026gt;\u0026amp; words) { vector\u0026lt;int\u0026gt;baselineCount(26,0); string temp; for(int i =0;i\u0026lt;words[0].size();i++) { baselineCount[words[0][i]-\u0026#39;a\u0026#39;]++; } for(auto word:words) { vector\u0026lt;int\u0026gt;newCount(26,0); for(const auto\u0026amp; ch:word) newCount[ch-\u0026#39;a\u0026#39;]++; for(int i= 0;i\u0026lt;26;i++) baselineCount[i] = min(baselineCount[i],newCount[i]); } vector\u0026lt;string\u0026gt;answer; for(int i =0; i\u0026lt;26;i++) { while(baselineCount[i]--) { temp = \u0026#34;\u0026#34;; temp += \u0026#39;a\u0026#39;+i; answer.push_back(temp); } } return answer; } }; Complexity Analysis Time Complexity : O(N) Space Complexity : O(1) Explanation 1. Intuition - We need to find the common characters in all the strings. - We need some kind of hash table to store all the common characters. - Characters may be repeated so we need to store the count of each character. 2. Implementation - Initialize a vector `baselineCount` of size 26 with all elements as `0`. - Iterate over the first word and increment the count of each character in the `baselineCount`. - Iterate over all the words and for each word create a new vector `newCount` of size 26 with all elements as `0`. - Increment the count of each character in the `newCount`. - Iterate over the `baselineCount` and `newCount` and update the `baselineCount` with the minimum of both. - This will give us the count of each character that is common in all the words seen so far. - Iterate over the `baselineCount` and for each character that has a count greater than `0` add it to the answer. - Return the answer. This problem is about finding the common characters in a given set of strings.\n","permalink":"https://KTS-o7.github.io/blog/posts/prev_solns/problem-find-common-characters/","tags":["string","hash-table","vector","array"],"title":"Problem 1002 Find Common Characters"},{"categories":null,"content":"Problem Statement Link - Problem 846 Question Alice has some number of cards and she wants to rearrange the cards into groups so that each group is of size groupSize, and consists of groupSize consecutive cards.\nGiven an integer array hand where hand[i] is the value written on the ith card and an integer groupSize, return true if she can rearrange the cards, or false otherwise.\nNote : Only groupSize matters not the number of groups. We can only form groups of size groupSize if total number of cards is divisible by groupSize. Consecutive cards means cards with consecutive values ie groups like [1,2,3] or [3,4,5] are valid but [1,3,4] is not valid for given groupSize = 3 Example 1 Input: hand = [1,2,3,6,2,3,4,7,8], groupSize = 3 Output: true Explanation: Alice\u0026#39;s hand can be rearranged as [1,2,3],[2,3,4],[6,7,8] Example 2 Input: hand = [1,2,3,4,5], groupSize = 4 Output: false Explanation: Alice\u0026#39;s hand can not be rearranged into groups of 4. Constraints - `1 \u0026lt;= hand.length \u0026lt;= 10^4` - `0 \u0026lt;= hand[i] \u0026lt;= 10^9` - `1 \u0026lt;= groupSize \u0026lt;= hand.length` Solution class Solution { public: bool isNStraightHand(vector\u0026lt;int\u0026gt;\u0026amp; hand, int groupSize) { std::ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); if (hand.size() % groupSize != 0) return false; map\u0026lt;int, int\u0026gt; freqCount; for (const int\u0026amp; card : hand) freqCount[card]++; for (auto it = freqCount.begin(); it != freqCount.end(); ++it) { if (it-\u0026gt;second \u0026gt; 0) { int count = it-\u0026gt;second; for (int i = 0; i \u0026lt; groupSize; ++i) { if (freqCount[it-\u0026gt;first + i] \u0026lt; count) return false; freqCount[it-\u0026gt;first + i] -= count; } } } return true; } }; Complexity Analysis Time Complexity : O(NlogN) Space Complexity : O(N) Explanation 1. Intuition - We need to check if we can form groups of size `groupSize` with given cards. - If not possible return false. - We need to maintain the count of each card. - We need this count to check if we can form groups of size `groupSize`. 2. Implementation - Check if total number of cards is divisible by `groupSize`. - If not return `false`. - Create a map `freqCount` to store the count of each card. - Iterate over the `hand` and increment the count of each card in `freqCount`. - For every card in `freqCount` check if the count is greater than `0`. - If yes then assign the count to a variable `count`. - Iterate over the next `groupSize` cards and check if the count of each card is greater than or equal to `count`. - This will help us to check if we can form groups of size `groupSize` with current card and next `groupSize-1` cards. - If not return `false`. - If yes then decrement the count of each card by `count`. - Continue this process until we have checked all the cards. - If we reach here then return `true`. This problem is also same as Problem 1296 . We need to dovode the array into groups of size k such that each group is consecutive.\n","permalink":"https://KTS-o7.github.io/blog/posts/prev_solns/problem-hand-of-straights/","tags":["greedy","hash-map","sorting"],"title":"Problem 846 Hand of Straights"},{"categories":null,"content":"Problem Statement Link - Problem 344 Question Write a function that reverses a string. The input string is given as an array of characters s.\nYou must do this by modifying the input array in-place with O(1) extra memory.\nExample 1 Input: s = [\u0026#34;h\u0026#34;,\u0026#34;e\u0026#34;,\u0026#34;l\u0026#34;,\u0026#34;l\u0026#34;,\u0026#34;o\u0026#34;] Output: [\u0026#34;o\u0026#34;,\u0026#34;l\u0026#34;,\u0026#34;l\u0026#34;,\u0026#34;e\u0026#34;,\u0026#34;h\u0026#34;] Example 2 Input: s = [\u0026#34;H\u0026#34;,\u0026#34;a\u0026#34;,\u0026#34;n\u0026#34;,\u0026#34;n\u0026#34;,\u0026#34;a\u0026#34;,\u0026#34;h\u0026#34;] Output: [\u0026#34;h\u0026#34;,\u0026#34;a\u0026#34;,\u0026#34;n\u0026#34;,\u0026#34;n\u0026#34;,\u0026#34;a\u0026#34;,\u0026#34;H\u0026#34;] Constraints 1 \u0026lt;= s.length \u0026lt;= 10^5 s[i] is a printable ascii character. Solution class Solution { public: void reverseString(vector\u0026lt;char\u0026gt;\u0026amp; s) { int start = 0, end = s.size()-1; char ch; while(start\u0026lt;end) { ch = s[start]; s[start] = s[end]; s[end] = ch; ++start; --end; } } }; Complexity Analysis Time Complexity : O(N) Space Complexity :O(1) Explanation 1. Intuition - Use two pointer approach to swap the elements. - We need to write a swapping logic without using any extra space. 2. Implementation 1. Initialize two pointers `start` and `end` to `0` and `s.size()-1` respectively. 2. Swap the elements at `start` and `end` index. 3. Increment `start` and decrement `end` until `start` is less than `end`. Alternate Solution class Solution { public: void reverseString(vector\u0026lt;char\u0026gt;\u0026amp; s) { reverse(s.begin(),s.end()); } }; Complexity Analysis Time Complexity : O(N) Space Complexity :O(1) Explanation - This solution uses the inbuilt `reverse` function to reverse the string. Utilizes the two pointer approach to swap the elements in the array.\n","permalink":"https://KTS-o7.github.io/blog/posts/prev_solns/problem-reverse-string/","tags":["two-pointer","string"],"title":"Problem 344 Reverse String"},{"categories":null,"content":"Problem Statement Link - Problem 3110 Question You are given a string s. The score of a string is defined as the sum of the absolute difference between the ASCII values of adjacent characters.\nReturn the score of s.\nExample 1 Input: s = \u0026#34;hello\u0026#34; Output: 13 Explanation: The ASCII values of the characters in s are: \u0026#39;h\u0026#39; = 104, \u0026#39;e\u0026#39; = 101, \u0026#39;l\u0026#39; = 108, \u0026#39;o\u0026#39; = 111. So, the score of s would be |104 - 101| + |101 - 108| + |108 - 108| + |108 - 111| = 3 + 7 + 0 + 3 = 13. Example 2 Input: s = \u0026#34;zaz\u0026#34; Output: 50 Explanation: The ASCII values of the characters in s are: \u0026#39;z\u0026#39; = 122, \u0026#39;a\u0026#39; = 97. So, the score of s would be |122 - 97| + |97 - 122| = 25 + 25 = 50. Constraints 2 \u0026lt;= s.length \u0026lt;= 100 s consists only of lowercase English letters. Solution class Solution { public: int scoreOfString(string s) { std::ios::sync_with_stdio(false); cout.tie(0); cin.tie(0); int score = 0; for(int i = 0;i\u0026lt;s.size()-1;i++) { score+= abs((int)(s[i]-s[i+1])); } return score; } }; Complexity Analysis Time Complexity: O(N) Space Complexity: O(1) Explanation 1. Intuition We can iterate over the string and calculate the score by taking the absolute difference between the ASCII values of adjacent characters. 2. Implementation Initialize the score to 0. Iterate over the string from 0 to s.size()-1. Calculate the score by taking the absolute difference between the ASCII values of adjacent characters. Return the score. This solution is a simple implementation of problem statement.\n","permalink":"https://KTS-o7.github.io/blog/posts/prev_solns/problem-score-of-a-string/","tags":["string","traversal"],"title":"Problem 3110 Score of a String"},{"categories":null,"content":"Problem Statement Link - Problem 131 Question Given a string s, partition s such that every substring of the partition is a palindrome. Return all possible palindrome partitioning of s.\nNote to self First we need to split the string into all possible substrings. Then we need to check if each substring is a palindrome or not. If that split is palindromic then we need to add it to the result. Example 1 Input: s = \u0026#34;aab\u0026#34; Output: [[\u0026#34;a\u0026#34;,\u0026#34;a\u0026#34;,\u0026#34;b\u0026#34;],[\u0026#34;aa\u0026#34;,\u0026#34;b\u0026#34;]] Example 2 Input: s = \u0026#34;a\u0026#34; Output: [[\u0026#34;a\u0026#34;]] Additional Examples s = \u0026#34;aaab\u0026#34; output = [[\u0026#34;a\u0026#34;,\u0026#34;a\u0026#34;,\u0026#34;a\u0026#34;,\u0026#34;b\u0026#34;],[\u0026#34;a\u0026#34;,\u0026#34;aa\u0026#34;,\u0026#34;b\u0026#34;],[\u0026#34;aa\u0026#34;,\u0026#34;a\u0026#34;,\u0026#34;b\u0026#34;],[\u0026#34;aaa\u0026#34;,\u0026#34;b\u0026#34;]] s = \u0026#34;abcaa\u0026#34; output = [[\u0026#34;a\u0026#34;,\u0026#34;b\u0026#34;,\u0026#34;c\u0026#34;,\u0026#34;a\u0026#34;,\u0026#34;a\u0026#34;],[\u0026#34;a\u0026#34;,\u0026#34;b\u0026#34;,\u0026#34;c\u0026#34;,\u0026#34;aa\u0026#34;]] s = \u0026#34;abbab\u0026#34; output = [[\u0026#34;a\u0026#34;,\u0026#34;b\u0026#34;,\u0026#34;b\u0026#34;,\u0026#34;a\u0026#34;,\u0026#34;b\u0026#34;],[\u0026#34;a\u0026#34;,\u0026#34;b\u0026#34;,\u0026#34;bab\u0026#34;],[\u0026#34;a\u0026#34;,\u0026#34;bb\u0026#34;,\u0026#34;a\u0026#34;,\u0026#34;b\u0026#34;],[\u0026#34;abba\u0026#34;,\u0026#34;b\u0026#34;]] s = \u0026#34;abaca\u0026#34; output = [[\u0026#34;a\u0026#34;,\u0026#34;b\u0026#34;,\u0026#34;a\u0026#34;,\u0026#34;c\u0026#34;,\u0026#34;a\u0026#34;],[\u0026#34;a\u0026#34;,\u0026#34;b\u0026#34;,\u0026#34;aca\u0026#34;],[\u0026#34;aba\u0026#34;,\u0026#34;c\u0026#34;,\u0026#34;a\u0026#34;]] s = \u0026#34;aaa\u0026#34; output = [[\u0026#34;a\u0026#34;,\u0026#34;a\u0026#34;,\u0026#34;a\u0026#34;],[\u0026#34;a\u0026#34;,\u0026#34;aa\u0026#34;],[\u0026#34;aa\u0026#34;,\u0026#34;a\u0026#34;],[\u0026#34;aaa\u0026#34;]] Constraints 1 \u0026lt;= s.length \u0026lt;= 16 s contains only lowercase English letters. Solution class Solution { public: vector\u0026lt;vector\u0026lt;string\u0026gt;\u0026gt; partition(string s) { std::ios::sync_with_stdio(false); cin.tie(0); cout.tie(0); vector\u0026lt;vector\u0026lt;string\u0026gt;\u0026gt; result; vector\u0026lt;string\u0026gt; path; backtrack(s, 0, path, result); return result; } private: void backtrack(const string\u0026amp; s, int start, vector\u0026lt;string\u0026gt;\u0026amp; path, vector\u0026lt;vector\u0026lt;string\u0026gt;\u0026gt;\u0026amp; result) { if (start == s.length()) { result.push_back(path); return; } for (int end = start + 1; end \u0026lt;= s.length(); ++end) { if (isPalindrome(s, start, end - 1)) { path.push_back(s.substr(start, end - start)); backtrack(s, end, path, result); path.pop_back(); } } } bool isPalindrome(const string\u0026amp; s, int left, int right) { while (left \u0026lt; right) { if (s[left++] != s[right--]) return false; } return true; } }; Complexity Analysis Time Complexity : O(N * 2^N) : 2^N subsets and each subset has N elements Space Complexity : O(N) : Recursive stack space Explanation 1. Intuition The intuition behind the solution is to use backtracking to generate all possible partitions of the input string s. For each position in the string, the algorithm considers extending the current partition with substrings starting from that position. Before extending, it checks if the substring is a palindrome using the isPalindrome helper function. If the substring is a palindrome, it adds the substring to the current partition (path) and recursively explores further partitions starting from the next character. Once a full partition is found (i.e., the end of the string is reached), it adds the partition to the result set. 2. Implementation Backtracking Function: The backtrack function is the core of the solution. It takes the input string s, the current start position, the current partition path, and the result set result. It iterates through the string, considering each position as a potential start of a new substring. For each position, it checks if the substring ending at that position is a palindrome. If so, it extends the current partition with this substring and recursively calls itself to explore further partitions. When the end of the string is reached, it means a valid partition has been found, which is then added to the result set. Is Palindrome Helper Function: The isPalindrome function checks if a given substring is a palindrome. It compares characters from both ends of the substring moving towards the center. If any pair of characters does not match, it returns false; otherwise, it continues comparing until the middle of the substring is reached, indicating that the entire substring is a palindrome. 3. Dry Run Let\u0026rsquo;s dry run the solution on the example input s = \u0026ldquo;aab\u0026rdquo; to understand how the backtracking algorithm generates all possible palindrome partitions. Input: s = \u0026#34;aab\u0026#34; Output: [[\u0026#34;a\u0026#34;,\u0026#34;a\u0026#34;,\u0026#34;b\u0026#34;],[\u0026#34;aa\u0026#34;,\u0026#34;b\u0026#34;]] - First, the backtrack function is called with the input string \u0026#34;aab\u0026#34;, start position 0, an empty path, and an empty result set. - At position 0, the substring \u0026#34;a\u0026#34; is a palindrome, so it is added to the path, and the function is recursively called with the updated path and the next position. - At position 1, the substring \u0026#34;a\u0026#34; is a palindrome, so it is added to the path, and the function is recursively called with the updated path and the next position. - At position 2, the substring \u0026#34;b\u0026#34; is a palindrome, so it is added to the path, and the function reaches the end of the string, adding the current partition [\u0026#34;a\u0026#34;,\u0026#34;a\u0026#34;,\u0026#34;b\u0026#34;] to the result set. - Backtracking occurs, and the last character \u0026#34;b\u0026#34; is removed from the path. - At position 1, the substring \u0026#34;aa\u0026#34; is a palindrome, so it is added to the path, and the function is recursively called with the updated path and the next position. - At position 2, the substring \u0026#34;b\u0026#34; is a palindrome, so it is added to the path, and the function reaches the end of the string, adding the current partition [\u0026#34;aa\u0026#34;,\u0026#34;b\u0026#34;] to the result set. - Backtracking occurs, and the last character \u0026#34;b\u0026#34; is removed from the path. - Backtracking occurs again, and the last character \u0026#34;a\u0026#34; is removed from the path. - The function returns the final result set containing all possible palindrome partitions of the input string \u0026#34;aab\u0026#34;. This solution uses backtracking to generate all possible palindrome partitions of the input string. By exploring all possible partitions, it ensures that no valid partition is missed, resulting in a complete set of palindrome partitions.\n","permalink":"https://KTS-o7.github.io/blog/posts/prev_solns/problem-palindrome-partitioning/","tags":["backtracking","recursion","cpp"],"title":"Problem 131 Palindrome Partitioning"},{"categories":null,"content":"Problem Statement Link - Problem 78 Question Given an integer array nums of unique elements, return all possible subsets (the power set).\nA subset of an array is a selection of elements (possibly none) of the array. The solution set must not contain duplicate subsets. Return the solution in any order.\nExample 1 Input: nums = [1,2,3] Output: [[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]] Example 2 Input: nums = [0] Output: [[],[0]] Constraints 1 \u0026lt;= nums.length \u0026lt;= 10 -10 \u0026lt;= nums[i] \u0026lt;= 10 All the numbers of nums are unique. Solution class Solution { public: vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; subsets(vector\u0026lt;int\u0026gt;\u0026amp; nums) { vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; result; result.push_back({}); int n; for (int num : nums) { n = result.size(); for (int i = 0; i \u0026lt; n; ++i) { vector\u0026lt;int\u0026gt; subset = result[i]; subset.push_back(num); result.push_back(subset); } } return result; } }; Complexity Analysis Time Complexity : O(N * 2^N) - 2^N subsets and each subset has N elements Space Complexity : O(N * 2^N) - 2^N subsets and each subset has N elements Explanation 1. Intuition The idea is to start with an empty subset and keep adding elements to it. For each element in the input array, we add it to all the existing subsets and create new subsets. 2. Implementation We start with an empty subset and add it to the result. For each element in the input array, we iterate over all the existing subsets and create new subsets by adding the current element to them. We add these new subsets to the result. Finally, we return the result containing all the subsets. Solution with backtracking class Solution { public: vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; subsets(vector\u0026lt;int\u0026gt;\u0026amp; nums) { vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; result; vector\u0026lt;int\u0026gt; subset; backtrack(result, subset, nums, 0); return result; } void backtrack(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; result, vector\u0026lt;int\u0026gt;\u0026amp; subset, vector\u0026lt;int\u0026gt;\u0026amp; nums, int start) { result.push_back(subset); for (int i = start; i \u0026lt; nums.size(); ++i) { subset.push_back(nums[i]); backtrack(result, subset, nums, i + 1); subset.pop_back(); } } }; Complexity Analysis of backtracking solution Time Complexity : O(N * 2^N) - 2^N subsets and each subset has N elements Space Complexity : O(N) - The depth of the recursion tree can go up to N Explanation of backtracking solution 1. Intuition We can either add an element to the subset or not add it. We will get one subset with element added to it and another subset without the element. Recursion tree for the input [1,2,3] graph TD A[ ] --\u003e B1[1] A[ ] --\u003e C[ ] B1[1] --\u003e D12[1, 2] B1[1] --\u003e E1[1] D12[1, 2] --\u003e F123[1, 2, 3] D12[1, 2] --\u003e G12[1, 2] E1[1] --\u003e L13[1, 3] E1[1] --\u003e M1[1] C[ ] --\u003e R2[2] C[ ] --\u003e S[ ] R2[2] --\u003e T23[2, 3] S[ ] --\u003e Z3[3] 2. Implementation result is the vector of all subsets. For each element in the input array, we add it to the subset and call the backtrack function recursively. In the backtrack function, we add the subset to the result and iterate over the remaining elements in the input array. This is ensured by starting the loop from the start index. Then we remove the current element from the subset once the recursive call returns. Shows the usage of backtracking to ensure proper subset generation.\n","permalink":"https://KTS-o7.github.io/blog/posts/prev_solns/problem-subsets/","tags":["backtracking","recursion","iterative","cpp"],"title":"Problem 78 Subsets"},{"categories":null,"content":"Problem Statement Link - Problem 1863 Question The XOR total of an array is defined as the bitwise XOR of all its elements, or 0 if the array is empty.\nFor example, the XOR total of the array [2,5,6] is 2 XOR 5 XOR 6 = 1. Given an array nums, return the sum of all XOR totals for every subset of nums.\nNote: Subsets with the same elements should be counted multiple times.\nAn array a is a subset of an array b if a can be obtained from b by deleting some (possibly zero) elements of b.\nExample 1 Input: nums = [1,3] Output: 6 Explanation: The 4 subsets of [1,3] are: - The empty subset has an XOR total of 0. - [1] has an XOR total of 1. - [3] has an XOR total of 3. - [1,3] has an XOR total of 1 XOR 3 = 2. 0 + 1 + 3 + 2 = 6 Example 2 Input: nums = [5,1,6] Output: 28 Explanation: The 8 subsets of [5,1,6] are: - The empty subset has an XOR total of 0. - [5] has an XOR total of 5. - [1] has an XOR total of 1. - [6] has an XOR total of 6. - [5,1] has an XOR total of 5 XOR 1 = 4. - [5,6] has an XOR total of 5 XOR 6 = 3. - [1,6] has an XOR total of 1 XOR 6 = 7. - [5,1,6] has an XOR total of 5 XOR 1 XOR 6 = 2. 0 + 5 + 1 + 6 + 4 + 3 + 7 + 2 = 28 Example 3 Input: nums = [3,4,5,6,7,8] Output: 480 Explanation: The sum of all XOR totals for every subset is 480. Constraints 1 \u0026lt;= nums.length \u0026lt;= 12 1 \u0026lt;= nums[i] \u0026lt;= 20 Solution class Solution { public: int subsetXORSum(vector\u0026lt;int\u0026gt;\u0026amp; nums) { std::ios::sync_with_stdio(false); return calculate(nums, 0, 0); } int calculate(vector\u0026lt;int\u0026gt;\u0026amp; nums, int level, int currentXOR) { if (level == nums.size()) return currentXOR; int include = calculate(nums, level + 1, currentXOR ^ nums[level]); int exclude = calculate(nums, level + 1, currentXOR); return include + exclude; } }; Complexity Analysis Time Complexity: O(2^n), where n is the length of nums. This is because there are 2^n subsets. Space Complexity: O(n), which is the depth of the recursion tree. Explanation 1. Intuition The problem requires calculating the XOR total of all subsets. Each element can either be included or excluded in a subset. We need to explore both possibilities for each element using recursion. Recursion Tree for Example 1 graph TD A[Start nums = 1, 3 currentXOR = 0] --\u003e B[Include 1 currentXOR = 1] A --\u003e C[Exclude 1 currentXOR = 0] B --\u003e D[Include 3 currentXOR = 1 XOR 3 = 2] B --\u003e E[Exclude 3 currentXOR = 1] C --\u003e F[Include 3 currentXOR = 0 XOR 3 = 3] C --\u003e G[Exclude 3 currentXOR = 0] D --\u003e H[Leaf Node currentXOR = 2] E --\u003e I[Leaf Node currentXOR = 1] F --\u003e J[Leaf Node currentXOR = 3] G --\u003e K[Leaf Node currentXOR = 0] 2. Implementation The calculate function is a recursive function that explores all subsets. At each step, we decide whether to include or exclude the current element. The base case is when we\u0026rsquo;ve considered all elements, at which point we return the current XOR total. The final result is the sum of XOR totals for all subsets. 3. Functions subsetXORSum: Initializes the recursive process. calculate: Recursively calculates the XOR total for all subsets, either including or excluding the current element, and sums the results. This problem demonstrates the use of recursion, backtracking and bit manipulation to solve combinatorial problems.\n","permalink":"https://KTS-o7.github.io/blog/posts/prev_solns/problem-sum-of-all-subset-xor-totals/","tags":["backtracking","bit-manipulation","recursion","cpp"],"title":"Problem 1863 Sum of All Subset XOR Totals"},{"categories":null,"content":"Problem Statement Link - Problem 3068 Question There exists an undirected tree with n nodes numbered 0 to n - 1. You are given a 0-indexed 2D integer array edges of length n - 1, where edges[i] = [ui, vi] indicates that there is an edge between nodes ui and vi in the tree. You are also given a positive integer k, and a 0-indexed array of non-negative integers nums of length n, where nums[i] represents the value of the node numbered i.\nAlice wants the sum of values of tree nodes to be maximum, for which Alice can perform the following operation any number of times (including zero) on the tree:\nChoose any edge [u, v] connecting the nodes u and v, and update their values as follows:\nnums[u] = nums[u] XOR k nums[v] = nums[v] XOR k Return the maximum possible sum of the values Alice can achieve by performing the operation any number of times. Example 1 Input: nums = [1,2,1], k = 3, edges = [[0,1],[0,2]] Output: 6 Explanation: Alice can achieve the maximum sum of 6 using a single operation: - Choose the edge [0,2]. nums[0] and nums[2] become: 1 XOR 3 = 2, and the array nums becomes: [1,2,1] -\u0026gt; [2,2,2]. The total sum of values is 2 + 2 + 2 = 6. It can be shown that 6 is the maximum achievable sum of values. flowchart TD id1(input) A((1)) --\u003e B((2)) A --\u003e C((1)) Example 2 Input: nums = [2,3], k = 7, edges = [[0,1]] Output: 9 Explanation: Alice can achieve the maximum sum of 9 using a single operation: - Choose the edge [0,1]. nums[0] becomes: 2 XOR 7 = 5 and nums[1] become: 3 XOR 7 = 4, and the array nums becomes: [2,3] -\u0026gt; [5,4]. The total sum of values is 5 + 4 = 9. It can be shown that 9 is the maximum achievable sum of values. flowchart TD id1(input) A((2)) --\u003e B((3)) Example 3 Input: nums = [7,7,7,7,7,7], k = 3, edges = [[0,1],[0,2],[0,3],[0,4],[0,5]] Output: 42 Explanation: The maximum achievable sum is 42 which can be achieved by Alice performing no operations. flowchart TD id1(input) A((7)) --\u003e B((7)) A --\u003e C((7)) A --\u003e D((7)) A --\u003e E((7)) A --\u003e F((7)) Constraints 2 \u0026lt;= n == nums.length \u0026lt;= 2 * 10*4 1 \u0026lt;= k \u0026lt;= 10^9 0 \u0026lt;= nums[i] \u0026lt;= 10^9 edges.length == n - 1 edges[i].length == 2 0 \u0026lt;= edges[i][0], edges[i][1] \u0026lt;= n - 1 The input is generated such that edges represent a valid tree. Solution static auto fastio = [](){ std::ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); return nullptr; }; class Solution { public: long long maximumValueSum(vector\u0026lt;int\u0026gt;\u0026amp; nums, int k, vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; edges) { long long res = 0; int changes = 0; int minDiff = INT_MAX; for (int num : nums) { int xorNum = num ^ k; if (num \u0026lt; xorNum) { changes++; res += xorNum; } else { res += num; } minDiff = min(minDiff, abs(num - xorNum)); } if (changes % 2 == 1) return res - minDiff; else return res; } }; Complexity Analysis Time Complexity : O(N) Space Complexity : O(1) Explanation 1. Intuition The problem is to find the maximum sum of the values of the nodes in the tree. We know that since its a tree, a path can be found between any two nodes. Hence we need to make sure that only even number of nodes need to be updated. 2. Implementation We iterate over the nodes and calculate the XOR value of the node with k. If the XOR value is greater than the original value, we update the node and increment the changes. We also calculate the minimum difference between the original value and the XOR value. If the number of changes is odd, we subtract the minimum difference from the result. This step is done to make sure that only even number of nodes are updated. Finally, we return the result. There are DP solutions possible for this problem, but the above greedy solution is the most optimal one. -\u0026gt; Click DP Solution In Leetcode ","permalink":"https://KTS-o7.github.io/blog/posts/prev_solns/problem-find-the-maximum-sum-of-node-values/","tags":["XOR","bit-manipulation","tree","greedy"],"title":"Problem 3068 Find the Maximum Sum of Node Values"},{"categories":null,"content":"Problem Statement Link - Problem 979 Question You are given the root of a binary tree with n nodes where each node in the tree has node.val coins. There are n coins in total throughout the whole tree.\nIn one move, we may choose two adjacent nodes and move one coin from one node to another. A move may be from parent to child, or from child to parent.\nReturn the minimum number of moves required to make every node have exactly one coin.\nNote Actually here the word minimum doesnt make any sense. Because we can move coins from parent to child and child to parent. What exactly we need to find is the flow of coins in a given path. Example 1 Input: root = [3,0,0] Output: 2 Explanation: From the root of the tree, we move one coin to its left child, and one coin to its right child. Example 2 Input: root = [0,3,0] Output: 3 Explanation: From the left child of the root, we move two coins to the root [taking two moves]. Then, we move one coin from the root of the tree to the right child. Example 3 (Important case) Since the only constraint is number of coins in the tree is same as number of nodes, it can be distributed in any manner.\nInput: root = [1,0,2] Output: 2 Explanation: From the root of the tree, we move one coin to the left child. From right child, we move one coin to the root. Constraints The number of nodes in the tree is n. 1 \u0026lt;= n \u0026lt;= 100 0 \u0026lt;= node.val \u0026lt;= n The sum of all node.val is n. Solution /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { int countSteps(TreeNode* root, int\u0026amp; step) { if( root == nullptr) return 0; int leftCoin = countSteps(root-\u0026gt;left,step); int rightCoin = countSteps(root-\u0026gt;right,step); step += abs(leftCoin) + abs(rightCoin); return (root-\u0026gt;val -1) + leftCoin + rightCoin; } public: int distributeCoins(TreeNode* root) { int ans = 0; countSteps(root,ans); return ans; } }; Complexity Analysis Time Complexity - O(N) - We are visiting each node once. Space Complexity - O(H) - Height of the tree. Explanation 1. Intuition We just need to find the movement of coins in the tree. If a node has y coins, then it will give y-1 coins to its parent. If a node has 0 coins then it will request 1 coin from its parent. So, we can say that abs(y-1) is the number of coins that will be moved from that node. Number of coins moved from a node is abs(z-1) + Coins from left subtree + Coins from right subtree. 2. Implementation If the root is null, return 0. This handles the base case. Recursively call the function on the left and right subtree. Calculate the number of coins moved from the left and right subtree. Store it in leftCoin and rightCoin. Store total steps so far done in step. Calculate the number of coins moved from the current node using the formula root-\u0026gt;val - 1 + leftCoin + rightCoin. ","permalink":"https://KTS-o7.github.io/blog/posts/prev_solns/problem-distribute-coins-in-binary-tree/","tags":["dfs","recursion","postorder","binary-tree"],"title":"Problem 979 Distribute Coins in Binary Tree"},{"categories":null,"content":"Problem Statement Link - Problem 1325 Question Given a binary tree root and an integer target, delete all the leaf nodes with value target.\nNote that once you delete a leaf node with value target, if its parent node becomes a leaf node and has the value target, it should also be deleted (you need to continue doing that until you cannot).\nExample 1 Input: root = [1,2,3,2,null,2,4], target = 2 Output: [1,null,3,null,4] Explanation: Leaf nodes in green with value (target = 2) are removed (Picture in left). After removing, new nodes become leaf nodes with value (target = 2) (Picture in center). flowchart TD id1(input) A((1)) --\u003e B((2)) A --\u003e C((3)) C --\u003e D((2)) D --\u003e E((2)) D --\u003e F((4)) id2(Output) G((1)) --\u003eH((3)) H --\u003e I((4)) Example 2 Input: root = [1,3,3,3,2], target = 3 Output: [1,3,null,null,2] flowchart TD id1(input) A((1)) --\u003e B((3)) A --\u003e C((3)) C --\u003e D((3)) D --\u003e E((3)) D --\u003e F((2)) id2(Output) G((1)) --\u003eH((3)) H --\u003e I((2)) Example 3 Input: root = [1,2,null,2,null,2], target = 2 Output: [1] Explanation: Leaf nodes in green with value (target = 2) are removed at each step. flowchart TD id1(input) A((1)) --\u003e B((2)) A --\u003e C((2)) C --\u003e D((2)) id2(Output) E((1)) Constraints The number of nodes in the tree is in the range [1, 3000]. 1 \u0026lt;= Node.val, target \u0026lt;= 1000 Solution /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: TreeNode* removeLeafNodes(TreeNode* root, int target) { if (!root) return nullptr; root-\u0026gt;left = removeLeafNodes(root-\u0026gt;left, target); root-\u0026gt;right = removeLeafNodes(root-\u0026gt;right, target); if (!root-\u0026gt;left \u0026amp;\u0026amp; !root-\u0026gt;right \u0026amp;\u0026amp; root-\u0026gt;val == target) return nullptr; return root; } }; Complexity Analysis Time complexity - O(N) Space complexity - O(H) Explanation 1. Intuition This can be solved using DFS. We will traverse the tree in post-order fashion. If the node is leaf and has the value equal to the target, Remove it. Otherwise, return the node. 2. Implementation If the root is null, return null. Recursively call the function on the left and right subtree. By this we will reach the leaf nodes. If the leaf node has the value equal to the target, return null. Otherwise, return the node. ","permalink":"https://KTS-o7.github.io/blog/posts/prev_solns/problem-delete-leaves-with-a-given-value/","tags":["binary-tree","dfs","recursion","postorder"],"title":"Problem 1325 Delete Leaves With a Given Value"},{"categories":null,"content":"Problem Statement Link - Problem 2331 Question You are given the root of a full binary tree with the following properties:\nLeaf nodes have either the value 0 or 1, where 0 represents False and 1 represents True. Non-leaf nodes have either the value 2 or 3, where 2 represents the boolean OR and 3 represents the boolean AND. The evaluation of a node is as follows:\nIf the node is a leaf node, the evaluation is the value of the node, i.e. True or False. Otherwise, evaluate the node\u0026rsquo;s two children and apply the boolean operation of its value with the children\u0026rsquo;s evaluations. Return the boolean result of evaluating the root node. A full binary tree is a binary tree where each node has either 0 or 2 children.\nA leaf node is a node that has zero children.\nExample 1 Input graph TD A((2))--\u003eB((1)) A--\u003eC((3)) C((3))--\u003eD((0)) C((3))--\u003eE((1)) F((OR))--\u003eG((True)) F--\u003eH((AND)) H--\u003eI((False)) H--\u003eJ((True)) Input: root = [2,1,3,null,null,0,1] Output: true Explanation: The above diagram illustrates the evaluation process. The AND node evaluates to False AND True = False. The OR node evaluates to True OR False = True. The root node evaluates to True, so we return true. Example 2 Input: root = [0] Output: false Explanation: The root node is a leaf node and it evaluates to false, so we return false. Constraints The number of nodes in the tree is in the range [1, 1000]. 0 \u0026lt;= Node.val \u0026lt;= 3 Every node has either 0 or 2 children. Leaf nodes have a value of 0 or 1. Non-leaf nodes have a value of 2 or 3. Solution /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: bool evaluateTree(TreeNode* root) { if(root-\u0026gt;left == nullptr \u0026amp;\u0026amp; root-\u0026gt;right == nullptr) return root-\u0026gt;val; else { if(root-\u0026gt;val == 2) return evaluateTree(root-\u0026gt;left) || evaluateTree(root-\u0026gt;right); else return evaluateTree(root-\u0026gt;left) \u0026amp;\u0026amp; evaluateTree(root-\u0026gt;right); } } }; Complexity Analysis Time: O(N) Space: O(N) Explanation 1. Intuition To evalute any node we need to evaluate its left and right child. There is no need to evaluate the leaf nodes as they are the base case. Using this we can develop a DFS based solution. 2. Implementation The evaluateTree function is used to evaluate the tree. If the node is a leaf node, we return the value of the node. Otherwise, we evaluate the left and right child and apply the operation based on the value of the node. If the value of the node is 2, we apply OR operation. If the value of the node is 3, we apply AND operation. ","permalink":"https://KTS-o7.github.io/blog/posts/prev_solns/problem-evaluate-boolean-binary-tree/","tags":["binary-tree","dfs","bit-manipulation","cpp"],"title":"Problem 2331 Evaluate Boolean Binary Tree"},{"categories":null,"content":"Problem Statement Link - Problem 1219 Question In a gold mine grid of size m x n, each cell in this mine has an integer representing the amount of gold in that cell, 0 if it is empty.\nReturn the maximum amount of gold you can collect under the conditions:\nEvery time you are located in a cell you will collect all the gold in that cell. From your position, you can walk one step to the left, right, up, or down. You can\u0026rsquo;t visit the same cell more than once. Never visit a cell with 0 gold. You can start and stop collecting gold from any position in the grid that has some gold. Example 1 Input: grid = [[0,6,0],[5,8,7],[0,9,0]] Output: 24 Explanation: [[0,6,0], [5,8,7], [0,9,0]] Path to get the maximum gold, 9 -\u0026gt; 8 -\u0026gt; 7. Example 2 Input: grid = [[1,0,7],[2,0,6],[3,4,5],[0,3,0],[9,0,20]] Output: 28 Explanation: [[1,0,7], [2,0,6], [3,4,5], [0,3,0], [9,0,20]] Path to get the maximum gold, 1 -\u0026gt; 2 -\u0026gt; 3 -\u0026gt; 4 -\u0026gt; 5 -\u0026gt; 6 -\u0026gt; 7. Constraints m == grid.length n == grid[i].length 1 \u0026lt;= m, n \u0026lt;= 15 0 \u0026lt;= grid[i][j] \u0026lt;= 100 There are at most 25 cells containing gold. Solution class Solution { const vector\u0026lt;pair\u0026lt;int,int\u0026gt;\u0026gt;direc = {{1,0},{-1,0},{0,-1},{0,1}}; int checkIfAllNonZeros(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; grid){ int count = 0; for(int i=0; i\u0026lt;grid.size(); i++){ for(int j=0; j\u0026lt;grid[0].size(); j++){ if(grid[i][j] != 0) count += grid[i][j]; else return 0; } } return count; } int dfs(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; grid, int x, int y, const int\u0026amp; row, const int\u0026amp; col) { if(x\u0026lt;0 || y\u0026lt;0 || x\u0026gt;=row || y\u0026gt;= col || grid[x][y] == 0) return 0; int val = grid[x][y]; grid[x][y] = 0; int localMax = val; for(const pair\u0026lt;int,int\u0026gt;\u0026amp; it:direc) { localMax = max(localMax, val + dfs(grid,x + it.first,y + it.second,row,col)); } grid[x][y] = val; return localMax; } public: int getMaximumGold(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; grid) { std::ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); int row = grid.size(), col = grid[0].size(); int maxVal = 0; int count = checkIfAllNonZeros(grid); if(count) { return count; } for(int i = 0; i\u0026lt;row; i++) { for(int j = 0; j\u0026lt;col; j++) { if(grid[i][j] != 0) maxVal = max(maxVal, dfs(grid,i,j,row,col)); } } return maxVal; } }; Complexity Analysis Time Complexity: O(4^{mn}). Space Complexity: O(mn). Explanation 1. Intuition We can start from any cell in the grid and move in any direction (up, down, left, right) to collect gold. We can\u0026rsquo;t visit the same cell more than once. We can\u0026rsquo;t visit a cell with 0 gold. We need to find the maximum amount of gold we can collect. This constraints suggest that we need to explore every possible path to find the maximum gold. Hence we need DFS to explore every possible path. But we need to backtrack so that a path once explored does not stop from exploring other paths. 2. Implementation The dfs function is used to explore every possible path. The checkIfAllNonZeros function is used to check if all the cells have non-zero gold. The edge case of all cells having non-zero gold is handled separately by the checkIfAllNonZeros function. The direc vector is used to move in all four directions. 3. Functions dfs function is used to explore every possible path.\nThe input to the dfs function is the grid, the current cell\u0026rsquo;s row and column, and the total number of rows and columns.\nIf the current cell is out of bounds or has 0 gold, we return 0.\nElse we store the current cell\u0026rsquo;s gold in a variable val.\nThen the current cell\u0026rsquo;s gold is set to 0.\nWe store the current cell\u0026rsquo;s gold in a variable localMax.\nRecursively we move in all four directions and store the maximum gold in the localMax variable.\nIf all 4 sides are 0 then the localMax will be equal to the current cell\u0026rsquo;s gold.\nWe restore the current cell\u0026rsquo;s gold to the original value.\nThis is to let other paths explore the current cell.\nWe return the localMax variable.\ngetMaximumGold function is used to find the maximum gold.\nThe input to the getMaximumGold function is the grid.\nWe initialize the row and col variables to store the total number of rows and columns.\nWe initialize the maxVal variable to store the maximum gold.\nWe check if all the cells have non-zero gold by calling the checkIfAllNonZeros function.\nIf all the cells have non-zero gold then we return the sum of all the cells.\nElse we iterate over all the cells and call the dfs function to find the maximum gold.\nWe return the maxVal variable.\nThis problem enables us to apply DFS and backtracking to a 2 dimensional matrix.\n","permalink":"https://KTS-o7.github.io/blog/posts/prev_solns/problem-path-with-maximum-gold/","tags":["matrix","dfs","backtracking","cpp"],"title":"Problem 1219 Path With Maximum Gold"},{"categories":null,"content":"Problem Statement Link - Problem 861 Question You are given an m x n binary matrix grid.\nA move consists of choosing any row or column and toggling each value in that row or column (i.e., changing all 0\u0026rsquo;s to 1\u0026rsquo;s, and all 1\u0026rsquo;s to 0\u0026rsquo;s).\nEvery row of the matrix is interpreted as a binary number, and the score of the matrix is the sum of these numbers.\nReturn the highest possible score after making any number of moves (including zero moves).\nExample 1 $$ \\left[ \\begin{array}{cccc} 0 \u0026 0 \u0026 1 \u0026 1 \\\\ 1 \u0026 0 \u0026 1 \u0026 0 \\\\ 1 \u0026 1 \u0026 0 \u0026 0 \\\\ \\end{array} \\right] \\rightarrow \\left[ \\begin{array}{cccc} 1 \u0026 1 \u0026 0 \u0026 0 \\\\ 1 \u0026 0 \u0026 1 \u0026 0 \\\\ 1 \u0026 1 \u0026 0 \u0026 0 \\\\ \\end{array} \\right] $$ $$ \\left[ \\begin{array}{cccc} 1 \u0026 1 \u0026 1 \u0026 0 \\\\ 1 \u0026 0 \u0026 0 \u0026 0 \\\\ 1 \u0026 1 \u0026 1 \u0026 0 \\\\ \\end{array} \\right] \\rightarrow \\left[ \\begin{array}{cccc} 1 \u0026 1 \u0026 1 \u0026 1 \\\\ 1 \u0026 0 \u0026 0 \u0026 1 \\\\ 1 \u0026 1 \u0026 1 \u0026 1 \\\\ \\end{array} \\right] $$ Input: grid = [[0,0,1,1],[1,0,1,0],[1,1,0,0]] Output: 39 Explanation: 0b1111 + 0b1001 + 0b1111 = 15 + 9 + 15 = 39 Example 2 Input: grid = [[0]] Output: 1 Constraints m == grid.length n == grid[i].length 1 \u0026lt;= m, n \u0026lt;= 20 grid[i][j] is either 0 or 1. Solution class Solution { public: int matrixScore(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; grid) { std::ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); for(int row =0; row\u0026lt;grid.size(); row++) { if(grid[row][0] == 0) { for(int col = 0; col\u0026lt;grid[0].size(); col++) { grid[row][col] = !grid[row][col]; } } } int zero = 0, one = 0; for(int col=0; col\u0026lt;grid[0].size(); col++) { for(int row=0; row\u0026lt;grid.size(); row++) { if(grid[row][col] == 0) zero++; else one++; } vector\u0026lt;int\u0026gt;zeroCnt(grid[0].size(),0); vector\u0026lt;int\u0026gt;oneCnt(grid[0].size(),0); if(zero \u0026gt; one ) { for(int row=0; row\u0026lt;grid.size(); row++) { grid[row][col] = !grid[row][col]; } } one = 0; zero = 0; } int answer = 0; int temp,base; for(int row = 0; row\u0026lt;grid.size(); row++) { temp = 0; base = 0; for(int col = grid[0].size()-1; col\u0026gt;=0; col--) { if(grid[row][col]) { temp+= (int)pow(2,base); } base++; } answer+= temp; } return answer; } }; Complexity Analysis Time Complexity - O(n^2) Space Complexity - O(1) Explanation 1. Intuition The goal is to maximize the final score of the matrix ie. maximize the sum of the binary numbers formed by the rows of the matrix. We can make a binary number maximum by making the most significant bit of the number 1. Example : 0111 is always less than 1000. Then we can greedily make the other bits of the number into 1 provided it increases the sum of the binary numbers formed by the rows of the matrix. We can iterate over the columns and check if the number of 0's in the column is greater than the number of 1's then we can flip the column. This flipping is guranteed to increase the sum of the binary numbers formed by the rows of the matrix. Example : [[1,0,1],[1,0,0]], if we flip 2nd column then the matrix becomes [[1,1,1],[1,1,0]] and the sum of the binary numbers formed by the rows of the matrix is 7+6 = 13 which is greater than 5+4 = 9. 2. Implementation Iterate over the rows of the matrix and if the first element of the row is 0 then flip the row. Iterate over the columns of the matrix and if the number of 0's in the column is greater than the number of 1's then flip the column. Calculate the sum of the binary numbers formed by the rows of the matrix and return the sum. Shows the implementation of greedy technique to maximize the sum of the binary numbers formed by the rows of the matrix.\n","permalink":"https://KTS-o7.github.io/blog/posts/prev_solns/problem-score-after-flipping-matrix/","tags":["matrix","greedy","bit-manipulation","cpp"],"title":"Problem 861 Score After Flipping Matrix"},{"categories":null,"content":"Problem Statement Link - Problem 2373 Question You are given an n x n integer matrix grid.\nGenerate an integer matrix maxLocal of size (n - 2) x (n - 2) such that:\nmaxLocal[i][j] is equal to the largest value of the 3 x 3 matrix in grid centered around row i + 1 and column j + 1. In other words, we want to find the largest value in every contiguous 3 x 3 matrix in grid.\nReturn the generated matrix.\nExample 1 $$ Input : grid = \\left[ \\begin{array}{cccc} 9 \u0026 9 \u0026 8 \u0026 1 \\\\ 5 \u0026 6 \u0026 2 \u0026 6 \\\\ 8 \u0026 2 \u0026 6 \u0026 4 \\\\ 6 \u0026 2 \u0026 2 \u0026 2 \\\\ \\end{array} \\right] Output : \\left[ \\begin{array}{cc} 9 \u0026 9 \\\\ 8 \u0026 6 \\\\ \\end{array} \\right] $$ Input: grid = [[9,9,8,1],[5,6,2,6],[8,2,6,4],[6,2,2,2]] Output: [[9,9],[8,6]] Explanation: The diagram above shows the original matrix and the generated matrix. Each value in the generated matrix corresponds to the largest value of a contiguous 3 x 3 matrix in grid. Example 2 $$ Input : grid = \\left[ \\begin{array}{cccccc} 1 \u0026 1 \u0026 1 \u0026 1 \u0026 1 \\\\ 1 \u0026 1 \u0026 1 \u0026 1 \u0026 1 \\\\ 1 \u0026 1 \u0026 2 \u0026 1 \u0026 1 \\\\ 1 \u0026 1 \u0026 1 \u0026 1 \u0026 1 \\\\ 1 \u0026 1 \u0026 1 \u0026 1 \u0026 1 \\\\ \\end{array} \\right] Output : \\left[ \\begin{array}{ccc} 2 \u0026 2 \u0026 2 \\\\ 2 \u0026 2 \u0026 2 \\\\ 2 \u0026 2 \u0026 2 \\\\ \\end{array} \\right] $$ Input: grid = [[1,1,1,1,1],[1,1,1,1,1],[1,1,2,1,1],[1,1,1,1,1],[1,1,1,1,1]] Output: [[2,2,2],[2,2,2],[2,2,2]] Explanation: Notice that the 2 is contained within every contiguous 3 x 3 matrix in grid. Constraints n == grid.length == grid[i].length 3 \u0026lt;= n \u0026lt;= 100 1 \u0026lt;= grid[i][j] \u0026lt;= 100 Solution class Solution { public: vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; largestLocal(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; grid) { vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;ans(grid.size()-2,vector\u0026lt;int\u0026gt;(grid[0].size()-2)); int locMax = INT_MIN; for(int row = 0; row \u0026lt; grid.size()-2; row++) { for(int col = 0; col \u0026lt; grid[0].size()-2; col++) { for(int i = row; i\u0026lt;row+3; i++) { for(int j = col; j\u0026lt;col+3; j++) locMax = max(locMax,grid[i][j]); } ans[row][col] = locMax; locMax = INT_MIN; } } return ans; } }; Complexity Analysis Time Complexity - O(n^2) Space Complexity - O(n^2) We are iterating over a 3x3 matrix each time thats 9 units and we have to visit each cell of the matrix so the time complexity is 9*n^2 which is O(n^2). The space complexity is O(n^2) as we are storing the result in a 2D vector of size (n-2) x (n-2). Explanation 1. Intuition We need to find the largest value in every contiguous 3 x 3 matrix in grid. We can iterate over the matrix and find the largest value in every 3 x 3 matrix. We can store the result in a new matrix and return it. To iterate over each contiguous 3 x 3 matrix, we need to iterate over the rows and columns of the matrix. 2. Implementation Initialize a 2D vector ans of size (n-2) x (n-2) to store the result. Initialize a variable locMax to store the maximum value in the 3 x 3 matrix. Iterate over the rows from 0 to n-2 and columns from 0 to n-2. This will give us the starting point of each 3 x 3 matrix. Iterate over the rows from row to row+3 and columns from col to col+3. This will give us the 3 x 3 matrix. Find the maximum value in the 3 x 3 matrix and store it in locMax. Store the maximum value in the result matrix ans[row][col]. Reset locMax to INT_MIN for the next 3 x 3 matrix. Return the result matrix ans. Intresting fact This problem closely simulates a very powerful ML algorithm in CNNs called as Max Pooling. Max pooling is a sample-based discretization process. The objective is to down-sample an input representation (image, hidden-layer output matrix, etc.), reducing its dimensionality and allowing for assumptions to be made about features contained in the sub-regions binned.\nKey terms in Max Pooling:\nPooling Layer: The pooling layer is a new layer added after the convolutional layer. It is used to reduce the spatial dimensions of the output volume. Max Pooling: Max pooling is a pooling operation that selects the maximum element from the region of the feature map covered by the filter. Thus, the output after max-pooling is the maximum value of the region covered by the filter. Filter: The filter is a matrix that is used to extract features from the input image. The filter is also known as a kernel. The filter is applied to the input image to produce the feature map. In this case, the filter is of size 3x3. Stride: The stride is the number of pixels by which the filter is moved over the input image. The stride is used to reduce the spatial dimensions of the output volume. In this case, the stride is 1. This problem simulates Max pooling. This shows a real world application of a DSA problem.\n","permalink":"https://KTS-o7.github.io/blog/posts/prev_solns/problem-largest-local-values-in-a-matrix/","tags":["matrix","2D-array","cpp","vector"],"title":"Problem 2373 Largest Local Values in a Matrix"},{"categories":null,"content":"Problem Statement Link - Problem 786 Question You are given a sorted integer array arr containing 1 and prime numbers, where all the integers of arr are unique. You are also given an integer k.\nFor every i and j where 0 \u0026lt;= i \u0026lt; j \u0026lt; arr.length, we consider the fraction arr[i] / arr[j].\nReturn the kth smallest fraction considered. Return your answer as an array of integers of size 2, where answer[0] == arr[i] and answer[1] == arr[j].\nExample 1 Input: arr = [1,2,3,5], k = 3 Output: [2,5] Explanation: The fractions to be considered in sorted order are: 1/5, 1/3, 2/5, 1/2, 3/5, and 2/3. The third fraction is 2/5. Example 2 Input: arr = [1,7], k = 1 Output: [1,7] Constraints 2 \u0026lt;= arr.length \u0026lt;= 1000 1 \u0026lt;= arr[i] \u0026lt;= 3 * 10^4 arr[0] == 1 arr[i] is a prime number for i \u0026gt; 0. All the numbers of arr are unique and sorted in strictly increasing order. 1 \u0026lt;= k \u0026lt;= arr.length * (arr.length - 1) / 2 Solution class Solution { public: vector\u0026lt;int\u0026gt; kthSmallestPrimeFraction(vector\u0026lt;int\u0026gt;\u0026amp; arr, int k) { std::ios::sync_with_stdio(false); cin.tie(0); cout.tie(0); auto comparePair = [](const pair\u0026lt;int,int\u0026gt;\u0026amp; a,const pair\u0026lt;int,int\u0026gt;\u0026amp; b) { return a.first*b.second \u0026gt; b.first*a.second; }; priority_queue\u0026lt;pair\u0026lt;int,int\u0026gt;,vector\u0026lt;pair\u0026lt;int,int\u0026gt;\u0026gt;, decltype(comparePair)\u0026gt;minheap; for(int i = 0;i\u0026lt;arr.size();i++) { for(int j=i+1;j\u0026lt;arr.size();j++) { minheap.push(make_pair(arr[i],arr[j])); } } vector\u0026lt;int\u0026gt;answer(2,0); while(k\u0026gt;1 \u0026amp;\u0026amp; !minheap.empty()) { k--; minheap.pop(); } answer[0] = minheap.top().first; answer[1] = minheap.top().second; return answer; } }; Complexity Analysis Time Complexity - O(n^2logn) Space Complexity - O(n^2) Time complexity of adding a node to the heap is O(logn) and we are adding n*(n-1)/2 nodes to the heap. So, the time complexity is O(n^2logn). Space complexity is O(n^2) because we are storing n*(n-1)/2 pairs in the heap. Explanation 1. Intuition Since we need to find the kth smallest fraction, we can use a min heap to store the fractions. For that we need to have all the possible fractions in the heap. We can generate all the possible fractions by iterating over the array and adding the fractions to the heap. 2. Implementation We need to have a min heap whose contents are pairs of integers.\nEach pair {a,b} in the heap represents the fraction a/b.\nWe need to define a custom comparator for the heap, because by default the heap will be a max heap.\nThe function comparePair checks if the fraction a/b is smaller than the fraction c/d.\nA fraction \\(\\dfrac{a}{b}\\ \u003e \\dfrac{c}{d}\\ = a \\cdot d \u003e b \\cdot c\\) The comparator returns false if a*d \u0026gt; b*c, which means that the fraction a/b is smaller than c/d.\nSince by default the heap is a max heap, we need to make sure that the comparator returns false if a*d \u0026gt; b*c.\nThen the node which has {a,b} will move up in the heap than the node which has {c,d}.\nWe will iterate over the array and generate all the possible fractions.\nFirst loop will set the numerator and the second loop will set the denominator.\nWe will add the fraction to the heap.\nWe will pop k-1 elements from the heap.\nThe kth element will be the kth smallest fraction.\nWe will return the kth smallest fraction as answer[0] and answer[1].\nAdditional Notes This problem can also be solved using binary search. We can use binary search to find the fraction that is the kth smallest. class Solution { public: vector\u0026lt;int\u0026gt; kthSmallestPrimeFraction(vector\u0026lt;int\u0026gt;\u0026amp; arr, int k) { const int n = arr.size(); double l = 0.0; double r = 1.0; while (l \u0026lt; r) { const double m = (l + r) / 2.0; int fractionsNoGreaterThanM = 0; int p = 0; int q = 1; // For each index i, find the first index j s.t. arr[i] / arr[j] \u0026lt;= m, // so fractionsNoGreaterThanM for index i will be n - j. for (int i = 0, j = 1; i \u0026lt; n; ++i) { while (j \u0026lt; n \u0026amp;\u0026amp; arr[i] \u0026gt; m * arr[j]) ++j; if (j == n) break; fractionsNoGreaterThanM += n - j; if (p * arr[j] \u0026lt; q * arr[i]) { p = arr[i]; q = arr[j]; } } if (fractionsNoGreaterThanM == k) return {p, q}; if (fractionsNoGreaterThanM \u0026gt; k) r = m; else l = m; } throw; } }; The above code uses binary search to find the kth smallest fraction. We start with the range [0,1] and find the middle value. We iterate over the array and find the number of fractions that are less than or equal to m. If the number of fractions is equal to k, we return the fraction. If the number of fractions is greater than k, we reduce the range to [l,m]. If the number of fractions is less than k, we increase the range to [m,r]. Time Complexity - O(nlogn) Space Complexity - O(1) This problem helps us to understand how to use a min heap to solve a problem that requires finding the kth smallest element.\n","permalink":"https://KTS-o7.github.io/blog/posts/prev_solns/problem-k-th-smallest-prime-fraction/","tags":["priority-queue","binary-search","array","math","heap","cpp"],"title":"Problem 786 K th Smallest Prime Fraction"},{"categories":null,"content":"Problem Statement Link - Problem 3075 Question You are given an array happiness of length n, and a positive integer k.\nThere are n children standing in a queue, where the ith child has happiness value happiness[i]. You want to select k children from these n children in k turns.\nIn each turn, when you select a child, the happiness value of all the children that have not been selected till now decreases by 1. Note that the happiness value cannot become negative and gets decremented only if it is positive.\nReturn the maximum sum of the happiness values of the selected children you can achieve by selecting k children.\nExample 1 Input: happiness = [1,2,3], k = 2 Output: 4 Explanation: We can pick 2 children in the following way: - Pick the child with the happiness value == 3. The happiness value of the remaining children becomes [0,1]. - Pick the child with the happiness value == 1. The happiness value of the remaining child becomes [0]. - Note that the happiness value cannot become less than 0. The sum of the happiness values of the selected children is 3 + 1 = 4. Example 2 Input: happiness = [1,1,1,1], k = 2 Output: 1 Explanation: We can pick 2 children in the following way: - Pick any child with the happiness value == 1. The happiness value of the remaining children becomes [0,0,0]. - Pick the child with the happiness value == 0. The happiness value of the remaining child becomes [0,0]. The sum of the happiness values of the selected children is 1 + 0 = 1. Example 3 Input: happiness = [2,3,4,5], k = 1 Output: 5 Explanation: We can pick 1 child in the following way: - Pick the child with the happiness value == 5. The happiness value of the remaining children becomes [1,2,3]. The sum of the happiness values of the selected children is 5. Constraints 1 \u0026lt;= n == happiness.length \u0026lt;= 2 * 10^5 1 \u0026lt;= happiness[i] \u0026lt;= 10^8 1 \u0026lt;= k \u0026lt;= n Solution class Solution { public: long long maximumHappinessSum(vector\u0026lt;int\u0026gt;\u0026amp; happiness, int k) { std::ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); priority_queue\u0026lt;int\u0026gt;heap; for(const int it:happiness) heap.push(it); long long count = 0; long long answer = 0; while(k\u0026gt;0 \u0026amp;\u0026amp; !heap.empty()) { answer = ((heap.top()-count)\u0026gt;=0)?answer+heap.top()-count:answer+0; heap.pop(); k--; count++; } return answer; } }; Complexity Analysis Time: O(nlogn) Space: O(n) Explanation 1. Intuition Since the order of selection does not matter, we can select the children with the highest happiness values first. this greedy approach will ensure that we maximize the sum of happiness values of the selected children. For this we need the array in sorted order, so we use a max heap to store the happiness values of the children. 2. Implementation We use a max heap to store the happiness values of the children. We iterate over the heap and select the children with the highest happiness values. We keep track of the count to ensure that the happiness value of the children that have not been selected decreases by 1. We will check if the difference between the happiness value and the count is greater than or equal to 0, if yes we add the difference to the answer, else we add 0. This makes sure that the happiness value does not become negative. We return the answer. Alternate Approach We can use the sorted vector to store the happiness values of the children. class Solution { public: long long maximumHappinessSum(vector\u0026lt;int\u0026gt;\u0026amp; happiness, int k) { ios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0); sort(happiness.begin(), happiness.end(), greater\u0026lt;int\u0026gt;()); long long sum = 0; for(int i = 0; i \u0026lt; k; i++) { happiness[i] = max(0, happiness[i]-i); sum += happiness[i]; } return sum; } }; This will be faster than the heap approach, as we do not need to maintain the heap.\nThis problem demonstrates the use of a max heap to solve a greedy problem.\n","permalink":"https://KTS-o7.github.io/blog/posts/prev_solns/problem-maximize-happiness-of-selected-children/","tags":["cpp","vector","heap","priority-queue","greedy"],"title":"Problem 3075 Maximize Happiness of Selected Children"},{"categories":null,"content":"Problem Statement Link - Problem 506 Question You are given an integer array score of size n, where score[i] is the score of the ith athlete in a competition. All the scores are guaranteed to be unique.\nThe athletes are placed based on their scores, where the 1st place athlete has the highest score, the 2nd place athlete has the 2nd highest score, and so on. The placement of each athlete determines their rank:\nThe 1st place athlete\u0026rsquo;s rank is \u0026quot;Gold Medal\u0026quot;. The 2nd place athlete\u0026rsquo;s rank is \u0026quot;Silver Medal\u0026quot;. The 3rd place athlete\u0026rsquo;s rank is \u0026quot;Bronze Medal\u0026quot;. For the 4th place to the nth place athlete, their rank is their placement number (i.e., the xth place athlete\u0026rsquo;s rank is \u0026quot;x\u0026quot;). Return an array answer of size n where answer[i] is the rank of the ith athlete.\nExample 1 Input: score = [5,4,3,2,1] Output: [\u0026#34;Gold Medal\u0026#34;,\u0026#34;Silver Medal\u0026#34;,\u0026#34;Bronze Medal\u0026#34;,\u0026#34;4\u0026#34;,\u0026#34;5\u0026#34;] Explanation: The placements are [1st, 2nd, 3rd, 4th, 5th]. Example 2 Input: score = [10,3,8,9,4] Output: [\u0026#34;Gold Medal\u0026#34;,\u0026#34;5\u0026#34;,\u0026#34;Bronze Medal\u0026#34;,\u0026#34;Silver Medal\u0026#34;,\u0026#34;4\u0026#34;] Explanation: The placements are [1st, 5th, 3rd, 2nd, 4th]. Constraints n == score.length 1 \u0026lt;= n \u0026lt;= 10^4 0 \u0026lt;= score[i] \u0026lt;= 10^6 All the values in score are unique. Solution class Solution { public: vector\u0026lt;string\u0026gt; findRelativeRanks(vector\u0026lt;int\u0026gt;\u0026amp; score) { auto comparePair = [](const pair\u0026lt;int,int\u0026gt;\u0026amp; a,const pair\u0026lt;int,int\u0026gt;\u0026amp; b) { return a.first\u0026lt;b.first; }; priority_queue\u0026lt;pair\u0026lt;int,int\u0026gt;, vector\u0026lt;pair\u0026lt;int,int\u0026gt;\u0026gt;, decltype(comparePair)\u0026gt; maxHeap; for(int i = 0;i\u0026lt;score.size();i++) maxHeap.push(make_pair(score[i],i)); vector\u0026lt;string\u0026gt;answer(score.size()); pair\u0026lt;int,int\u0026gt; holder; int place = 0; vector\u0026lt;string\u0026gt;places = {\u0026#34;Gold Medal\u0026#34;,\u0026#34;Silver Medal\u0026#34;,\u0026#34;Bronze Medal\u0026#34;}; while(!maxHeap.empty() \u0026amp;\u0026amp; place \u0026lt;3) { holder = maxHeap.top(); maxHeap.pop(); answer[holder.second] = places[place]; place++; } while(!maxHeap.empty()) { holder = maxHeap.top(); maxHeap.pop(); answer[holder.second] = to_string(++place); } return answer; } }; Complexity Analysis Time: O(nlogn) Space: O(n) Explanation 1. Intuition Since the scores need to be relatively ordered in decreasing order, along with the index which they occured. We can use a priority queue to store the scores and their index. We would need to have a custom comparator to compare the scores. This needs to be a max heap, so that we can get the highest score first. 2. Implementation We can use a priority queue to store the scores and their index. We can use a custom comparator to compare the scores. The custom comparator comparePair compares the pair\u0026lt;score,index_which_it_occured\u0026gt;. The lambda function comparePair does a.first\u0026lt;b.first because internally the priority queue is a max heap, hence the highest score would be at the top. The custom comparator ensures that the the pair with highest score is at the top of the heap. The keyword decltype is used to get the type of the lambda function. Priority queue needs to have a callable object as a comparator, hence we pass the lambda function comparePair. We will first push the scores and their index into the priority queue. We will have a vector of strings answer to store the ranks of the athletes. We will have a variable place to keep track of the rank. We will have a vector of strings places to store the medals of the athletes. We will iterate the priority queue until the place is less than 3. We will pop the top element from the priority queue. We will assign the rank to the athlete based on the place. 1st place athlete\u0026rsquo;s rank is \u0026quot;Gold Medal\u0026quot;. 2nd place athlete\u0026rsquo;s rank is \u0026quot;Silver Medal\u0026quot;. 3rd place athlete\u0026rsquo;s rank is \u0026quot;Bronze Medal\u0026quot;. We will increment the place after assigning the rank each time. Then check if there are any more athletes left. If there are any athletes left, assign the rank based on the place. The ranks is a string hence use the to_string function to convert the integer to string. Return the answer vector. Alternate Solution A solution with a map can be used to store the scores and their index. class Solution { public: vector\u0026lt;string\u0026gt; findRelativeRanks(vector\u0026lt;int\u0026gt;\u0026amp; score) { int n = score.size(); map\u0026lt;int, int\u0026gt; mp1; vector\u0026lt;string\u0026gt; result(n); for (int i = 0; i \u0026lt; n; i++) { mp1[score[i]] = i; } sort(score.begin(), score.end(), greater\u0026lt;int\u0026gt;()); for (int i = 0; i \u0026lt; n; i++) { if (i == 0) { result[mp1[score[i]]] = \u0026#34;Gold Medal\u0026#34;; } else if (i == 1) { result[mp1[score[i]]] = \u0026#34;Silver Medal\u0026#34;; } else if (i == 2) { result[mp1[score[i]]] = \u0026#34;Bronze Medal\u0026#34;; } else { result[mp1[score[i]]] = to_string(i + 1); } } return result; } }; Time Complexity: O(nlogn) Space Complexity: O(n) A solution with built in comparator for priority queue can be used. class Solution { public: vector\u0026lt;string\u0026gt; findRelativeRanks(vector\u0026lt;int\u0026gt;\u0026amp; score) { std::ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); priority_queue\u0026lt;pair\u0026lt;int,int\u0026gt;\u0026gt; maxHeap; for(int i = 0;i\u0026lt;score.size();i++) maxHeap.push(make_pair(score[i],i)); vector\u0026lt;string\u0026gt;answer(score.size()); pair\u0026lt;int,int\u0026gt; holder; int place = 0; vector\u0026lt;string\u0026gt;places = {\u0026#34;Gold Medal\u0026#34;,\u0026#34;Silver Medal\u0026#34;,\u0026#34;Bronze Medal\u0026#34;}; while(!maxHeap.empty() \u0026amp;\u0026amp; place \u0026lt;3) { holder = maxHeap.top(); maxHeap.pop(); answer[holder.second] = places[place]; place++; } while(!maxHeap.empty()) { holder = maxHeap.top(); maxHeap.pop(); answer[holder.second] = to_string(++place); } return answer; } }; This problem demonstrtaes the use of priority queue and custom comparators to solve the problem. The alternate solutions are also provided for the same problem.\n","permalink":"https://KTS-o7.github.io/blog/posts/prev_solns/problem-relative-ranks/","tags":["priority-queue","cpp","vector","strings","heap","custom-comparator"],"title":"Problem 506 Relative Ranks"},{"categories":null,"content":"Problem Statement Link - Problem 2816 Question You are given the head of a non-empty linked list representing a non-negative integer without leading zeroes.\nReturn the head of the linked list after doubling it\nExample 1 Input graph LR A((1))--\u003eB((8)) B--\u003eC((9)) Output graph LR A((3))--\u003eB((7)) B--\u003eC((8)) Input: head = [1,8,9] Output: [3,7,8] Explanation: The figure above corresponds to the given linked list which represents the number 189. Hence, the returned linked list represents the number 189 * 2 = 378. Example 2 Input graph LR A((9))--\u003eB((9)) B--\u003eC((9)) Output graph LR A((1))--\u003eB((9)) B--\u003eC((9)) C--\u003eD((8)) Input: head = [9,9,9] Output: [1,9,9,8] Explanation: The figure above corresponds to the given linked list which represents the number 999. Hence, the returned linked list reprersents the number 999 * 2 = 1998. Constraints The number of nodes in the list is in the range [1, 10^4]. 0 \u0026lt;= Node.val \u0026lt;= 9 The input is generated such that the list represents a number that does not have leading zeros, except the number 0 itself. Solution /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ class Solution { public: ListNode* doubleIt(ListNode* head) { std::ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); stack\u0026lt;ListNode*\u0026gt;st; ListNode* temp = head; while(temp!=nullptr) { st.push(temp); temp=temp-\u0026gt;next; } int carry = 0, newVal = 0; while(!st.empty()) { temp = st.top(); st.pop(); newVal = 2*temp-\u0026gt;val + carry; carry = newVal/10; newVal = newVal%10; //cout\u0026lt;\u0026lt;carry\u0026lt;\u0026lt;newVal\u0026lt;\u0026lt;endl; temp-\u0026gt;val = newVal; } if(carry) { ListNode* newhead = new ListNode(carry,head); return newhead; } return head; } }; Complexity Time : O(n) Space : O(n) Explanation 1. Intuition We need to iterate the linked list in reverse order to double the number. From the last node we need to double the value and keep track of the carry. We can use a stack to store the nodes in reverse order. 2. Implementation Have a stack to store the nodes in reverse order. Push all the nodes into the stack. Pop the nodes from the stack and double the value of the node. Calculate the carry and the new value. Carry = NewValue/10, NewValue = NewValue%10. Update the value of the node. Do this for all the nodes. If there is a carry left after the last node, create a new node with the carry and return the new head. Else return the head of the linked list. This is a problem where FIFO principle of stack is used to reverse the linkedlist without manipulating any pointers.\n","permalink":"https://KTS-o7.github.io/blog/posts/prev_solns/problem-double-a-number-represented-as-a-linked-list/","tags":["linked-list","cpp","stack","pointers"],"title":"Problem 2816 Double a Number Represented as a Linked List"},{"categories":null,"content":"Problem Statement Link - Problem 2487 Question You are given the head of a linked list.\nRemove every node which has a node with a greater value anywhere to the right side of it.\nReturn the head of the modified linked list.\nExample 1 Input graph LR A((5))--\u003eB((2)) B--\u003eC((13)) C--\u003eD((3)) D--\u003eE((8)) Output graph LR A((13))--\u003eB((8)) Input: head = [5,2,13,3,8] Output: [13,8] Explanation: The nodes that should be removed are 5, 2 and 3. - Node 13 is to the right of node 5. - Node 13 is to the right of node 2. - Node 8 is to the right of node 3. Example 2 Input graph LR A((1))--\u003eB((1)) B--\u003eC((1)) C--\u003eD((1)) Output graph LR A((1))--\u003eB((1)) B--\u003eC((1)) C--\u003eD((1)) Input: head = [1,1,1,1] Output: [1,1,1,1] Explanation: Every node has value 1, so no nodes are removed. Constraints The number of the nodes in the given list is in the range [1, 10^5]. 1 \u0026lt;= Node.val \u0026lt;= 10^5 Solution /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ class Solution { public: ListNode* removeNodes(ListNode* head) { std::ios::sync_with_stdio(false); stack\u0026lt;ListNode*\u0026gt; st; ListNode* temp = head; while(temp != nullptr) { if(st.empty()) { st.push(temp); temp = temp-\u0026gt;next; } else { while(!st.empty() \u0026amp;\u0026amp; temp-\u0026gt;val \u0026gt; st.top()-\u0026gt;val) st.pop(); st.push(temp); temp=temp-\u0026gt;next; } } ListNode* newHead = nullptr; while(!st.empty()) { temp = st.top(); st.pop(); temp-\u0026gt;next = newHead; newHead = temp; } return newHead; } }; Complexity Time : O(n) Space : O(n) Explanation 1. Intuition We want to remove every node which has a node with value greater than current node to the right side of it. If we use a loop once and check for every node to the right side of it, it will take O(n^2) time. We can use a stack to store the nodes in decreasing order. This monotonically decreasing stack will help us to remove the nodes which have a greater value to the right side of it. The idea is to traverse the linked list and keep pushing the nodes into the stack. If the current node has a greater value than the top of the stack, we will pop the stack until the top of the stack has a greater value than the current node. After traversing the linked list, we will pop the stack and create a new linked list in reverse order. We need it in reverse order because the stack will have the nodes from the end of the linked list to the start of the linked list. 2. Implementation We will create a stack to store the nodes. We will traverse the linked list and push the nodes into the stack. If the stack is empty, we will push the current node into the stack. If the stack is not empty, we will check if the current node has a greater value than the top of the stack. If the current node has a greater value than the top of the stack, we will pop the stack until the top of the stack has a greater value than the current node. After traversing the linked list, we will pop the stack and create a new linked list in reverse order. We will return the head of the new linked list. Note: This problem showcases the use of monotonic stack\n","permalink":"https://KTS-o7.github.io/blog/posts/prev_solns/problem-remove-nodes-from-linked-list/","tags":["monotonic-stack","linked-list","pointers","stack","cpp"],"title":"Problem 2487 Remove Nodes From Linked List"},{"categories":null,"content":"Problem Statement Link - Problem 237 Question There is a singly-linked list head and we want to delete a node node in it.\nYou are given the node to be deleted node. You will not be given access to the first node of head.\nAll the values of the linked list are unique, and it is guaranteed that the given node node is not the last node in the linked list.\nDelete the given node. Note that by deleting the node, we mean that :\nThe value of the given node should not exist in the linked list. The number of nodes in the linked list should decrease by one. All the values before node should be in the same order. All the values after node should be in the same order. Example 1 Input: head = [4,5,1,9], node = 5 Output: [4,1,9] Explanation: You are given the second node with value 5, the linked list should become 4 -\u0026gt; 1 -\u0026gt; 9 after calling your function. Before deletion graph LR A((4)) --\u003e B((5)) B --\u003e C((1)) C --\u003e D((9)) After deletion graph LR A((4)) --\u003e C((1)) C --\u003e D((9)) Example 2 Input: head = [4,5,1,9], node = 1 Output: [4,5,9] Explanation: You are given the third node with value 1, the linked list should become 4 -\u0026gt; 5 -\u0026gt; 9 after calling your function. Before deletion graph LR A((4)) --\u003e B((5)) B --\u003e C((1)) C --\u003e D((9)) After deletion graph LR A((4)) --\u003e B((5)) B --\u003e D((9)) Constraints The number of the nodes in the given list is in the range [2, 1000]. -1000 \u0026lt;= Node.val \u0026lt;= 1000 The value of each node in the list is unique. The node to be deleted is in the list and is not a tail node. Solution /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */ class Solution { public: void deleteNode(ListNode* node) { ListNode* toDel = node-\u0026gt;next; node-\u0026gt;val = toDel-\u0026gt;val; node-\u0026gt;next = toDel-\u0026gt;next; delete toDel; } }; Complexity Analysis Time complexity : O(1) Space complexity : O(1) Explanation 1. Intuition We are given the node to be deleted and we can\u0026rsquo;t access the head of the linked list. We can\u0026rsquo;t delete the node directly as we don\u0026rsquo;t have access to the previous node. The idea is to copy the value of the next node to the current node and then delete the next node. 2. Code explained We store the next node in a temporary pointer toDel. We copy the value of the next node to the current node. We update the next pointer of the current node to the next of the next node. We delete the next node. This is a demonstration of Linked List manipulation.\n","permalink":"https://KTS-o7.github.io/blog/posts/prev_solns/problem-delete-node-in-a-linked-list/","tags":["linked-list","pointers","cpp"],"title":"Problem 237 Delete Node in a Linked List"},{"categories":null,"content":"Problem Statement Link - Problem 881 Question You are given an array people where people[i] is the weight of the ith person, and an infinite number of boats where each boat can carry a maximum weight of limit. Each boat carries at most two people at the same time, provided the sum of the weight of those people is at most limit.\nReturn the minimum number of boats to carry every given person.\nExample 1 Input: people = [1,2], limit = 3 Output: 1 Explanation: 1 boat (1, 2) Example 2 Input: people = [3,2,2,1], limit = 3 Output: 3 Explanation: 3 boats (1, 2), (2) and (3) Example 3 Input: people = [3,5,3,4], limit = 5 Output: 4 Explanation: 4 boats (3), (3), (4), (5) Constraints 1 \u0026lt;= people.length \u0026lt;= 5 * 10^4 1 \u0026lt;= people[i] \u0026lt;= limit \u0026lt;= 3 * 10^4 Solution class Solution { public: int numRescueBoats(vector\u0026lt;int\u0026gt;\u0026amp; people, int limit) { std::ios_base::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); sort(people.begin(),people.end()); int left = 0,right = people.size()-1; int answer = 0; while(left\u0026lt;=right) { if(people[left]+people[right]\u0026gt;limit) { answer++; right--; } else { answer++; left++; right--; } } return answer; } }; Complexity Analysis Time : O(nlogn) Space : O(1) Explanation 1. Intuition We can see that the number of boats needed at minimum is n/2 where n is the number of people. Maximum number of boats needed is n where each person is in a separate boat. The idea is to give the heaviest person a boat and then check if the lightest person can be accomodated in the same boat. If the lightest person can be accomodated then we can move to the next lightest person. If the lightest person cannot be accomodated then we need to give the heaviest person a separate boat. 2. Code explained Sort the given vector. Initialize two pointers left and right at the start and end of the vector. Initialize the answer variable to 0. Iterate over the vector until left is less than or equal to right. If the sum of the weights of the people at left and right is greater than the limit then we need to give the person at right a separate boat. If the sum of the weights of the people at left and right is less than or equal to the limit then we can accomodate both the people in the same boat. Increment the answer variable accordingly. Return the answer variable. Note : This is a very simple problem and can be solved using the two pointer approach. The idea is to sort the given vector and then use two pointers to iterate over the vector. The time complexity of this approach is O(nlogn) where n is the number of people. The space complexity is O(1).\n","permalink":"https://KTS-o7.github.io/blog/posts/prev_solns/problem-boats-to-save-people/","tags":["two-pointers","greedy","cpp"],"title":"Problem 881 Boats to Save People"},{"categories":null,"content":"Problem Statement Link - Problem 2000 Question Given a 0-indexed string word and a character ch, reverse the segment of word that starts at index 0 and ends at the index of the first occurrence of ch (inclusive). If the character ch does not exist in word, do nothing.\nFor example, if word = \u0026quot;abcdefd\u0026quot; and ch = \u0026quot;d\u0026quot;, then you should reverse the segment that starts at 0 and ends at 3 (inclusive). The resulting string will be \u0026quot;dcbaefd\u0026quot;.\nReturn the resulting string.\nExample 1 Input: word = \u0026#34;abcdefd\u0026#34;, ch = \u0026#34;d\u0026#34; Output: \u0026#34;dcbaefd\u0026#34; Explanation: The first occurrence of \u0026#34;d\u0026#34; is at index 3. Reverse the part of word from 0 to 3 (inclusive), the resulting string is \u0026#34;dcbaefd\u0026#34;. Example 2 Input: word = \u0026#34;xyxzxe\u0026#34;, ch = \u0026#34;z\u0026#34; Output: \u0026#34;zxyxxe\u0026#34; Explanation: The first and only occurrence of \u0026#34;z\u0026#34; is at index 3. Reverse the part of word from 0 to 3 (inclusive), the resulting string is \u0026#34;zxyxxe\u0026#34;. Example 3 Input: word = \u0026#34;abcd\u0026#34;, ch = \u0026#34;z\u0026#34; Output: \u0026#34;abcd\u0026#34; Explanation: \u0026#34;z\u0026#34; does not exist in word. You should not do any reverse operation, the resulting string is \u0026#34;abcd\u0026#34;. Constraints 1 \u0026lt;= word.length \u0026lt;= 250 word consists of lowercase English letters. ch is a lowercase English letter. Solution class Solution { public: string reversePrefix(string word, char ch) { std::ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); int prefixIndex = INT_MIN; for(int i = 0;i\u0026lt;word.size();i++) { if(word[i]==ch) { prefixIndex = i; break; } } if(prefixIndex == INT_MIN)\\ return word; string ans = \u0026#34;\u0026#34;; for(int i = prefixIndex;i\u0026gt;=0;i--) ans += word[i]; for(int i = prefixIndex+1;i\u0026lt;word.size();i++) ans += word[i]; return ans; } }; Complexity Analysis Time - O(N) Space - O(N) Explanation Iterate through the string and check if the character ch exists in word. If not return the word as it is. If it exisits swap construct a new string ans in the following fashion. Append characters from prefixIndex to 0, then append characters from prefixIndex +1 to word.size(). Return the ans string. Note A solution using STL functions is as follows class Solution { public: string reversePrefix(string word, char ch) { int j = word.find(ch); if (j != -1) { reverse(word.begin(), word.begin() + j + 1); } return word; } }; Showcases the string manipulation.\n","permalink":"https://KTS-o7.github.io/blog/posts/prev_solns/problem-reverse-prefix-of-word/","tags":["cpp","string"],"title":"Problem 2000 Reverse Prefix of Word"},{"categories":null,"content":"Problem Statement Link: Problem 1289 Question Given an n x n integer matrix grid, return the minimum sum of a falling path with non-zero shifts.\nA falling path with non-zero shifts is a choice of exactly one element from each row of grid such that no two elements chosen in adjacent rows are in the same column.\nExample 1 1 2 3 4 5 6 7 8 9 Input: grid = [[1,2,3],[4,5,6],[7,8,9]] Output: 13 Explanation: The possible falling paths are: [1,5,9], [1,5,7], [1,6,7], [1,6,8], [2,4,8], [2,4,9], [2,6,7], [2,6,8], [3,4,8], [3,4,9], [3,5,7], [3,5,9] The falling path with the smallest sum is [1,5,7], so the answer is 13. Example 2 7 Input: grid = [[7]] Output: 7 Constraints n == grid.length == grid[i].length 1 \u0026lt;= n \u0026lt;= 200 -99 \u0026lt;= grid[i][j] \u0026lt;= 99 Solution class Solution { public: int minFallingPathSum(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; grid) { std::ios::sync_with_stdio(false); vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;dp(grid.size(),vector\u0026lt;int\u0026gt;(grid[0].size(),-1)); int rows = grid.size(), cols = grid[0].size(); int result = INT_MAX,temp; for(int j =0;j\u0026lt;cols;j++) dp[0][j] = grid[0][j]; for(int i = 1;i\u0026lt;rows;i++) { for(int j = 0;j\u0026lt;cols;j++) { temp = INT_MAX; for(int k = 0;k\u0026lt;cols;k++) { if(k!=j) { temp = min(temp, grid[i][j]+dp[i-1][k]); } } dp[i][j] = temp; } } for(int j = 0;j\u0026lt;cols;j++) result = min(result,dp[rows-1][j]); return result; } }; Complexity Time : O(Rows * Cols^2) Space : O(Rows * Cols) Explaination We will use a 2D dp array to store the minimum sum of the falling path ending at the cell dp[i][j]. The minimum falling path sum of first row will be same as first row of grid, hence we initialize dp[0][j] = grid[0][j]. For each cell dp[i][j] we will iterate over the previous row and find the minimum sum of the falling path ending at the cell dp[i][j]. We will find the minimmum sum of falling path which is not from the same column, hence we use if (k != j) condition. The answer will be the minimum value stored at the final row of dp matrix. This shows the usage of iterative DP to solve a grid problem.\nWe can also use Dijkstras Algorithm to solve the same problem.\n","permalink":"https://KTS-o7.github.io/blog/posts/prev_solns/problem-minimum-falling-path-sum-ii/","tags":["dp","matrix"],"title":"Problem 1289 Minimum Falling Path Sum II"},{"categories":null,"content":"Problem Statement Link - Problem 1137 Question The Tribonacci sequence T(n) is defined as follows:\nT(0) = 0, T(1) = 1, T(2) = 1, and T(n+3) = T(n) + T(n+1) + T(n+2) for n \u0026gt;= 0.\nGiven n, return the value of T(n).\nNote to self This is a straight forward Recursion Problem. We can convert this to DP by using memoization. We will use an array to store the intermediate values to prevent repeated calculations. Example 1 Input: n = 4 Output: 4 Explanation: T_3 = 0 + 1 + 1 = 2 T_4 = 1 + 1 + 2 = 4 Example 2 Input: n = 25 Output: 1389537 Constraints 0 \u0026lt;= n \u0026lt;= 37 The answer is guaranteed to fit within a 32-bit integer, ie. answer \u0026lt;= 2^31 - 1. Solution class Solution { public: int tribonacci(int n) { if(!n) return 0; if(n==1) return 1; if(n==2) return 1; vector\u0026lt;int\u0026gt;dp(n+1); dp[0]= 0; dp[1] = 1; dp[2] = 1; for(int i=3;i\u0026lt;=n;i++) dp[i]= dp[i-1]+dp[i-2]+dp[i-3]; return dp[n]; } }; Complexity Time: O(n) Space: O(n) Explaination We will use the DP array to store the intermediate values. We will store 0,1,1 as first 3 values. Then inside a loop from 3 to n, we will calculate the value of T(n) using the formula T(n) = T(n-1) + T(n-2) + T(n-3). We will return the value of T(n) at the end. DP without using array It is still memoization class Solution { public: int tribonacci(int n) { if(!n) return 0; if(n==1) return 1; if(n==2) return 1; int a=0,b=1,c=1; for(int i=3;i\u0026lt;=n;i++) { int temp = a+b+c; a=b; b=c; c=temp; } return c; } }; Time: O(n)\nSpace: O(1)\nWe can also solve this using recursion but it will be slow as it will have a time complexity of O(3^n).\nWe can also solve this using matrix exponentiation but it will be an overkill for this problem.\nThis is a demonstration of memoization technique used in DP. With this we can convert a recursive method into dynamic programming method.\n","permalink":"https://KTS-o7.github.io/blog/posts/prev_solns/problem-nth-tribonacci-number/","tags":["cpp","math","dp"],"title":"Problem 1137 Nth Tribonacci Number"},{"categories":null,"content":"Problem Statement Link - Problem 752 Question You have a lock in front of you with 4 circular wheels. Each wheel has 10 slots: '0', '1', '2', '3', '4', '5', '6', '7', '8', '9'. The wheels can rotate freely and wrap around: for example we can turn '9' to be '0', or '0' to be '9'. Each move consists of turning one wheel one slot.\nThe lock initially starts at '0000', a string representing the state of the 4 wheels.\nYou are given a list of deadends dead ends, meaning if the lock displays any of these codes, the wheels of the lock will stop turning and you will be unable to open it.\nGiven a target representing the value of the wheels that will unlock the lock, return the minimum total number of turns required to open the lock, or -1 if it is impossible.\nNote What they want us to find is the shortest path from the start node to the target node. The start node is '0000' and the target node is the target string. There will be an edge between two nodes if they differ by one digit. There are no outgoing edges from the deadend nodes. We can reach the target by changing the digits of the start node one by one, We can change them in either direction. The logic what we will be using is of BFS. BFS will always give us the shortest path. Note that the starting node also maybe a deadend. Example 1 Input: deadends = [\u0026#34;0201\u0026#34;,\u0026#34;0101\u0026#34;,\u0026#34;0102\u0026#34;,\u0026#34;1212\u0026#34;,\u0026#34;2002\u0026#34;], target = \u0026#34;0202\u0026#34; Output: 6 Explanation: A sequence of valid moves would be \u0026#34;0000\u0026#34; -\u0026gt; \u0026#34;1000\u0026#34; -\u0026gt; \u0026#34;1100\u0026#34; -\u0026gt; \u0026#34;1200\u0026#34; -\u0026gt; \u0026#34;1201\u0026#34; -\u0026gt; \u0026#34;1202\u0026#34; -\u0026gt; \u0026#34;0202\u0026#34;. Note that a sequence like \u0026#34;0000\u0026#34; -\u0026gt; \u0026#34;0001\u0026#34; -\u0026gt; \u0026#34;0002\u0026#34; -\u0026gt; \u0026#34;0102\u0026#34; -\u0026gt; \u0026#34;0202\u0026#34; would be invalid, because the wheels of the lock become stuck after the display becomes the dead end \u0026#34;0102\u0026#34;. Example 2 Input: deadends = [\u0026#34;8888\u0026#34;], target = \u0026#34;0009\u0026#34; Output: 1 Explanation: We can turn the last wheel in reverse to move from \u0026#34;0000\u0026#34; -\u0026gt; \u0026#34;0009\u0026#34;. Example 3 Input: deadends = [\u0026#34;8887\u0026#34;,\u0026#34;8889\u0026#34;,\u0026#34;8878\u0026#34;,\u0026#34;8898\u0026#34;,\u0026#34;8788\u0026#34;,\u0026#34;8988\u0026#34;,\u0026#34;7888\u0026#34;,\u0026#34;9888\u0026#34;], target = \u0026#34;8888\u0026#34; Output: -1 Explanation: We cannot reach the target without getting stuck. Constraints 1 \u0026lt;= deadends.length \u0026lt;= 500 deadends[i].length == 4 target.length == 4 target will not be in the list deadends. target and deadends[i] consist of digits only. Solution class Solution { public: int openLock(vector\u0026lt;string\u0026gt;\u0026amp; deadends, string target) { std::ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); unordered_set\u0026lt;string\u0026gt; dead(deadends.begin(),deadends.end()); if(dead.find(\u0026#34;0000\u0026#34;) != dead.end()) return -1; if(target == \u0026#34;0000\u0026#34;) return 0; int steps = 0; queue\u0026lt;string\u0026gt; q; q.push(\u0026#34;0000\u0026#34;); char actual; while(!q.empty()) { steps++; for(int size = q.size();size\u0026gt;0;size--) { string passwd = q.front(); q.pop(); for(int i= 0;i\u0026lt;4;i++) { actual = passwd[i]; passwd[i] = (passwd[i]==\u0026#39;9\u0026#39;)?\u0026#39;0\u0026#39;:passwd[i]+1; if(passwd == target) return steps; if(dead.find(passwd) == dead.end()) { q.push(passwd); dead.insert(passwd); } passwd[i] = actual; passwd[i] = (passwd[i]==\u0026#39;0\u0026#39;)?\u0026#39;9\u0026#39;:passwd[i]-1; if(passwd == target) return steps; if(dead.find(passwd) == dead.end()) { q.push(passwd); dead.insert(passwd); } passwd[i] = actual; } } } return -1; } }; Complexity Analysis Time complexity - O(10000) = O(1) - As we are iterating over all the possible combinations of the lock. Space complexity - O(10000) = O(1) - As we are storing all the possible combinations of the lock in the queue. Explanation First we create a unordered_set of deadends which will help us to check if the current combination is a deadend or not. We add all the deadends to the set. This makes sure that immidiate children of the deadends are not added to the queue. We check if the target is already a deadend or not. We check if the target is the start node itself. We create a queue and push the start node to it. We will keep track on number steps needed to reach the target. We will iterate over the current queue size. This is because we need to check only the current level nodes. We will iterate over the current node and change the digits one by one. If the child node is the target we return the number of steps. If child node is not target and is not a deadend or not visited till now, we will add it to the queue and mark it as visited. We will do the same for the other direction of the digit. If we are not able to reach the target we return -1. Note - This is a very good problem to understand the concept of BFS. We can also solve this problem using DFS but BFS is more efficient in this case.\n","permalink":"https://KTS-o7.github.io/blog/posts/prev_solns/problem-open-the-lock/","tags":["cpp","bfs","graph"],"title":"Problem 752 Open the Lock"},{"categories":null,"content":"Problem Statement Link - Problem 1971 Question There is a bi-directional graph with n vertices, where each vertex is labeled from 0 to n-1 (inclusive). The edges in the graph are represented as a 2D integer array edges, where each edges[i] = [ui, vi] denotes a bi-directional edge between vertex ui and vertex vi. Every vertex pair is connected by at most one edge, and no vertex has an edge to itself.\nYou want to determine if there is a valid path that exists from vertex source to vertex destination.\nGiven edges and the integers n, source, and destination, return true if there is a valid path from source to destination, or false otherwise.\nExample 1 graph LR A((0))\u003c--\u003eB((1)) B((1))\u003c--\u003eC((2)) C((2))\u003c--\u003eA((0)) Input: n = 3, edges = [[0,1],[1,2],[2,0]], source = 0, destination = 2 Output: true Explanation: There are two paths from vertex 0 to vertex 2: - 0 → 1 → 2 - 0 → 2 Example 2 graph TD A((0))\u003c--\u003eB((1)) C((2))\u003c--\u003eA((0)) D((3))\u003c--\u003eE((4)) E((4))\u003c--\u003eF((5)) F((5))\u003c--\u003eD((3)) Input: n = 6, edges = [[0,1],[0,2],[3,5],[5,4],[4,3]], source = 0, destination = 5 Output: false Explanation: There is no path from vertex 0 to vertex 5. Edge Case graph TD A((0)) Input: n = 1, edges = [], source = 0, destination = 0 Output = true Explanation: We are already in destination node. Constraints 1 \u0026lt;= n \u0026lt;= 2 * 10^5 0 \u0026lt;= edges.length \u0026lt;= 2 * 10^5 edges[i].length == 2 0 \u0026lt;= ui, vi \u0026lt;= n - 1 ui != vi 0 \u0026lt;= source, destination \u0026lt;= n - 1 There are no duplicate edges. There are no self edges Solution class Solution { public: bool dfs(unordered_map\u0026lt;int,vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; graph, int curr, int dest, unordered_set\u0026lt;int\u0026gt;\u0026amp; visited) { if(curr == dest) return true; visited.insert(curr); for(int next:graph[curr]) { if(visited.find(next) == visited.end()) if( dfs(graph,next,dest,visited)) return true; } return false; } bool validPath(int n, vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; edges, int source, int destination) { unordered_map\u0026lt;int, vector\u0026lt;int\u0026gt;\u0026gt; graph; for (const auto\u0026amp; edge : edges) { graph[edge[0]].push_back(edge[1]); graph[edge[1]].push_back(edge[0]); } unordered_set\u0026lt;int\u0026gt; visited; return dfs(graph, source, destination, visited); } }; Complexity Time : O(V + E), DFS visits each node and checks each edge atleast once. Space : O(V + E), the map stores each vertex V and corresponding edges E. Explanation We are given a vector of vector of int which denote the edges of a graph, the source vertex and destination vertex. Graph is bidirectional and there are no Self-Edges (From given). First we create an adjacency list graph which stores the vertex and the edges which is connected to them. We keep track of visited nodes in an unordered set visited. The DFS function then first checks if the current node is destination. If yes then we return true. Else we will append it to visited set, then try to find if any path exists from the connected nodes of current node. We will explore all the unvisited conntected nodes. If no path is found we return false. This shows the dfs method of graph traversal when a graph is represented in adjacency list format.\n","permalink":"https://KTS-o7.github.io/blog/posts/prev_solns/problem-find-if-path-exists-in-graph/","tags":["cpp","graph","dfs"],"title":"Problem 1971 Find if Path Exists in Graph"},{"categories":null,"content":"Problem Statement Link - Problem 1992 Question You are given a 0-indexed m x n binary matrix land where a 0 represents a hectare of forested land and a 1 represents a hectare of farmland.\nTo keep the land organized, there are designated rectangular areas of hectares that consist entirely of farmland. These rectangular areas are called groups. No two groups are adjacent, meaning farmland in one group is not four-directionally adjacent to another farmland in a different group.\nland can be represented by a coordinate system where the top left corner of land is (0, 0) and the bottom right corner of land is (m-1, n-1). Find the coordinates of the top left and bottom right corner of each group of farmland. A group of farmland with a top left corner at (r1, c1) and a bottom right corner at (r2, c2) is represented by the 4-length array [r1, c1, r2, c2].\nReturn a 2D array containing the 4-length arrays described above for each group of farmland in land. If there are no groups of farmland, return an empty array. You may return the answer in any order.\nExample 1 Input: land = [[1,0,0],[0,1,1],[0,1,1]] Output: [[0,0,0,0],[1,1,2,2]] Explanation: The first group has a top left corner at land[0][0] and a bottom right corner at land[0][0]. The second group has a top left corner at land[1][1] and a bottom right corner at land[2][2]. Example 2 Input: land = [[1,1],[1,1]] Output: [[0,0,1,1]] Explanation: The first group has a top left corner at land[0][0] and a bottom right corner at land[1][1]. Example 3 Input: land = [[0]] Output: [] Explanation: There are no groups of farmland. Constraints m == land.length n == land[i].length 1 \u0026lt;= m, n \u0026lt;= 300 land consists of only 0's and 1's. Groups of farmland are rectangular in shape. Solution class Solution { public: void dfs(int i, int j, int\u0026amp; r1, int\u0026amp; c1, int\u0026amp; r2, int\u0026amp; c2,vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; land){ if(i \u0026lt; 0 || j \u0026lt; 0 || i \u0026gt;= land.size() || j \u0026gt;= land[0].size() || land[i][j] != 1) return; land[i][j] = 0; r1=min(r1, i), c1=min(c1, j), r2=max(r2, i), c2=max(c2, j); dfs(i+1,j, r1, c1, r2, c2, land); dfs(i,j+1, r1, c1, r2, c2, land); // No need to check top and left because it is given that it is always a rectangle. //dfs(i-1,j, r1, c1, r2, c2, land); //dfs(i,j-1, r1, c1, r2, c2, land); } vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; findFarmland(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; land) { std::ios::sync_with_stdio(false); int n=land.size(); int m=land[0].size(); int r1,r2,c1,c2; vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; answer; for(int i=0; i\u0026lt;n; i++) for(int j=0; j\u0026lt;m; j++){ if(land[i][j]==1){ r1=i, c1=j, r2=i, c2=j; dfs(i, j, r1, c1, r2, c2, land); answer.push_back({r1, c1, r2, c2}); } } return answer; } }; Complexity Time complexity : O(n*m) Space complexity : O(n*m) Explaination We will use the DFS technique to find the farmland. This is very similar to the number of islands problem. Check it Out . We will iterate over the matrix given only if the current cell is 1. In the dfs function, we will check if the current cell is in bounds and is 1. If it is, we will mark it as 0 and update the r1, c1, r2, c2 values. The r1, c1 will be the minimum values of the current cell and the r2, c2 will be the maximum values of the current cell. r1, c1 will be the top left corner and r2, c2 will be the bottom right corner of the farmland. We will call the dfs function recursively on the right and bottom cells. We need not to check the top and left cells because it is given that the farmland is always a rectangle. Once the dfs function is ended, we will push the r1, c1, r2, c2 values to the answer array. This demonstrates the use of DFS to traverse a 2D matrix and find the components or groups.\n","permalink":"https://KTS-o7.github.io/blog/posts/prev_solns/problem-find-all-groups-of-farmland/","tags":["cpp","matrix","dfs"],"title":"Problem 1992 Find All Groups of Farmland"},{"categories":null,"content":"Problem Statement Link - Problem 200 Question Given an m x n 2D binary grid grid which represents a map of '1's (land) and '0's (water), return the number of islands.\nAn island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.\nNote to self They use characters not integers for 1 and 0. This is a classic dfs problem. Example 1 Input:\ngrid = [ [\u0026#34;1\u0026#34;,\u0026#34;1\u0026#34;,\u0026#34;1\u0026#34;,\u0026#34;1\u0026#34;,\u0026#34;0\u0026#34;], [\u0026#34;1\u0026#34;,\u0026#34;1\u0026#34;,\u0026#34;0\u0026#34;,\u0026#34;1\u0026#34;,\u0026#34;0\u0026#34;], [\u0026#34;1\u0026#34;,\u0026#34;1\u0026#34;,\u0026#34;0\u0026#34;,\u0026#34;0\u0026#34;,\u0026#34;0\u0026#34;], [\u0026#34;0\u0026#34;,\u0026#34;0\u0026#34;,\u0026#34;0\u0026#34;,\u0026#34;0\u0026#34;,\u0026#34;0\u0026#34;] ] Output:\n1 Example 2 Input:\ngrid = [ [\u0026#34;1\u0026#34;,\u0026#34;1\u0026#34;,\u0026#34;0\u0026#34;,\u0026#34;0\u0026#34;,\u0026#34;0\u0026#34;], [\u0026#34;1\u0026#34;,\u0026#34;1\u0026#34;,\u0026#34;0\u0026#34;,\u0026#34;0\u0026#34;,\u0026#34;0\u0026#34;], [\u0026#34;0\u0026#34;,\u0026#34;0\u0026#34;,\u0026#34;1\u0026#34;,\u0026#34;0\u0026#34;,\u0026#34;0\u0026#34;], [\u0026#34;0\u0026#34;,\u0026#34;0\u0026#34;,\u0026#34;0\u0026#34;,\u0026#34;1\u0026#34;,\u0026#34;1\u0026#34;] ] Output:\n3 Constraints m == grid.length n == grid[i].length 1 \u0026lt;= m, n \u0026lt;= 300 grid[i][j] is '0' or '1'. Solution class Solution { public: void checkIsland(int row,int col,vector\u0026lt;vector\u0026lt;char\u0026gt;\u0026gt;\u0026amp; grid) { if(row \u0026lt; 0 || col \u0026lt; 0 || row \u0026gt;= grid.size() || col \u0026gt;= grid[0].size() || grid[row][col] != \u0026#39;1\u0026#39;) return; grid[row][col] = \u0026#39;0\u0026#39;; checkIsland(row - 1, col,grid); checkIsland(row + 1, col,grid); checkIsland(row, col - 1,grid); checkIsland(row, col + 1,grid); } int numIslands(vector\u0026lt;vector\u0026lt;char\u0026gt;\u0026gt;\u0026amp; grid) { std::ios::sync_with_stdio(false); if(grid.empty() || grid[0].empty()) return 0; int rows = grid.size(); int cols = grid[0].size(); int islands = 0; for(int row = 0; row \u0026lt; rows; row++) { for(int col = 0; col \u0026lt; cols; col++) { if(grid[row][col] == \u0026#39;1\u0026#39;) { checkIsland(row, col,grid); islands++; } } } return islands; } }; Complexity Time : O(m*n) Space : O(m*n) Explaination We use the classic dfs approach to solve this. The logic is to check if the current cell is in bounds, and is '1'. If it is then the cell is marked as visited and call the function recursively on all the 4 directions. This recursive call checks if its adjacent cells are '0' or '1'. If they all are Zeroes then the call will end and the count of islands Islands will be incremented. If the current cell has an unvisited land neighbour then we extend our search there. So whenever the checkIsland function is ended by the base case it means it has found a valid island. This demonstrates the use of DFS to traverse a 2D matrix and find the components or groups.\n","permalink":"https://KTS-o7.github.io/blog/posts/prev_solns/problem-number-of-islands/","tags":["cpp","matrix","dfs","array"],"title":"Problem 200 Number of Islands"},{"categories":null,"content":"Problem Statement Link - Problem 463 Question You are given row x col grid representing a map where grid[i][j] = 1 represents land and grid[i][j] = 0 represents water.\nGrid cells are connected horizontally/vertically (not diagonally). The grid is completely surrounded by water, and there is exactly one island (i.e., one or more connected land cells).\nThe island doesn\u0026rsquo;t have \u0026ldquo;lakes\u0026rdquo;, meaning the water inside isn\u0026rsquo;t connected to the water around the island. One cell is a square with side length 1. The grid is rectangular, width and height don\u0026rsquo;t exceed 100. Determine the perimeter of the island.\nExample 1 Input: grid = [[0,1,0,0],[1,1,1,0],[0,1,0,0],[1,1,0,0]] Output: 16 Example 2 Input: grid = [[1]] Output: 4 Example 3 Input: grid = [[1,0]] Output: 4 Constraints row == grid.length col == grid[i].length 1 \u0026lt;= row, col \u0026lt;= 100 grid[i][j] is 0 or 1. There is exactly one island in grid. Solution class Solution { public: int islandPerimeter(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; grid) { int row = grid.size(), col = grid[0].size(); int peri = 0; for(int i=0;i\u0026lt;row;i++) { for(int j=0;j\u0026lt;col;j++) { if(grid[i][j]\u0026amp;1) { peri+=4; if(i\u0026gt;0 \u0026amp;\u0026amp; (grid[i-1][j] \u0026amp; 1)) peri-=2; if(j\u0026gt;0 \u0026amp;\u0026amp; (grid[i][j-1] \u0026amp; 1)) peri-=2; } } } return peri; } }; Complexity Time : O(N*M) Space : O(1) Explanation We iterate over the grid. If the cell is land then add 4 to the perimeter. Then we check the left and top of the cell. If they are land then we subtract 2 from the perimeter each. This is because when two lands are adjacent then they share a side and hence the perimeter is reduced by 2. Finally return the perimeter. This problem demonstrates the traversal of a matrix and checking the adjacent cells.\n","permalink":"https://KTS-o7.github.io/blog/posts/prev_solns/problem-island-perimeter/","tags":["cpp","matrix","array"],"title":"Problem 463 Island Perimeter"},{"categories":null,"content":"Problem Statement Link - Problem 988 Question You are given the root of a binary tree where each node has a value in the range [0, 25] representing the letters 'a' to 'z'.\nReturn the lexicographically smallest string that starts at a leaf of this tree and ends at the root.\nAs a reminder, any shorter prefix of a string is lexicographically smaller.\nFor example, \u0026quot;ab\u0026quot; is lexicographically smaller than \u0026quot;aba\u0026quot;. A leaf of a node is a node that has no children.\nExample 1 graph TD A[0] --\u003e B[1] A --\u003e C[2] B --\u003e D[3] B --\u003e E[4] C --\u003e F[3] C --\u003e G[4] Input: root = [0,1,2,3,4,3,4] Output: \u0026#34;dba\u0026#34; Example 2 graph TD A[25] --\u003e B[1] B --\u003e C[1] B --\u003e D[3] A --\u003e E[3] E --\u003e F[0] E --\u003e G[2] Input: root = [25,1,3,1,3,0,2] Output: \u0026#34;adz\u0026#34; Example 3 graph TD A[2] --\u003e B[2] A --\u003e C[1] B --\u003e D[1] C--\u003e E[0] D--\u003eF[0] Input: root = [2,2,1,null,1,0,null,0] Output: \u0026#34;abc\u0026#34; Important Edge Case graph TD A[0] --\u003e B[1] Input: root = [0,null,1] Output: \u0026#34;ba\u0026#34; Constraints The number of nodes in the tree is in the range [1, 8500]. 0 \u0026lt;= Node.val \u0026lt;= 25 Solution /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: void dfs(TreeNode* root, string str, string\u0026amp; smallest) { if(root == NULL) return; str+= char(\u0026#39;a\u0026#39;+root-\u0026gt;val); if(root-\u0026gt;left == NULL \u0026amp;\u0026amp; root-\u0026gt;right == NULL) { reverse(str.begin(),str.end()); if(smallest.empty() || str\u0026lt;smallest) smallest = str; reverse(str.begin(),str.end()); } dfs(root-\u0026gt;left,str,smallest); dfs(root-\u0026gt;right,str,smallest); } string smallestFromLeaf(TreeNode* root) { string small; dfs(root,\u0026#34;\u0026#34;,small); return small; } }; Complexity Time : O(N) Space : O(N) Explanation We perform a DFS traversal of the tree. First we start from the root of the tree and traverse down. We use a string called smallest to keep track of the smallest string from leafnode to rootnode found so far. Base Case for recursion - if root is NULL then just return. We append the character to the string str which is the character at the current node. String str actually stores the current path which is being developed from rootnode to leafnode. If we reach a leafnode then we reverse the str and check if its the lexographically smallest string which we saw so far. If yes then update the smallest. Then reverse str again so that we can continue exploring the path. Then we recursively explore the left subtree and right subtree looking for leaf nodes. This solution effectively demonstrates the usage of DFS to build a string from a tree following the given set of rules.\n","permalink":"https://KTS-o7.github.io/blog/posts/prev_solns/problem-smallest-string-starting-from-leaf/","tags":["binary tree","dfs"],"title":"Problem 988 Smallest String Starting From Leaf"},{"categories":null,"content":"Problem Statement Link - Problem 623 Question Given the root of a binary tree and two integers val and depth, add a row of nodes with value val at the given depth depth.\nNote that the root node is at depth 1.\nThe adding rule is:\nGiven the integer depth, for each not null tree node cur at the depth depth - 1, create two tree nodes with value val as cur's left subtree root and right subtree root. cur's original left subtree should be the left subtree of the new left subtree root. cur's original right subtree should be the right subtree of the new right subtree root. If depth == 1 that means there is no depth depth - 1 at all, then create a tree node with value val as the new root of the whole original tree, and the original tree is the new root\u0026rsquo;s left subtree. Example 1 Input: root = [4,2,6,3,1,5], val = 1, depth = 2 Output: [4,1,1,2,null,null,6,3,1,5] Example 2 Input: root = [4,2,null,3,1], val = 1, depth = 3 Output: [4,2,null,1,1,3,null,null,1] Constraints The number of nodes in the tree is in the range [1, 10^4]. The depth of the tree is in the range [1, 10^4]. -100 \u0026lt;= Node.val \u0026lt;= 100 -10^5 \u0026lt;= val \u0026lt;= 10^5 1 \u0026lt;= depth \u0026lt;= the depth of tree + 1 Solution /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(NULL), right(NULL) {} * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: void dfs(TreeNode* root,int val,int currDepth,int depth) { if(root == NULL) return; if(currDepth == depth-1) { root-\u0026gt;left = new TreeNode(val,root-\u0026gt;left,NULL); root-\u0026gt;right = new TreeNode(val,NULL,root-\u0026gt;right); return; } dfs(root-\u0026gt;left,val,currDepth+1,depth); dfs(root-\u0026gt;right,val,currDepth+1,depth); } TreeNode* addOneRow(TreeNode* root, int val, int depth) { if(depth == 1) { return new TreeNode(val,root,NULL); } dfs(root,val,1,depth); return root; } }; Complexity Time : O(N) Space : O(N) Explaination The provided code is a C++ solution for adding a new row of nodes with a given value to a binary tree at a specified depth. The solution uses a depth-first search (DFS) approach to traverse the tree and add the new nodes. Here\u0026rsquo;s a breakdown of the approach and logic:\nApproach Depth-First Search (DFS): The solution uses a DFS approach to traverse the binary tree. DFS is chosen because it allows us to explore each path from the root to a leaf node in a systematic manner, which is crucial for adding nodes at a specific depth.\nAdding Nodes at the Specified Depth: The dfs function is designed to add new nodes at the specified depth. It takes four parameters: the current node (root), the value to be added to the new nodes (val), the current depth (currDepth), and the target depth (depth).\nBase Case: The base case for the DFS is when the current depth equals the target depth minus one. At this point, the function creates new nodes with the given value and adds them as the left and right children of the current node. This effectively adds a new row of nodes at the specified depth.\nRecursive Calls: For each node, the function makes recursive calls to itself for the left and right children of the current node, incrementing the current depth by one. This allows the function to explore all nodes at the specified depth and add the new nodes.\nHandling the Root Node: If the target depth is 1, the addOneRow function creates a new root node with the given value and the original root as its right child. This effectively adds a new row of nodes at the root level.\nLogic DFS Traversal: The DFS traversal starts from the root and explores each path from the root to a leaf node. The traversal is controlled by the currDepth and depth parameters, ensuring that nodes are added only at the specified depth.\nAdding New Nodes: When the DFS reaches the specified depth, it adds new nodes with the given value as the left and right children of the current node. This is done by creating new TreeNode instances with the given value and the existing left and right children of the current node.\nReturning the Modified Tree: After adding the new nodes, the addOneRow function returns the modified tree. If the target depth is 1, it returns a new root node; otherwise, it returns the original root node.\nWhy This Approach Works ? Systematic Exploration: DFS ensures that we explore all nodes in the tree in a systematic manner, allowing us to add new nodes at the specified depth.\nDepth Control: By comparing currDepth with depth - 1, we can precisely control when to add new nodes, ensuring that they are added only at the specified depth.\nFlexibility: This approach can handle adding a new row of nodes at any depth within the tree, making it versatile for different scenarios.\nThis solution effectively demonstrates how to use DFS to modify a binary tree by adding a new row of nodes at a specified depth.\n","permalink":"https://KTS-o7.github.io/blog/posts/prev_solns/problem-add-one-row-to-tree/","tags":["cpp","binary-tree","dfs"],"title":"Problem 623 Add One Row to Tree"},{"categories":null,"content":"Problem Statement Link - Problem 129 Question You are given the root of a binary tree containing digits from 0 to 9 only.\nEach root-to-leaf path in the tree represents a number.\nFor example, the root-to-leaf path 1 -\u0026gt; 2 -\u0026gt; 3 represents the number 123. Return the total sum of all root-to-leaf numbers. Test cases are generated so that the answer will fit in a 32-bit integer.\nA leaf node is a node with no children.\nExample 1 Input: root = [1,2,3] Output: 25 Explanation: The root-to-leaf path 1-\u0026gt;2 represents the number 12. The root-to-leaf path 1-\u0026gt;3 represents the number 13. Therefore, sum = 12 + 13 = 25. Example 2 Input: root = [4,9,0,5,1] Output: 1026 Explanation: The root-to-leaf path 4-\u0026gt;9-\u0026gt;5 represents the number 495. The root-to-leaf path 4-\u0026gt;9-\u0026gt;1 represents the number 491. The root-to-leaf path 4-\u0026gt;0 represents the number 40. Therefore, sum = 495 + 491 + 40 = 1026. Constraints Constraints: The number of nodes in the tree is in the range [1, 1000]. 0 \u0026lt;= Node.val \u0026lt;= 9 The depth of the tree will not exceed 10. Solution /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: int dfs(TreeNode* root, int path) { if(root==nullptr) return 0; path = path*10 + root-\u0026gt;val; if(root-\u0026gt;left == nullptr \u0026amp;\u0026amp; root-\u0026gt;right == nullptr) return path; return dfs(root-\u0026gt;left,path)+dfs(root-\u0026gt;right,path); } int sumNumbers(TreeNode* root) { return dfs(root,0); } }; Complexity Time : O(N) Space : O(N) Explanation Depth-First Search (DFS): The solution uses a depth-first search (DFS) approach to traverse the binary tree. DFS is chosen because it allows us to explore each path from the root to a leaf node in a systematic manner. Path Representation: As we traverse the tree, we keep track of the current path from the root to the current node. This path is represented as an integer, where each digit in the path corresponds to the value of a node in the path. Appending Node Values: For each node we visit, we append its value to the current path. This is done by multiplying the current path by 10 (to shift the digits to the left) and adding the node\u0026rsquo;s value. This operation effectively appends the node\u0026rsquo;s value to the end of the path. Base Case: The base case for the DFS is when we reach a leaf node (a node with no children). At this point, the path represents a number, and we return this number. Recursive Calls: For each non-leaf node, we make recursive calls to the DFS function for its left and right children, passing along the updated path. This allows us to explore all possible paths from the root to the leaves. Summing Numbers: The sum of all numbers represented by the paths from the root to the leaves is calculated by adding up the numbers returned by the recursive calls. Why this technique works ? Systematic Exploration: DFS ensures that we explore all possible paths from the root to the leaves in a systematic manner. This is crucial for calculating the sum of all numbers represented by these paths. Path Representation: By representing the path as an integer, we can easily append the value of each node to the path and calculate the number represented by the path. This representation is efficient and straightforward. Base Case Handling: The base case (reaching a leaf node) allows us to calculate the number represented by the path from the root to the leaf. This is the key step in solving the problem. Recursive Summing: By making recursive calls and summing the results, we ensure that the sum of all numbers represented by the paths from the root to the leaves is calculated correctly. This technique works because it systematically explores all paths from the root to the leaves of the binary tree, calculates the number represented by each path, and sums these numbers to find the total sum of all root-to-leaf numbers.\n","permalink":"https://KTS-o7.github.io/blog/posts/prev_solns/problem-sum-root-to-leaf-numbers/","tags":["cpp","binary-tree","dfs"],"title":"Problem 129 Sum Root to Leaf Numbers"},{"categories":null,"content":"Raspberry Pi Zero Headless WiFi Setup Using Linux The following instructions will ultimately enable your Pi Zero to connect the WiFi to the router during every boot up, for a headless management.\nAppendix Prerequisite Enabling USB ethernet gadget mode on Pi Things to do once connected to Pi via USB 3.1. Enabling Internet access in Raspberry Pi 3.2. SSH into Raspberry Pi 3.3. Change locale settings 3.4. Update the OS 3.5. WiFi configuration for auto connecting to the access point 1. Prerequisite a) Raspberry Pi Zero v1.3\nb) USB data cable\nc) Raspbian OS\nd) A charger\ne) Manjaro Linux ( mentioned as host OS in this article )\nf) Raspberry Pi Imager tool\ng) SD card\n2. Enabling USB ether net gadget mode on Pi To enable the gadget mode, edit config.txt and cmdline.txt files in thebootpartition of the SD card.\\\nAdd dtoverlay=dwc2 to config.txt and\nAdd modules-load=dwc2,g_ether after the rootwait in cmdline.txt\nNote: Leave a space before and after the add modules-load=dwc2,g_ether line.\nMake an empty ssh file inside the same partition to enable SSH on boot.\nNow connect the USB data cable to the USB port of the Pi and plug it in the PC\u0026rsquo;s\nUSB port.\nImportant ! In the newer version of Raspbian there is no default pi user. We have to create it ourselves. Following steps will instruct you how to create that default user.\nCreate an empty file called userconf in the boot partition. touch useconf Now copy paste the following into the file pi:$6$/4.VdYgDm7RJ0qM1$FwXCeQgDKkqrOU3RIRuDSKpauAbBvP11msq9X58c8Que2l1Dwq3vdJMgiZlQSbEXGaY5esVHGBNbCxKLVNqZW1 The above will create a default user named pi and password is raspberry. You can change it later on. Without this you wont be able to SSH into the raspberry pi zero.\n3. Things to do once connected to Pi via USB 3.1 Enabling Internet access in Raspberry Pi Before enabling the internet, make sure that the Pi is connected as a USB gadget. Check sudo dmesg to confirm it. Look for lines similar to\n[ 343.853507] usb 1-4: new full-speed USB device number 3 using xhci_hcd [ 345.088725] usb 1-4: new high-speed USB device number 4 using xhci_hcd [ 345.243731] usb 1-4: New USB device found, idVendor=0525, idProduct=a4a2, bcdDevice= 5.10 [ 345.243740] usb 1-4: New USB device strings: Mfr=1, Product=2, SerialNumber=0 [ 345.243743] usb 1-4: Product: RNDIS/Ethernet Gadget [ 345.243746] usb 1-4: Manufacturer: Linux 5.10.17+ with 20980000.usb [ 345.463183] cdc_subset: probe of 1-4:1.0 failed with error -22 [ 345.464195] cdc_subset 1-4:1.1 usb0: register \u0026#39;cdc_subset\u0026#39; at usb-0000:03:00.3-4, Linux Device, e2:38:73:2d:01:39 [ 345.464248] usbcore: registered new interface driver cdc_subset [ 345.464297] cdc_ether: probe of 1-4:1.0 failed with error -16 [ 345.464337] usbcore: registered new interface driver cdc_ether [ 345.743346] bpfilter: Loaded bpfilter_umh pid 4407 [ 345.743711] Started bpfilter Note:\nGive at least 30 seconds or more before trying the dmesg\nIf the last line says something like\n[ 887.699447] usb 1-4: USB disconnect, device number 4 [ 887.699969] cdc_subset 1-4:1.1 usb0: unregister \u0026#39;cdc_subset\u0026#39; usb-0000:03:00.3-4, Linux Device that means the USB gadget mode was enabled and for some reason it got disconnected.\nIf you get this, check whether the USB cable was connected to the USB port on the Pi, not on the power port.\nOnce confirmed that everything is working fine, goto gnome-network-manager gui and change the USB ethernet\u0026rsquo;s IPv4 setting to shared to other computers.\nDisconnect and then reconnect the USB ethernet in the gui. If that doesn\u0026rsquo;t allow you to ssh into the Pi, you might also need to dis/reconnect the PCI ethernet option.\nNow you should be able to SSH into the Internet ready Pi.\n3.2 SSH into Raspberry Pi ssh pi@IP_ADDRESS password: raspberry replace the IP_ADDRESS with the IP Address of the Raspberry Pi zero.\n3.3 Change locale settings To eliminate perl: LC errors during package installations; sudo dpkg-reconfigure locales select the appropriate locale. For example; en_US.UTF-8\nSet timezone sudo ln -sf /usr/share/timezone/Country/Region /etc/localtime Expand file system expand the file system by using\nsudo raspi-config Now its time to shutdown the Pi to take effect the changes.\nReboot seems to be breaking the USB ether net gadget mode for some reason. Hence you need to shutdown the system.\nNote :\nCheck dmesg again . If you see some messages similar to below, reboot the host linux OS. Only then re-connect the Pi.\n[ 1131.255131] ------------[ cut here ]------------ [ 1131.255137] NETDEV WATCHDOG: enx1a4d1a4fb05e (cdc_ether): transmit queue 0 timed out [ 1131.255158] WARNING: CPU: 6 PID: 0 at net/sched/sch_generic.c:467 dev_watchdog+0x24f/0x260 . . . [ 1131.255535] ---[ end trace 07a143fded20143c ]--- I got this message even after a reboot. In that case disconnect the Pi and check the SD card for any file system errors. Reboot the host OS again and reconnect the Pi.\nThen follow the instructions on 3.1 .\n3.4 Update the OS It\u0026rsquo;s better to setup the WiFi connection and then upgrade the OS. It can be done by referring to\nsudo apt update sudo apt upgrade Shutdown and unplug or re plug the Pi. Follow 3.1 .\nNow we need to setup the WiFi to automatically connect to the access point during the next reboot.\n3.5 WiFi configuration for auto connecting to the access point You can add the WiFi Configuration using raspi-config after SSH-ing via USB.\narp -a This will display the IP address of the USB Ethernet ( usually its of form 10.42.0.x ) SSH into the board. Use the following command to enter the Raspi configuration\nsudo raspi-config Then connect to WiFi via the Connection options by entering the SSID and Password of your network.\nOR\nAdd these lines to /etc/wpa_supplicant/wpa_supplicant.conf;\ncountry=\u0026#34;your country code\u0026#34; network={ scan_ssid=1 ssid=\u0026#34;wifi name\u0026#34; psk=\u0026#34;wifi password\u0026#34; } Now shutdown the Pi. Connect the WiFi adapter and power cable then turn it on.\n","permalink":"https://KTS-o7.github.io/blog/posts/raspberrypi/raspberrypi_zero_setup/","tags":["raspberrypi","setup"],"title":"RaspberryPi_Zero_Setup"},{"categories":null,"content":" Hello! I\u0026rsquo;m Krishnatejaswi S, a passionate Computer Science and Engineering student from Bangalore, India. My journey in the world of technology has been both challenging and rewarding, and I\u0026rsquo;m excited to share my experiences and projects with you.\nAcademic Background I\u0026rsquo;m currently pursuing my B.E degree in Computer Science and Engineering at RV College of Engineering, where I\u0026rsquo;ve had the opportunity to dive deep into various technologies and programming languages. My academic and research projects have allowed me to explore and master languages like Python and C++, and I\u0026rsquo;m always eager to learn and experiment with new technologies. Portfolio I\u0026rsquo;ve worked on a variety of projects that have helped me grow as a developer. Check out my portfolio to see some of my work. From web development to machine learning, I\u0026rsquo;ve tackled projects that challenge me and push my boundaries.\nPassion for Coding My passion for coding extends beyond the classroom. I\u0026rsquo;m particularly interested in exploring the cutting-edge technologies that are shaping the future of the tech industry. Some of the areas I\u0026rsquo;m currently exploring include:\nOpenCV: A facinating library to work with image processing in python. Ollama: A platform that\u0026rsquo;s revolutionizing the way we interact with AI. Generative AI: Creating content and models that can generate human-like text and images. JavaScript, Next.js: Building dynamic and responsive web applications. PyTorch: Diving into the world of machine learning and AI. Contact Me If you\u0026rsquo;re interested in my work, have questions, or would like to collaborate on a project, feel free to contact me . I\u0026rsquo;m always open to new connections and opportunities.\nThank you for visiting my About page. I look forward to sharing more of my journey with you!\nYou can also connect me via Linktree ","permalink":"https://KTS-o7.github.io/blog/about/about/","tags":null,"title":"About"},{"categories":null,"content":"","permalink":"https://KTS-o7.github.io/blog/search/_index.es/","tags":null,"title":""},{"categories":null,"content":"","permalink":"https://KTS-o7.github.io/blog/search/_index.fr/","tags":null,"title":""},{"categories":null,"content":"","permalink":"https://KTS-o7.github.io/blog/search/_index.hi/","tags":null,"title":""},{"categories":null,"content":"","permalink":"https://KTS-o7.github.io/blog/search/_index.jp/","tags":null,"title":""},{"categories":null,"content":"","permalink":"https://KTS-o7.github.io/blog/search/_index.pl/","tags":null,"title":""},{"categories":null,"content":"","permalink":"https://KTS-o7.github.io/blog/search/_index.ru/","tags":null,"title":""},{"categories":null,"content":"","permalink":"https://KTS-o7.github.io/blog/search/_index.zh-cn/","tags":null,"title":""}]