[{"categories":null,"content":"Problem Statement Link - Problem 1122 Question Given two arrays arr1 and arr2, the elements of arr2 are distinct, and all elements in arr2 are also in arr1.\nSort the elements of arr1 such that the relative ordering of items in arr1 are the same as in arr2. Elements that do not appear in arr2 should be placed at the end of arr1 in ascending order.\nExample 1 Input: arr1 = [2,3,1,3,2,4,6,7,9,2,19], arr2 = [2,1,4,3,9,6] Output: [2,2,2,1,4,3,3,9,6,7,19] Example 2 Input: arr1 = [28,6,22,8,44,17], arr2 = [22,28,8,6] Output: [22,28,8,6,17,44] Constraints 1 \u0026lt;= arr1.length, arr2.length \u0026lt;= 1000 0 \u0026lt;= arr1[i], arr2[i] \u0026lt;= 1000 All the elements of arr2 are distinct. Each arr2[i] is in arr1. Solution class Solution { public: vector\u0026lt;int\u0026gt; relativeSortArray(vector\u0026lt;int\u0026gt;\u0026amp; arr1, vector\u0026lt;int\u0026gt;\u0026amp; arr2) { vector\u0026lt;int\u0026gt;freqCount(1001,0); for(int i = 0;i\u0026lt;arr1.size();i++) { freqCount[arr1[i]]++; } int ansptr=0; for(int i=0; i\u0026lt;arr2.size();i++) { while(freqCount[arr2[i]]) { arr1[ansptr] = arr2[i]; ansptr++; freqCount[arr2[i]]--; } } for(int i = 0;i\u0026lt;freqCount.size();i++) { while(freqCount[i]) { arr1[ansptr] = i; ansptr++; freqCount[i]--; } } return arr1; } }; Complexity Analysis Time Complexity : O(N) Space Complexity : O(N) Explanation 1. Intuition - We need to know the count of elements in `arr1` - Hence we use `freqCount` vector to store frequency counts. - `arr2` will give us the order of insertion. 2. Implementation - First create a `freqCount` vector of size 1001 and initialize it with 0. - Traverse through `arr1` and increment the frequency count of each element. - Traverse through `arr2` and insert the elements in `arr1` in the order of `arr2`. - Traverse through `freqCount` and insert the remaining elements in `arr1`. - Now the array is sorted according to `arr2`. - Return `arr1`. Note Hashmap implementation class Solution{ public: vector\u0026lt;int\u0026gt; relativeSortArray(vector\u0026lt;int\u0026gt;\u0026amp; arr1, vector\u0026lt;int\u0026gt;\u0026amp; arr2) { map\u0026lt;int,int\u0026gt;freqCount; for(int i = 0;i\u0026lt;arr1.size();i++) { freqCount[arr1[i]]++; } int ansptr=0; for(int i=0; i\u0026lt;arr2.size();i++) { while(freqCount[arr2[i]]) { arr1[ansptr] = arr2[i]; ansptr++; freqCount[arr2[i]]--; } } for(auto i:freqCount) { while(i.second) { arr1[ansptr] = i.first; ansptr++; i.second--; } } return arr1; } }; ","permalink":"https://KTS-o7.github.io/blog/posts/problem-relative-sort-array/","tags":["vector","counting-sort","sorting","count-sort","hash-map"],"title":"Problem Relative Sort Array"},{"categories":null,"content":"Problem Statement Link - Problem 136 Question Given a non-empty array of integers nums, every element appears twice except for one. Find that single one.\nYou must implement a solution with a linear runtime complexity and use only constant extra space.\nNote We need O(1) space and O(n) time complexity. That means we cant use any other space to store frequency of elements and cant sort the array and check for the element which is not repeated. This hints that we need to manipulate the given array and find the single number. Example 1 Input: nums = [2,2,1] Output: 1 Example 2 Input: nums = [4,1,2,1,2] Output: 4 Example 3 Input: nums = [1] Output: 1 Constraints 1 \u0026lt;= nums.length \u0026lt;= 3 * 10^4 -3 * 10^4 \u0026lt;= nums[i] \u0026lt;= 3 * 10^4 Each element in the array appears twice except for one element which appears only once. Solution class Solution { public: int singleNumber(vector\u0026lt;int\u0026gt;\u0026amp; nums) { std::ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); int ans = nums[0]; for(int i= 1; i\u0026lt;nums.size(); i++) ans = ans^nums[i]; return ans; } }; Complexity Analysis Time Complexity : O(N) Space Complexity : O(1) Explanation 1. Intuition - We know that a number XOR with itself is 0. - So, if we XOR all the elements in the array, the elements which are repeated will cancel each other. - We will be left with the single number. 2. Implementation - Initialize a variable `ans` with the first element of the array. - Iterate over the array from the second element. - XOR the `ans` with the current element. - Return the `ans`. This solution shows the power of XOR operation. XOR operation is commutative and associative. So, we can use it to find the single number in the array.\n","permalink":"https://KTS-o7.github.io/blog/posts/problem-single-number/","tags":["bit-manipulation","vectors","bitwise-xor"],"title":"Problem Single Number"},{"categories":null,"content":"Problem Statement Link - Problem 1051 Question A school is trying to take an annual photo of all the students. The students are asked to stand in a single file line in non-decreasing order by height. Let this ordering be represented by the integer array expected where expected[i] is the expected height of the ith student in line.\nYou are given an integer array heights representing the current order that the students are standing in. Each heights[i] is the height of the ith student in line (0-indexed).\nReturn the number of indices where heights[i] != expected[i].\nExample 1 Input: heights = [1,1,4,2,1,3] Output: 3 Explanation: heights: [1,1,4,2,1,3] expected: [1,1,1,2,3,4] Indices 2, 4, and 5 do not match. Example 2 Input: heights = [5,1,2,3,4] Output: 5 Explanation: heights: [5,1,2,3,4] expected: [1,2,3,4,5] All indices do not match. Example 3 Input: heights = [1,2,3,4,5] Output: 0 Explanation: heights: [1,2,3,4,5] expected: [1,2,3,4,5] All indices match. Constraints 1\u0026lt;= heights.length \u0026lt;= 100 1 \u0026lt;= heights[i] \u0026lt;= 100 Solution class Solution { public: int heightChecker(vector\u0026lt;int\u0026gt;\u0026amp; heights) { vector\u0026lt;int\u0026gt; ans; for(auto i : heights) ans.push_back(i); sort(ans.begin(), ans.end()); int count = 0; for(int i = 0 ; i \u0026lt; heights.size() ; i ++) if(heights[i] != ans[i]) count++; return count; } }; Complexity Analysis Time Complexity : O(NlogN) Space Complexity : O(N) Explanation 1. Intuition - We need to have a copy of the original array. - Sort the copy. - Compare the original array with the sorted array. - Count the number of mismatches. 2. Implementation - Create a copy of the `heights` array and name it `expected`. - Sort the `expected` array. - Compare the `heights` array with the `expected` array. - Count the number of mismatches. - Return the count. ","permalink":"https://KTS-o7.github.io/blog/posts/problem-height-checker/","tags":["vectors","sorting"],"title":"Problem Height Checker"},{"categories":null,"content":"Problem Statement Link - Problem 523 Question Given an integer array nums and an integer k, return true if nums has a good subarray or false otherwise.\nA good subarray is a subarray where:\nits length is at least two, and the sum of the elements of the subarray is a multiple of k.\nNote A subarray is a contiguous part of the array. An integer x is a multiple of k if there exists an integer n such that x = n * k. 0 is always a multiple of k. Example 1 Input: nums = [23,2,4,6,7], k = 6 Output: true Explanation: [2, 4] is a continuous subarray of size 2 whose elements sum up to 6. Example 2 Input: nums = [23,2,6,4,7], k = 6 Output: true Explanation: [23, 2, 6, 4, 7] is an continuous subarray of size 5 whose elements sum up to 42. 42 is a multiple of 6 because 42 = 7 * 6 and 7 is an integer. Example 3 Input: nums = [23,2,6,4,7], k = 13 Output: false Constraints - `1 \u0026lt;= nums.length \u0026lt;= 10^5` - `0 \u0026lt;= nums[i] \u0026lt;= 10^9` - `0 \u0026lt;= sum(nums[i]) \u0026lt;= 23^1 - 1` - `1 \u0026lt;= k \u0026lt;= 2^31 - 1` Solution A Brute force Solution // This code is practically useless for larger values of k and nums; class Solution { public: bool checkSubarraySum(vector\u0026lt;int\u0026gt;\u0026amp; nums,int k) { std::ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); int size = nums.size(); for(int i = 0; i\u0026lt;size; i++) { int sum = nums[i]; for(int j = i+1; j\u0026lt;size; j++) { sum+=nums[j]; if(k==0) { if(sum==0) return true; } else if(sum%k==0) return true; } } return false; } }; // Time complexity is O(N^2) // Space complexity is O(1) A Better Solution class Solution { public: bool checkSubarraySum(vector\u0026lt;int\u0026gt;\u0026amp; nums, int k) { std::ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); int size = nums.size(), sum = 0; unordered_map\u0026lt;int,int\u0026gt;indexOccured; indexOccured[0] = -1; for(int i= 0; i\u0026lt;size; i++) { sum+=nums[i]; if(indexOccured.find(sum%k) == indexOccured.end()) { indexOccured[sum%k] = i; } else { int found = indexOccured[sum%k]; if(i-found\u0026gt;1) return true; } } return false; } }; Complexity Analysis Time Complexity : O(n) Space Complexity : O(n) Explanation 1. Intuition - We need to find a subarray whose sum is a multiple of k and length is atleast 2. - We can use two loops to define start and end points of a subarray and calculate the sum. - If the sum is a multiple of k, we can return true. - But this solution is not optimal. - We can use a hashmap to store the sum%k and the index where it occured. This works for fast lookups. - So make it just a single loop to calculate the sum so far and store the sum%k in a hashmap. - If the sum%k is already present in the hashmap, we can check if the difference between the current index and the index where the sum%k occured is greater than 1. - if yes return true. If not continue. 2. Implementation - Intialize a hashmap `indexOccured` with key as 0 and value as -1. - This initialization is to prevent the edge case where the first element is a multiple of k. - Iterate over the array `nums` and calculate the `sum` so far. - If the `sum%k` is not present in the hashmap, add it to the hashmap with the index. - If the `sum%k` is already present in the hashmap: check if the difference between the current index and the index where the `sum%k` occured is greater than 1. - If yes return true. If not continue. - If we reach end of the loop, return false. A really good mathematical optimization problem. The hashmap is the key to this solution. The hashmap stores the sum%k and the index where it occured. If the sum%k is already present in the hashmap, we can check if the difference between the current index and the index where the sum%k occured is greater than 1.\n","permalink":"https://KTS-o7.github.io/blog/posts/problem-continuous-subarray-sum/","tags":["hashmap","prefix-sum","prefixsum","vector"],"title":"Problem Continuous Subarray Sum"},{"categories":null,"content":"Problem Statement Link - Problem 1002 Question Given a string array words, return an array of all characters that show up in all strings within the words (including duplicates). You may return the answer in any order.\nExample 1 Input: words = [\u0026#34;bella\u0026#34;,\u0026#34;label\u0026#34;,\u0026#34;roller\u0026#34;] Output: [\u0026#34;e\u0026#34;,\u0026#34;l\u0026#34;,\u0026#34;l\u0026#34;] Example 2 Input: words = [\u0026#34;cool\u0026#34;,\u0026#34;lock\u0026#34;,\u0026#34;cook\u0026#34;] Output: [\u0026#34;c\u0026#34;,\u0026#34;o\u0026#34;] Constraints 1 \u0026lt;= words.length \u0026lt;= 100 1 \u0026lt;= words[i].length \u0026lt;= 100 words[i] consists of lowercase English letters. Solution class Solution { public: vector\u0026lt;string\u0026gt; commonChars(vector\u0026lt;string\u0026gt;\u0026amp; words) { vector\u0026lt;int\u0026gt;baselineCount(26,0); string temp; for(int i =0;i\u0026lt;words[0].size();i++) { baselineCount[words[0][i]-\u0026#39;a\u0026#39;]++; } for(auto word:words) { vector\u0026lt;int\u0026gt;newCount(26,0); for(const auto\u0026amp; ch:word) newCount[ch-\u0026#39;a\u0026#39;]++; for(int i= 0;i\u0026lt;26;i++) baselineCount[i] = min(baselineCount[i],newCount[i]); } vector\u0026lt;string\u0026gt;answer; for(int i =0; i\u0026lt;26;i++) { while(baselineCount[i]--) { temp = \u0026#34;\u0026#34;; temp += \u0026#39;a\u0026#39;+i; answer.push_back(temp); } } return answer; } }; Complexity Analysis Time Complexity : O(N) Space Complexity : O(1) Explanation 1. Intuition - We need to find the common characters in all the strings. - We need some kind of hash table to store all the common characters. - Characters may be repeated so we need to store the count of each character. 2. Implementation - Initialize a vector `baselineCount` of size 26 with all elements as `0`. - Iterate over the first word and increment the count of each character in the `baselineCount`. - Iterate over all the words and for each word create a new vector `newCount` of size 26 with all elements as `0`. - Increment the count of each character in the `newCount`. - Iterate over the `baselineCount` and `newCount` and update the `baselineCount` with the minimum of both. - This will give us the count of each character that is common in all the words seen so far. - Iterate over the `baselineCount` and for each character that has a count greater than `0` add it to the answer. - Return the answer. This problem is about finding the common characters in a given set of strings.\n","permalink":"https://KTS-o7.github.io/blog/posts/problem-find-common-characters/","tags":["string","hash-table","vector","array"],"title":"Problem Find Common Characters"},{"categories":null,"content":"Problem Statement Link - Problem 846 Question Alice has some number of cards and she wants to rearrange the cards into groups so that each group is of size groupSize, and consists of groupSize consecutive cards.\nGiven an integer array hand where hand[i] is the value written on the ith card and an integer groupSize, return true if she can rearrange the cards, or false otherwise.\nNote : Only groupSize matters not the number of groups. We can only form groups of size groupSize if total number of cards is divisible by groupSize. Consecutive cards means cards with consecutive values ie groups like [1,2,3] or [3,4,5] are valid but [1,3,4] is not valid for given groupSize = 3 Example 1 Input: hand = [1,2,3,6,2,3,4,7,8], groupSize = 3 Output: true Explanation: Alice\u0026#39;s hand can be rearranged as [1,2,3],[2,3,4],[6,7,8] Example 2 Input: hand = [1,2,3,4,5], groupSize = 4 Output: false Explanation: Alice\u0026#39;s hand can not be rearranged into groups of 4. Constraints - `1 \u0026lt;= hand.length \u0026lt;= 10^4` - `0 \u0026lt;= hand[i] \u0026lt;= 10^9` - `1 \u0026lt;= groupSize \u0026lt;= hand.length` Solution class Solution { public: bool isNStraightHand(vector\u0026lt;int\u0026gt;\u0026amp; hand, int groupSize) { std::ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); if (hand.size() % groupSize != 0) return false; map\u0026lt;int, int\u0026gt; freqCount; for (const int\u0026amp; card : hand) freqCount[card]++; for (auto it = freqCount.begin(); it != freqCount.end(); ++it) { if (it-\u0026gt;second \u0026gt; 0) { int count = it-\u0026gt;second; for (int i = 0; i \u0026lt; groupSize; ++i) { if (freqCount[it-\u0026gt;first + i] \u0026lt; count) return false; freqCount[it-\u0026gt;first + i] -= count; } } } return true; } }; Complexity Analysis Time Complexity : O(NlogN) Space Complexity : O(N) Explanation 1. Intuition - We need to check if we can form groups of size `groupSize` with given cards. - If not possible return false. - We need to maintain the count of each card. - We need this count to check if we can form groups of size `groupSize`. 2. Implementation - Check if total number of cards is divisible by `groupSize`. - If not return `false`. - Create a map `freqCount` to store the count of each card. - Iterate over the `hand` and increment the count of each card in `freqCount`. - For every card in `freqCount` check if the count is greater than `0`. - If yes then assign the count to a variable `count`. - Iterate over the next `groupSize` cards and check if the count of each card is greater than or equal to `count`. - This will help us to check if we can form groups of size `groupSize` with current card and next `groupSize-1` cards. - If not return `false`. - If yes then decrement the count of each card by `count`. - Continue this process until we have checked all the cards. - If we reach here then return `true`. This problem is also same as Problem 1296 . We need to dovode the array into groups of size k such that each group is consecutive.\n","permalink":"https://KTS-o7.github.io/blog/posts/problem-hand-of-straights/","tags":[],"title":"Problem Hand of Straights"},{"categories":null,"content":"Problem Statement Link - Problem 344 Question Write a function that reverses a string. The input string is given as an array of characters s.\nYou must do this by modifying the input array in-place with O(1) extra memory.\nExample 1 Input: s = [\u0026#34;h\u0026#34;,\u0026#34;e\u0026#34;,\u0026#34;l\u0026#34;,\u0026#34;l\u0026#34;,\u0026#34;o\u0026#34;] Output: [\u0026#34;o\u0026#34;,\u0026#34;l\u0026#34;,\u0026#34;l\u0026#34;,\u0026#34;e\u0026#34;,\u0026#34;h\u0026#34;] Example 2 Input: s = [\u0026#34;H\u0026#34;,\u0026#34;a\u0026#34;,\u0026#34;n\u0026#34;,\u0026#34;n\u0026#34;,\u0026#34;a\u0026#34;,\u0026#34;h\u0026#34;] Output: [\u0026#34;h\u0026#34;,\u0026#34;a\u0026#34;,\u0026#34;n\u0026#34;,\u0026#34;n\u0026#34;,\u0026#34;a\u0026#34;,\u0026#34;H\u0026#34;] Constraints 1 \u0026lt;= s.length \u0026lt;= 10^5 s[i] is a printable ascii character. Solution class Solution { public: void reverseString(vector\u0026lt;char\u0026gt;\u0026amp; s) { int start = 0, end = s.size()-1; char ch; while(start\u0026lt;end) { ch = s[start]; s[start] = s[end]; s[end] = ch; ++start; --end; } } }; Complexity Analysis Time Complexity : O(N) Space Complexity :O(1) Explanation 1. Intuition - Use two pointer approach to swap the elements. - We need to write a swapping logic without using any extra space. 2. Implementation 1. Initialize two pointers `start` and `end` to `0` and `s.size()-1` respectively. 2. Swap the elements at `start` and `end` index. 3. Increment `start` and decrement `end` until `start` is less than `end`. Alternate Solution class Solution { public: void reverseString(vector\u0026lt;char\u0026gt;\u0026amp; s) { reverse(s.begin(),s.end()); } }; Complexity Analysis Time Complexity : O(N) Space Complexity :O(1) Explanation - This solution uses the inbuilt `reverse` function to reverse the string. Utilizes the two pointer approach to swap the elements in the array.\n","permalink":"https://KTS-o7.github.io/blog/posts/problem-reverse-string/","tags":["two-pointer","string"],"title":"Problem Reverse String"},{"categories":null,"content":"Problem Statement Link - Problem 3110 Question You are given a string s. The score of a string is defined as the sum of the absolute difference between the ASCII values of adjacent characters.\nReturn the score of s.\nExample 1 Input: s = \u0026#34;hello\u0026#34; Output: 13 Explanation: The ASCII values of the characters in s are: \u0026#39;h\u0026#39; = 104, \u0026#39;e\u0026#39; = 101, \u0026#39;l\u0026#39; = 108, \u0026#39;o\u0026#39; = 111. So, the score of s would be |104 - 101| + |101 - 108| + |108 - 108| + |108 - 111| = 3 + 7 + 0 + 3 = 13. Example 2 Input: s = \u0026#34;zaz\u0026#34; Output: 50 Explanation: The ASCII values of the characters in s are: \u0026#39;z\u0026#39; = 122, \u0026#39;a\u0026#39; = 97. So, the score of s would be |122 - 97| + |97 - 122| = 25 + 25 = 50. Constraints 2 \u0026lt;= s.length \u0026lt;= 100 s consists only of lowercase English letters. Solution class Solution { public: int scoreOfString(string s) { std::ios::sync_with_stdio(false); cout.tie(0); cin.tie(0); int score = 0; for(int i = 0;i\u0026lt;s.size()-1;i++) { score+= abs((int)(s[i]-s[i+1])); } return score; } }; Complexity Analysis Time Complexity: O(N) Space Complexity: O(1) Explanation 1. Intuition We can iterate over the string and calculate the score by taking the absolute difference between the ASCII values of adjacent characters. 2. Implementation Initialize the score to 0. Iterate over the string from 0 to s.size()-1. Calculate the score by taking the absolute difference between the ASCII values of adjacent characters. Return the score. This solution is a simple implementation of problem statement.\n","permalink":"https://KTS-o7.github.io/blog/posts/problem-score-of-a-string/","tags":["string","traversal"],"title":"Problem Score of a String"},{"categories":null,"content":"Problem Statement Link - Problem 131 Question Given a string s, partition s such that every substring of the partition is a palindrome. Return all possible palindrome partitioning of s.\nNote to self First we need to split the string into all possible substrings. Then we need to check if each substring is a palindrome or not. If that split is palindromic then we need to add it to the result. Example 1 Input: s = \u0026#34;aab\u0026#34; Output: [[\u0026#34;a\u0026#34;,\u0026#34;a\u0026#34;,\u0026#34;b\u0026#34;],[\u0026#34;aa\u0026#34;,\u0026#34;b\u0026#34;]] Example 2 Input: s = \u0026#34;a\u0026#34; Output: [[\u0026#34;a\u0026#34;]] Additional Examples s = \u0026#34;aaab\u0026#34; output = [[\u0026#34;a\u0026#34;,\u0026#34;a\u0026#34;,\u0026#34;a\u0026#34;,\u0026#34;b\u0026#34;],[\u0026#34;a\u0026#34;,\u0026#34;aa\u0026#34;,\u0026#34;b\u0026#34;],[\u0026#34;aa\u0026#34;,\u0026#34;a\u0026#34;,\u0026#34;b\u0026#34;],[\u0026#34;aaa\u0026#34;,\u0026#34;b\u0026#34;]] s = \u0026#34;abcaa\u0026#34; output = [[\u0026#34;a\u0026#34;,\u0026#34;b\u0026#34;,\u0026#34;c\u0026#34;,\u0026#34;a\u0026#34;,\u0026#34;a\u0026#34;],[\u0026#34;a\u0026#34;,\u0026#34;b\u0026#34;,\u0026#34;c\u0026#34;,\u0026#34;aa\u0026#34;]] s = \u0026#34;abbab\u0026#34; output = [[\u0026#34;a\u0026#34;,\u0026#34;b\u0026#34;,\u0026#34;b\u0026#34;,\u0026#34;a\u0026#34;,\u0026#34;b\u0026#34;],[\u0026#34;a\u0026#34;,\u0026#34;b\u0026#34;,\u0026#34;bab\u0026#34;],[\u0026#34;a\u0026#34;,\u0026#34;bb\u0026#34;,\u0026#34;a\u0026#34;,\u0026#34;b\u0026#34;],[\u0026#34;abba\u0026#34;,\u0026#34;b\u0026#34;]] s = \u0026#34;abaca\u0026#34; output = [[\u0026#34;a\u0026#34;,\u0026#34;b\u0026#34;,\u0026#34;a\u0026#34;,\u0026#34;c\u0026#34;,\u0026#34;a\u0026#34;],[\u0026#34;a\u0026#34;,\u0026#34;b\u0026#34;,\u0026#34;aca\u0026#34;],[\u0026#34;aba\u0026#34;,\u0026#34;c\u0026#34;,\u0026#34;a\u0026#34;]] s = \u0026#34;aaa\u0026#34; output = [[\u0026#34;a\u0026#34;,\u0026#34;a\u0026#34;,\u0026#34;a\u0026#34;],[\u0026#34;a\u0026#34;,\u0026#34;aa\u0026#34;],[\u0026#34;aa\u0026#34;,\u0026#34;a\u0026#34;],[\u0026#34;aaa\u0026#34;]] Constraints 1 \u0026lt;= s.length \u0026lt;= 16 s contains only lowercase English letters. Solution class Solution { public: vector\u0026lt;vector\u0026lt;string\u0026gt;\u0026gt; partition(string s) { std::ios::sync_with_stdio(false); cin.tie(0); cout.tie(0); vector\u0026lt;vector\u0026lt;string\u0026gt;\u0026gt; result; vector\u0026lt;string\u0026gt; path; backtrack(s, 0, path, result); return result; } private: void backtrack(const string\u0026amp; s, int start, vector\u0026lt;string\u0026gt;\u0026amp; path, vector\u0026lt;vector\u0026lt;string\u0026gt;\u0026gt;\u0026amp; result) { if (start == s.length()) { result.push_back(path); return; } for (int end = start + 1; end \u0026lt;= s.length(); ++end) { if (isPalindrome(s, start, end - 1)) { path.push_back(s.substr(start, end - start)); backtrack(s, end, path, result); path.pop_back(); } } } bool isPalindrome(const string\u0026amp; s, int left, int right) { while (left \u0026lt; right) { if (s[left++] != s[right--]) return false; } return true; } }; Complexity Analysis Time Complexity : O(N * 2^N) : 2^N subsets and each subset has N elements Space Complexity : O(N) : Recursive stack space Explanation 1. Intuition The intuition behind the solution is to use backtracking to generate all possible partitions of the input string s. For each position in the string, the algorithm considers extending the current partition with substrings starting from that position. Before extending, it checks if the substring is a palindrome using the isPalindrome helper function. If the substring is a palindrome, it adds the substring to the current partition (path) and recursively explores further partitions starting from the next character. Once a full partition is found (i.e., the end of the string is reached), it adds the partition to the result set. 2. Implementation Backtracking Function: The backtrack function is the core of the solution. It takes the input string s, the current start position, the current partition path, and the result set result. It iterates through the string, considering each position as a potential start of a new substring. For each position, it checks if the substring ending at that position is a palindrome. If so, it extends the current partition with this substring and recursively calls itself to explore further partitions. When the end of the string is reached, it means a valid partition has been found, which is then added to the result set. Is Palindrome Helper Function: The isPalindrome function checks if a given substring is a palindrome. It compares characters from both ends of the substring moving towards the center. If any pair of characters does not match, it returns false; otherwise, it continues comparing until the middle of the substring is reached, indicating that the entire substring is a palindrome. 3. Dry Run Let\u0026rsquo;s dry run the solution on the example input s = \u0026ldquo;aab\u0026rdquo; to understand how the backtracking algorithm generates all possible palindrome partitions. Input: s = \u0026#34;aab\u0026#34; Output: [[\u0026#34;a\u0026#34;,\u0026#34;a\u0026#34;,\u0026#34;b\u0026#34;],[\u0026#34;aa\u0026#34;,\u0026#34;b\u0026#34;]] - First, the backtrack function is called with the input string \u0026#34;aab\u0026#34;, start position 0, an empty path, and an empty result set. - At position 0, the substring \u0026#34;a\u0026#34; is a palindrome, so it is added to the path, and the function is recursively called with the updated path and the next position. - At position 1, the substring \u0026#34;a\u0026#34; is a palindrome, so it is added to the path, and the function is recursively called with the updated path and the next position. - At position 2, the substring \u0026#34;b\u0026#34; is a palindrome, so it is added to the path, and the function reaches the end of the string, adding the current partition [\u0026#34;a\u0026#34;,\u0026#34;a\u0026#34;,\u0026#34;b\u0026#34;] to the result set. - Backtracking occurs, and the last character \u0026#34;b\u0026#34; is removed from the path. - At position 1, the substring \u0026#34;aa\u0026#34; is a palindrome, so it is added to the path, and the function is recursively called with the updated path and the next position. - At position 2, the substring \u0026#34;b\u0026#34; is a palindrome, so it is added to the path, and the function reaches the end of the string, adding the current partition [\u0026#34;aa\u0026#34;,\u0026#34;b\u0026#34;] to the result set. - Backtracking occurs, and the last character \u0026#34;b\u0026#34; is removed from the path. - Backtracking occurs again, and the last character \u0026#34;a\u0026#34; is removed from the path. - The function returns the final result set containing all possible palindrome partitions of the input string \u0026#34;aab\u0026#34;. This solution uses backtracking to generate all possible palindrome partitions of the input string. By exploring all possible partitions, it ensures that no valid partition is missed, resulting in a complete set of palindrome partitions.\n","permalink":"https://KTS-o7.github.io/blog/posts/problem-palindrome-partitioning/","tags":["backtracking","recursion","cpp"],"title":"Problem Palindrome Partitioning"},{"categories":null,"content":"Problem Statement Link - Problem 78 Question Given an integer array nums of unique elements, return all possible subsets (the power set).\nA subset of an array is a selection of elements (possibly none) of the array. The solution set must not contain duplicate subsets. Return the solution in any order.\nExample 1 Input: nums = [1,2,3] Output: [[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]] Example 2 Input: nums = [0] Output: [[],[0]] Constraints 1 \u0026lt;= nums.length \u0026lt;= 10 -10 \u0026lt;= nums[i] \u0026lt;= 10 All the numbers of nums are unique. Solution class Solution { public: vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; subsets(vector\u0026lt;int\u0026gt;\u0026amp; nums) { vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; result; result.push_back({}); int n; for (int num : nums) { n = result.size(); for (int i = 0; i \u0026lt; n; ++i) { vector\u0026lt;int\u0026gt; subset = result[i]; subset.push_back(num); result.push_back(subset); } } return result; } }; Complexity Analysis Time Complexity : O(N * 2^N) - 2^N subsets and each subset has N elements Space Complexity : O(N * 2^N) - 2^N subsets and each subset has N elements Explanation 1. Intuition The idea is to start with an empty subset and keep adding elements to it. For each element in the input array, we add it to all the existing subsets and create new subsets. 2. Implementation We start with an empty subset and add it to the result. For each element in the input array, we iterate over all the existing subsets and create new subsets by adding the current element to them. We add these new subsets to the result. Finally, we return the result containing all the subsets. Solution with backtracking class Solution { public: vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; subsets(vector\u0026lt;int\u0026gt;\u0026amp; nums) { vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; result; vector\u0026lt;int\u0026gt; subset; backtrack(result, subset, nums, 0); return result; } void backtrack(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; result, vector\u0026lt;int\u0026gt;\u0026amp; subset, vector\u0026lt;int\u0026gt;\u0026amp; nums, int start) { result.push_back(subset); for (int i = start; i \u0026lt; nums.size(); ++i) { subset.push_back(nums[i]); backtrack(result, subset, nums, i + 1); subset.pop_back(); } } }; Complexity Analysis of backtracking solution Time Complexity : O(N * 2^N) - 2^N subsets and each subset has N elements Space Complexity : O(N) - The depth of the recursion tree can go up to N Explanation of backtracking solution 1. Intuition We can either add an element to the subset or not add it. We will get one subset with element added to it and another subset without the element. Recursion tree for the input [1,2,3] graph TD A[ ] --\u003e B1[1] A[ ] --\u003e C[ ] B1[1] --\u003e D12[1, 2] B1[1] --\u003e E1[1] D12[1, 2] --\u003e F123[1, 2, 3] D12[1, 2] --\u003e G12[1, 2] E1[1] --\u003e L13[1, 3] E1[1] --\u003e M1[1] C[ ] --\u003e R2[2] C[ ] --\u003e S[ ] R2[2] --\u003e T23[2, 3] S[ ] --\u003e Z3[3] 2. Implementation result is the vector of all subsets. For each element in the input array, we add it to the subset and call the backtrack function recursively. In the backtrack function, we add the subset to the result and iterate over the remaining elements in the input array. This is ensured by starting the loop from the start index. Then we remove the current element from the subset once the recursive call returns. Shows the usage of backtracking to ensure proper subset generation.\n","permalink":"https://KTS-o7.github.io/blog/posts/problem-subsets/","tags":["backtracking","recursion","iterative","cpp"],"title":"Problem Subsets"},{"categories":null,"content":"Problem Statement Link - Problem 1863 Question The XOR total of an array is defined as the bitwise XOR of all its elements, or 0 if the array is empty.\nFor example, the XOR total of the array [2,5,6] is 2 XOR 5 XOR 6 = 1. Given an array nums, return the sum of all XOR totals for every subset of nums.\nNote: Subsets with the same elements should be counted multiple times.\nAn array a is a subset of an array b if a can be obtained from b by deleting some (possibly zero) elements of b.\nExample 1 Input: nums = [1,3] Output: 6 Explanation: The 4 subsets of [1,3] are: - The empty subset has an XOR total of 0. - [1] has an XOR total of 1. - [3] has an XOR total of 3. - [1,3] has an XOR total of 1 XOR 3 = 2. 0 + 1 + 3 + 2 = 6 Example 2 Input: nums = [5,1,6] Output: 28 Explanation: The 8 subsets of [5,1,6] are: - The empty subset has an XOR total of 0. - [5] has an XOR total of 5. - [1] has an XOR total of 1. - [6] has an XOR total of 6. - [5,1] has an XOR total of 5 XOR 1 = 4. - [5,6] has an XOR total of 5 XOR 6 = 3. - [1,6] has an XOR total of 1 XOR 6 = 7. - [5,1,6] has an XOR total of 5 XOR 1 XOR 6 = 2. 0 + 5 + 1 + 6 + 4 + 3 + 7 + 2 = 28 Example 3 Input: nums = [3,4,5,6,7,8] Output: 480 Explanation: The sum of all XOR totals for every subset is 480. Constraints 1 \u0026lt;= nums.length \u0026lt;= 12 1 \u0026lt;= nums[i] \u0026lt;= 20 Solution class Solution { public: int subsetXORSum(vector\u0026lt;int\u0026gt;\u0026amp; nums) { std::ios::sync_with_stdio(false); return calculate(nums, 0, 0); } int calculate(vector\u0026lt;int\u0026gt;\u0026amp; nums, int level, int currentXOR) { if (level == nums.size()) return currentXOR; int include = calculate(nums, level + 1, currentXOR ^ nums[level]); int exclude = calculate(nums, level + 1, currentXOR); return include + exclude; } }; Complexity Analysis Time Complexity: O(2^n), where n is the length of nums. This is because there are 2^n subsets. Space Complexity: O(n), which is the depth of the recursion tree. Explanation 1. Intuition The problem requires calculating the XOR total of all subsets. Each element can either be included or excluded in a subset. We need to explore both possibilities for each element using recursion. Recursion Tree for Example 1 graph TD A[Start nums = 1, 3 currentXOR = 0] --\u003e B[Include 1 currentXOR = 1] A --\u003e C[Exclude 1 currentXOR = 0] B --\u003e D[Include 3 currentXOR = 1 XOR 3 = 2] B --\u003e E[Exclude 3 currentXOR = 1] C --\u003e F[Include 3 currentXOR = 0 XOR 3 = 3] C --\u003e G[Exclude 3 currentXOR = 0] D --\u003e H[Leaf Node currentXOR = 2] E --\u003e I[Leaf Node currentXOR = 1] F --\u003e J[Leaf Node currentXOR = 3] G --\u003e K[Leaf Node currentXOR = 0] 2. Implementation The calculate function is a recursive function that explores all subsets. At each step, we decide whether to include or exclude the current element. The base case is when we\u0026rsquo;ve considered all elements, at which point we return the current XOR total. The final result is the sum of XOR totals for all subsets. 3. Functions subsetXORSum: Initializes the recursive process. calculate: Recursively calculates the XOR total for all subsets, either including or excluding the current element, and sums the results. This problem demonstrates the use of recursion, backtracking and bit manipulation to solve combinatorial problems.\n","permalink":"https://KTS-o7.github.io/blog/posts/problem-sum-of-all-subset-xor-totals/","tags":["backtracking","bit-manipulation","recursion","cpp"],"title":"Problem Sum of All Subset XOR Totals"},{"categories":null,"content":"Problem Statement Link - Problem 3068 Question There exists an undirected tree with n nodes numbered 0 to n - 1. You are given a 0-indexed 2D integer array edges of length n - 1, where edges[i] = [ui, vi] indicates that there is an edge between nodes ui and vi in the tree. You are also given a positive integer k, and a 0-indexed array of non-negative integers nums of length n, where nums[i] represents the value of the node numbered i.\nAlice wants the sum of values of tree nodes to be maximum, for which Alice can perform the following operation any number of times (including zero) on the tree:\nChoose any edge [u, v] connecting the nodes u and v, and update their values as follows:\nnums[u] = nums[u] XOR k nums[v] = nums[v] XOR k Return the maximum possible sum of the values Alice can achieve by performing the operation any number of times. Example 1 Input: nums = [1,2,1], k = 3, edges = [[0,1],[0,2]] Output: 6 Explanation: Alice can achieve the maximum sum of 6 using a single operation: - Choose the edge [0,2]. nums[0] and nums[2] become: 1 XOR 3 = 2, and the array nums becomes: [1,2,1] -\u0026gt; [2,2,2]. The total sum of values is 2 + 2 + 2 = 6. It can be shown that 6 is the maximum achievable sum of values. flowchart TD id1(input) A((1)) --\u003e B((2)) A --\u003e C((1)) Example 2 Input: nums = [2,3], k = 7, edges = [[0,1]] Output: 9 Explanation: Alice can achieve the maximum sum of 9 using a single operation: - Choose the edge [0,1]. nums[0] becomes: 2 XOR 7 = 5 and nums[1] become: 3 XOR 7 = 4, and the array nums becomes: [2,3] -\u0026gt; [5,4]. The total sum of values is 5 + 4 = 9. It can be shown that 9 is the maximum achievable sum of values. flowchart TD id1(input) A((2)) --\u003e B((3)) Example 3 Input: nums = [7,7,7,7,7,7], k = 3, edges = [[0,1],[0,2],[0,3],[0,4],[0,5]] Output: 42 Explanation: The maximum achievable sum is 42 which can be achieved by Alice performing no operations. flowchart TD id1(input) A((7)) --\u003e B((7)) A --\u003e C((7)) A --\u003e D((7)) A --\u003e E((7)) A --\u003e F((7)) Constraints 2 \u0026lt;= n == nums.length \u0026lt;= 2 * 10*4 1 \u0026lt;= k \u0026lt;= 10^9 0 \u0026lt;= nums[i] \u0026lt;= 10^9 edges.length == n - 1 edges[i].length == 2 0 \u0026lt;= edges[i][0], edges[i][1] \u0026lt;= n - 1 The input is generated such that edges represent a valid tree. Solution static auto fastio = [](){ std::ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); return nullptr; }; class Solution { public: long long maximumValueSum(vector\u0026lt;int\u0026gt;\u0026amp; nums, int k, vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; edges) { long long res = 0; int changes = 0; int minDiff = INT_MAX; for (int num : nums) { int xorNum = num ^ k; if (num \u0026lt; xorNum) { changes++; res += xorNum; } else { res += num; } minDiff = min(minDiff, abs(num - xorNum)); } if (changes % 2 == 1) return res - minDiff; else return res; } }; Complexity Analysis Time Complexity : O(N) Space Complexity : O(1) Explanation 1. Intuition The problem is to find the maximum sum of the values of the nodes in the tree. We know that since its a tree, a path can be found between any two nodes. Hence we need to make sure that only even number of nodes need to be updated. 2. Implementation We iterate over the nodes and calculate the XOR value of the node with k. If the XOR value is greater than the original value, we update the node and increment the changes. We also calculate the minimum difference between the original value and the XOR value. If the number of changes is odd, we subtract the minimum difference from the result. This step is done to make sure that only even number of nodes are updated. Finally, we return the result. There are DP solutions possible for this problem, but the above greedy solution is the most optimal one. -\u0026gt; Click DP Solution In Leetcode ","permalink":"https://KTS-o7.github.io/blog/posts/problem-find-the-maximum-sum-of-node-values/","tags":["XOR","bit-manipulation","tree","greedy"],"title":"Problem Find the Maximum Sum of Node Values"},{"categories":null,"content":"Problem Statement Link - Problem 979 Question You are given the root of a binary tree with n nodes where each node in the tree has node.val coins. There are n coins in total throughout the whole tree.\nIn one move, we may choose two adjacent nodes and move one coin from one node to another. A move may be from parent to child, or from child to parent.\nReturn the minimum number of moves required to make every node have exactly one coin.\nNote Actually here the word minimum doesnt make any sense. Because we can move coins from parent to child and child to parent. What exactly we need to find is the flow of coins in a given path. Example 1 Input: root = [3,0,0] Output: 2 Explanation: From the root of the tree, we move one coin to its left child, and one coin to its right child. Example 2 Input: root = [0,3,0] Output: 3 Explanation: From the left child of the root, we move two coins to the root [taking two moves]. Then, we move one coin from the root of the tree to the right child. Example 3 (Important case) Since the only constraint is number of coins in the tree is same as number of nodes, it can be distributed in any manner.\nInput: root = [1,0,2] Output: 2 Explanation: From the root of the tree, we move one coin to the left child. From right child, we move one coin to the root. Constraints The number of nodes in the tree is n. 1 \u0026lt;= n \u0026lt;= 100 0 \u0026lt;= node.val \u0026lt;= n The sum of all node.val is n. Solution /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { int countSteps(TreeNode* root, int\u0026amp; step) { if( root == nullptr) return 0; int leftCoin = countSteps(root-\u0026gt;left,step); int rightCoin = countSteps(root-\u0026gt;right,step); step += abs(leftCoin) + abs(rightCoin); return (root-\u0026gt;val -1) + leftCoin + rightCoin; } public: int distributeCoins(TreeNode* root) { int ans = 0; countSteps(root,ans); return ans; } }; Complexity Analysis Time Complexity - O(N) - We are visiting each node once. Space Complexity - O(H) - Height of the tree. Explanation 1. Intuition We just need to find the movement of coins in the tree. If a node has y coins, then it will give y-1 coins to its parent. If a node has 0 coins then it will request 1 coin from its parent. So, we can say that abs(y-1) is the number of coins that will be moved from that node. Number of coins moved from a node is abs(z-1) + Coins from left subtree + Coins from right subtree. 2. Implementation If the root is null, return 0. This handles the base case. Recursively call the function on the left and right subtree. Calculate the number of coins moved from the left and right subtree. Store it in leftCoin and rightCoin. Store total steps so far done in step. Calculate the number of coins moved from the current node using the formula root-\u0026gt;val - 1 + leftCoin + rightCoin. ","permalink":"https://KTS-o7.github.io/blog/posts/problem-distribute-coins-in-binary-tree/","tags":["dfs","recursion","postorder","binary-tree"],"title":"Problem Distribute Coins in Binary Tree"},{"categories":null,"content":"Problem Statement Link - Problem 1325 Question Given a binary tree root and an integer target, delete all the leaf nodes with value target.\nNote that once you delete a leaf node with value target, if its parent node becomes a leaf node and has the value target, it should also be deleted (you need to continue doing that until you cannot).\nExample 1 Input: root = [1,2,3,2,null,2,4], target = 2 Output: [1,null,3,null,4] Explanation: Leaf nodes in green with value (target = 2) are removed (Picture in left). After removing, new nodes become leaf nodes with value (target = 2) (Picture in center). flowchart TD id1(input) A((1)) --\u003e B((2)) A --\u003e C((3)) C --\u003e D((2)) D --\u003e E((2)) D --\u003e F((4)) id2(Output) G((1)) --\u003eH((3)) H --\u003e I((4)) Example 2 Input: root = [1,3,3,3,2], target = 3 Output: [1,3,null,null,2] flowchart TD id1(input) A((1)) --\u003e B((3)) A --\u003e C((3)) C --\u003e D((3)) D --\u003e E((3)) D --\u003e F((2)) id2(Output) G((1)) --\u003eH((3)) H --\u003e I((2)) Example 3 Input: root = [1,2,null,2,null,2], target = 2 Output: [1] Explanation: Leaf nodes in green with value (target = 2) are removed at each step. flowchart TD id1(input) A((1)) --\u003e B((2)) A --\u003e C((2)) C --\u003e D((2)) id2(Output) E((1)) Constraints The number of nodes in the tree is in the range [1, 3000]. 1 \u0026lt;= Node.val, target \u0026lt;= 1000 Solution /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: TreeNode* removeLeafNodes(TreeNode* root, int target) { if (!root) return nullptr; root-\u0026gt;left = removeLeafNodes(root-\u0026gt;left, target); root-\u0026gt;right = removeLeafNodes(root-\u0026gt;right, target); if (!root-\u0026gt;left \u0026amp;\u0026amp; !root-\u0026gt;right \u0026amp;\u0026amp; root-\u0026gt;val == target) return nullptr; return root; } }; Complexity Analysis Time complexity - O(N) Space complexity - O(H) Explanation 1. Intuition This can be solved using DFS. We will traverse the tree in post-order fashion. If the node is leaf and has the value equal to the target, Remove it. Otherwise, return the node. 2. Implementation If the root is null, return null. Recursively call the function on the left and right subtree. By this we will reach the leaf nodes. If the leaf node has the value equal to the target, return null. Otherwise, return the node. ","permalink":"https://KTS-o7.github.io/blog/posts/problem-delete-leaves-with-a-given-value/","tags":["binary-tree","dfs","recursion","postorder"],"title":"Problem Delete Leaves With a Given Value"},{"categories":null,"content":"Problem Statement Link - Problem 2331 Question You are given the root of a full binary tree with the following properties:\nLeaf nodes have either the value 0 or 1, where 0 represents False and 1 represents True. Non-leaf nodes have either the value 2 or 3, where 2 represents the boolean OR and 3 represents the boolean AND. The evaluation of a node is as follows:\nIf the node is a leaf node, the evaluation is the value of the node, i.e. True or False. Otherwise, evaluate the node\u0026rsquo;s two children and apply the boolean operation of its value with the children\u0026rsquo;s evaluations. Return the boolean result of evaluating the root node. A full binary tree is a binary tree where each node has either 0 or 2 children.\nA leaf node is a node that has zero children.\nExample 1 Input graph TD A((2))--\u003eB((1)) A--\u003eC((3)) C((3))--\u003eD((0)) C((3))--\u003eE((1)) F((OR))--\u003eG((True)) F--\u003eH((AND)) H--\u003eI((False)) H--\u003eJ((True)) Input: root = [2,1,3,null,null,0,1] Output: true Explanation: The above diagram illustrates the evaluation process. The AND node evaluates to False AND True = False. The OR node evaluates to True OR False = True. The root node evaluates to True, so we return true. Example 2 Input: root = [0] Output: false Explanation: The root node is a leaf node and it evaluates to false, so we return false. Constraints The number of nodes in the tree is in the range [1, 1000]. 0 \u0026lt;= Node.val \u0026lt;= 3 Every node has either 0 or 2 children. Leaf nodes have a value of 0 or 1. Non-leaf nodes have a value of 2 or 3. Solution /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: bool evaluateTree(TreeNode* root) { if(root-\u0026gt;left == nullptr \u0026amp;\u0026amp; root-\u0026gt;right == nullptr) return root-\u0026gt;val; else { if(root-\u0026gt;val == 2) return evaluateTree(root-\u0026gt;left) || evaluateTree(root-\u0026gt;right); else return evaluateTree(root-\u0026gt;left) \u0026amp;\u0026amp; evaluateTree(root-\u0026gt;right); } } }; Complexity Analysis Time: O(N) Space: O(N) Explanation 1. Intuition To evalute any node we need to evaluate its left and right child. There is no need to evaluate the leaf nodes as they are the base case. Using this we can develop a DFS based solution. 2. Implementation The evaluateTree function is used to evaluate the tree. If the node is a leaf node, we return the value of the node. Otherwise, we evaluate the left and right child and apply the operation based on the value of the node. If the value of the node is 2, we apply OR operation. If the value of the node is 3, we apply AND operation. ","permalink":"https://KTS-o7.github.io/blog/posts/problem-evaluate-boolean-binary-tree/","tags":["binary-tree","dfs","bit-manipulation","cpp"],"title":"Problem Evaluate Boolean Binary Tree"},{"categories":null,"content":"Problem Statement Link - Problem 1219 Question In a gold mine grid of size m x n, each cell in this mine has an integer representing the amount of gold in that cell, 0 if it is empty.\nReturn the maximum amount of gold you can collect under the conditions:\nEvery time you are located in a cell you will collect all the gold in that cell. From your position, you can walk one step to the left, right, up, or down. You can\u0026rsquo;t visit the same cell more than once. Never visit a cell with 0 gold. You can start and stop collecting gold from any position in the grid that has some gold. Example 1 Input: grid = [[0,6,0],[5,8,7],[0,9,0]] Output: 24 Explanation: [[0,6,0], [5,8,7], [0,9,0]] Path to get the maximum gold, 9 -\u0026gt; 8 -\u0026gt; 7. Example 2 Input: grid = [[1,0,7],[2,0,6],[3,4,5],[0,3,0],[9,0,20]] Output: 28 Explanation: [[1,0,7], [2,0,6], [3,4,5], [0,3,0], [9,0,20]] Path to get the maximum gold, 1 -\u0026gt; 2 -\u0026gt; 3 -\u0026gt; 4 -\u0026gt; 5 -\u0026gt; 6 -\u0026gt; 7. Constraints m == grid.length n == grid[i].length 1 \u0026lt;= m, n \u0026lt;= 15 0 \u0026lt;= grid[i][j] \u0026lt;= 100 There are at most 25 cells containing gold. Solution class Solution { const vector\u0026lt;pair\u0026lt;int,int\u0026gt;\u0026gt;direc = {{1,0},{-1,0},{0,-1},{0,1}}; int checkIfAllNonZeros(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; grid){ int count = 0; for(int i=0; i\u0026lt;grid.size(); i++){ for(int j=0; j\u0026lt;grid[0].size(); j++){ if(grid[i][j] != 0) count += grid[i][j]; else return 0; } } return count; } int dfs(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; grid, int x, int y, const int\u0026amp; row, const int\u0026amp; col) { if(x\u0026lt;0 || y\u0026lt;0 || x\u0026gt;=row || y\u0026gt;= col || grid[x][y] == 0) return 0; int val = grid[x][y]; grid[x][y] = 0; int localMax = val; for(const pair\u0026lt;int,int\u0026gt;\u0026amp; it:direc) { localMax = max(localMax, val + dfs(grid,x + it.first,y + it.second,row,col)); } grid[x][y] = val; return localMax; } public: int getMaximumGold(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; grid) { std::ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); int row = grid.size(), col = grid[0].size(); int maxVal = 0; int count = checkIfAllNonZeros(grid); if(count) { return count; } for(int i = 0; i\u0026lt;row; i++) { for(int j = 0; j\u0026lt;col; j++) { if(grid[i][j] != 0) maxVal = max(maxVal, dfs(grid,i,j,row,col)); } } return maxVal; } }; Complexity Analysis Time Complexity: O(4^{mn}). Space Complexity: O(mn). Explanation 1. Intuition We can start from any cell in the grid and move in any direction (up, down, left, right) to collect gold. We can\u0026rsquo;t visit the same cell more than once. We can\u0026rsquo;t visit a cell with 0 gold. We need to find the maximum amount of gold we can collect. This constraints suggest that we need to explore every possible path to find the maximum gold. Hence we need DFS to explore every possible path. But we need to backtrack so that a path once explored does not stop from exploring other paths. 2. Implementation The dfs function is used to explore every possible path. The checkIfAllNonZeros function is used to check if all the cells have non-zero gold. The edge case of all cells having non-zero gold is handled separately by the checkIfAllNonZeros function. The direc vector is used to move in all four directions. 3. Functions dfs function is used to explore every possible path.\nThe input to the dfs function is the grid, the current cell\u0026rsquo;s row and column, and the total number of rows and columns.\nIf the current cell is out of bounds or has 0 gold, we return 0.\nElse we store the current cell\u0026rsquo;s gold in a variable val.\nThen the current cell\u0026rsquo;s gold is set to 0.\nWe store the current cell\u0026rsquo;s gold in a variable localMax.\nRecursively we move in all four directions and store the maximum gold in the localMax variable.\nIf all 4 sides are 0 then the localMax will be equal to the current cell\u0026rsquo;s gold.\nWe restore the current cell\u0026rsquo;s gold to the original value.\nThis is to let other paths explore the current cell.\nWe return the localMax variable.\ngetMaximumGold function is used to find the maximum gold.\nThe input to the getMaximumGold function is the grid.\nWe initialize the row and col variables to store the total number of rows and columns.\nWe initialize the maxVal variable to store the maximum gold.\nWe check if all the cells have non-zero gold by calling the checkIfAllNonZeros function.\nIf all the cells have non-zero gold then we return the sum of all the cells.\nElse we iterate over all the cells and call the dfs function to find the maximum gold.\nWe return the maxVal variable.\nThis problem enables us to apply DFS and backtracking to a 2 dimensional matrix.\n","permalink":"https://KTS-o7.github.io/blog/posts/problem-path-with-maximum-gold/","tags":["matrix","dfs","backtracking","cpp"],"title":"Problem Path With Maximum Gold"},{"categories":null,"content":"Problem Statement Link - Problem 861 Question You are given an m x n binary matrix grid.\nA move consists of choosing any row or column and toggling each value in that row or column (i.e., changing all 0\u0026rsquo;s to 1\u0026rsquo;s, and all 1\u0026rsquo;s to 0\u0026rsquo;s).\nEvery row of the matrix is interpreted as a binary number, and the score of the matrix is the sum of these numbers.\nReturn the highest possible score after making any number of moves (including zero moves).\nExample 1 $$ \\left[ \\begin{array}{cccc} 0 \u0026 0 \u0026 1 \u0026 1 \\\\ 1 \u0026 0 \u0026 1 \u0026 0 \\\\ 1 \u0026 1 \u0026 0 \u0026 0 \\\\ \\end{array} \\right] \\rightarrow \\left[ \\begin{array}{cccc} 1 \u0026 1 \u0026 0 \u0026 0 \\\\ 1 \u0026 0 \u0026 1 \u0026 0 \\\\ 1 \u0026 1 \u0026 0 \u0026 0 \\\\ \\end{array} \\right] $$ $$ \\left[ \\begin{array}{cccc} 1 \u0026 1 \u0026 1 \u0026 0 \\\\ 1 \u0026 0 \u0026 0 \u0026 0 \\\\ 1 \u0026 1 \u0026 1 \u0026 0 \\\\ \\end{array} \\right] \\rightarrow \\left[ \\begin{array}{cccc} 1 \u0026 1 \u0026 1 \u0026 1 \\\\ 1 \u0026 0 \u0026 0 \u0026 1 \\\\ 1 \u0026 1 \u0026 1 \u0026 1 \\\\ \\end{array} \\right] $$ Input: grid = [[0,0,1,1],[1,0,1,0],[1,1,0,0]] Output: 39 Explanation: 0b1111 + 0b1001 + 0b1111 = 15 + 9 + 15 = 39 Example 2 Input: grid = [[0]] Output: 1 Constraints m == grid.length n == grid[i].length 1 \u0026lt;= m, n \u0026lt;= 20 grid[i][j] is either 0 or 1. Solution class Solution { public: int matrixScore(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; grid) { std::ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); for(int row =0; row\u0026lt;grid.size(); row++) { if(grid[row][0] == 0) { for(int col = 0; col\u0026lt;grid[0].size(); col++) { grid[row][col] = !grid[row][col]; } } } int zero = 0, one = 0; for(int col=0; col\u0026lt;grid[0].size(); col++) { for(int row=0; row\u0026lt;grid.size(); row++) { if(grid[row][col] == 0) zero++; else one++; } vector\u0026lt;int\u0026gt;zeroCnt(grid[0].size(),0); vector\u0026lt;int\u0026gt;oneCnt(grid[0].size(),0); if(zero \u0026gt; one ) { for(int row=0; row\u0026lt;grid.size(); row++) { grid[row][col] = !grid[row][col]; } } one = 0; zero = 0; } int answer = 0; int temp,base; for(int row = 0; row\u0026lt;grid.size(); row++) { temp = 0; base = 0; for(int col = grid[0].size()-1; col\u0026gt;=0; col--) { if(grid[row][col]) { temp+= (int)pow(2,base); } base++; } answer+= temp; } return answer; } }; Complexity Analysis Time Complexity - O(n^2) Space Complexity - O(1) Explanation 1. Intuition The goal is to maximize the final score of the matrix ie. maximize the sum of the binary numbers formed by the rows of the matrix. We can make a binary number maximum by making the most significant bit of the number 1. Example : 0111 is always less than 1000. Then we can greedily make the other bits of the number into 1 provided it increases the sum of the binary numbers formed by the rows of the matrix. We can iterate over the columns and check if the number of 0's in the column is greater than the number of 1's then we can flip the column. This flipping is guranteed to increase the sum of the binary numbers formed by the rows of the matrix. Example : [[1,0,1],[1,0,0]], if we flip 2nd column then the matrix becomes [[1,1,1],[1,1,0]] and the sum of the binary numbers formed by the rows of the matrix is 7+6 = 13 which is greater than 5+4 = 9. 2. Implementation Iterate over the rows of the matrix and if the first element of the row is 0 then flip the row. Iterate over the columns of the matrix and if the number of 0's in the column is greater than the number of 1's then flip the column. Calculate the sum of the binary numbers formed by the rows of the matrix and return the sum. Shows the implementation of greedy technique to maximize the sum of the binary numbers formed by the rows of the matrix.\n","permalink":"https://KTS-o7.github.io/blog/posts/problem-score-after-flipping-matrix/","tags":["matrix","greedy","bit-manipulation","cpp"],"title":"Problem Score After Flipping Matrix"},{"categories":null,"content":"Problem Statement Link - Problem 2373 Question You are given an n x n integer matrix grid.\nGenerate an integer matrix maxLocal of size (n - 2) x (n - 2) such that:\nmaxLocal[i][j] is equal to the largest value of the 3 x 3 matrix in grid centered around row i + 1 and column j + 1. In other words, we want to find the largest value in every contiguous 3 x 3 matrix in grid.\nReturn the generated matrix.\nExample 1 $$ Input : grid = \\left[ \\begin{array}{cccc} 9 \u0026 9 \u0026 8 \u0026 1 \\\\ 5 \u0026 6 \u0026 2 \u0026 6 \\\\ 8 \u0026 2 \u0026 6 \u0026 4 \\\\ 6 \u0026 2 \u0026 2 \u0026 2 \\\\ \\end{array} \\right] Output : \\left[ \\begin{array}{cc} 9 \u0026 9 \\\\ 8 \u0026 6 \\\\ \\end{array} \\right] $$ Input: grid = [[9,9,8,1],[5,6,2,6],[8,2,6,4],[6,2,2,2]] Output: [[9,9],[8,6]] Explanation: The diagram above shows the original matrix and the generated matrix. Each value in the generated matrix corresponds to the largest value of a contiguous 3 x 3 matrix in grid. Example 2 $$ Input : grid = \\left[ \\begin{array}{cccccc} 1 \u0026 1 \u0026 1 \u0026 1 \u0026 1 \\\\ 1 \u0026 1 \u0026 1 \u0026 1 \u0026 1 \\\\ 1 \u0026 1 \u0026 2 \u0026 1 \u0026 1 \\\\ 1 \u0026 1 \u0026 1 \u0026 1 \u0026 1 \\\\ 1 \u0026 1 \u0026 1 \u0026 1 \u0026 1 \\\\ \\end{array} \\right] Output : \\left[ \\begin{array}{ccc} 2 \u0026 2 \u0026 2 \\\\ 2 \u0026 2 \u0026 2 \\\\ 2 \u0026 2 \u0026 2 \\\\ \\end{array} \\right] $$ Input: grid = [[1,1,1,1,1],[1,1,1,1,1],[1,1,2,1,1],[1,1,1,1,1],[1,1,1,1,1]] Output: [[2,2,2],[2,2,2],[2,2,2]] Explanation: Notice that the 2 is contained within every contiguous 3 x 3 matrix in grid. Constraints n == grid.length == grid[i].length 3 \u0026lt;= n \u0026lt;= 100 1 \u0026lt;= grid[i][j] \u0026lt;= 100 Solution class Solution { public: vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; largestLocal(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; grid) { vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;ans(grid.size()-2,vector\u0026lt;int\u0026gt;(grid[0].size()-2)); int locMax = INT_MIN; for(int row = 0; row \u0026lt; grid.size()-2; row++) { for(int col = 0; col \u0026lt; grid[0].size()-2; col++) { for(int i = row; i\u0026lt;row+3; i++) { for(int j = col; j\u0026lt;col+3; j++) locMax = max(locMax,grid[i][j]); } ans[row][col] = locMax; locMax = INT_MIN; } } return ans; } }; Complexity Analysis Time Complexity - O(n^2) Space Complexity - O(n^2) We are iterating over a 3x3 matrix each time thats 9 units and we have to visit each cell of the matrix so the time complexity is 9*n^2 which is O(n^2). The space complexity is O(n^2) as we are storing the result in a 2D vector of size (n-2) x (n-2). Explanation 1. Intuition We need to find the largest value in every contiguous 3 x 3 matrix in grid. We can iterate over the matrix and find the largest value in every 3 x 3 matrix. We can store the result in a new matrix and return it. To iterate over each contiguous 3 x 3 matrix, we need to iterate over the rows and columns of the matrix. 2. Implementation Initialize a 2D vector ans of size (n-2) x (n-2) to store the result. Initialize a variable locMax to store the maximum value in the 3 x 3 matrix. Iterate over the rows from 0 to n-2 and columns from 0 to n-2. This will give us the starting point of each 3 x 3 matrix. Iterate over the rows from row to row+3 and columns from col to col+3. This will give us the 3 x 3 matrix. Find the maximum value in the 3 x 3 matrix and store it in locMax. Store the maximum value in the result matrix ans[row][col]. Reset locMax to INT_MIN for the next 3 x 3 matrix. Return the result matrix ans. Intresting fact This problem closely simulates a very powerful ML algorithm in CNNs called as Max Pooling. Max pooling is a sample-based discretization process. The objective is to down-sample an input representation (image, hidden-layer output matrix, etc.), reducing its dimensionality and allowing for assumptions to be made about features contained in the sub-regions binned.\nKey terms in Max Pooling:\nPooling Layer: The pooling layer is a new layer added after the convolutional layer. It is used to reduce the spatial dimensions of the output volume. Max Pooling: Max pooling is a pooling operation that selects the maximum element from the region of the feature map covered by the filter. Thus, the output after max-pooling is the maximum value of the region covered by the filter. Filter: The filter is a matrix that is used to extract features from the input image. The filter is also known as a kernel. The filter is applied to the input image to produce the feature map. In this case, the filter is of size 3x3. Stride: The stride is the number of pixels by which the filter is moved over the input image. The stride is used to reduce the spatial dimensions of the output volume. In this case, the stride is 1. This problem simulates Max pooling. This shows a real world application of a DSA problem.\n","permalink":"https://KTS-o7.github.io/blog/posts/problem-largest-local-values-in-a-matrix/","tags":["matrix","2D array","cpp","vector"],"title":"Problem Largest Local Values in a Matrix"},{"categories":null,"content":"Problem Statement Link - Problem 786 Question You are given a sorted integer array arr containing 1 and prime numbers, where all the integers of arr are unique. You are also given an integer k.\nFor every i and j where 0 \u0026lt;= i \u0026lt; j \u0026lt; arr.length, we consider the fraction arr[i] / arr[j].\nReturn the kth smallest fraction considered. Return your answer as an array of integers of size 2, where answer[0] == arr[i] and answer[1] == arr[j].\nExample 1 Input: arr = [1,2,3,5], k = 3 Output: [2,5] Explanation: The fractions to be considered in sorted order are: 1/5, 1/3, 2/5, 1/2, 3/5, and 2/3. The third fraction is 2/5. Example 2 Input: arr = [1,7], k = 1 Output: [1,7] Constraints 2 \u0026lt;= arr.length \u0026lt;= 1000 1 \u0026lt;= arr[i] \u0026lt;= 3 * 10^4 arr[0] == 1 arr[i] is a prime number for i \u0026gt; 0. All the numbers of arr are unique and sorted in strictly increasing order. 1 \u0026lt;= k \u0026lt;= arr.length * (arr.length - 1) / 2 Solution class Solution { public: vector\u0026lt;int\u0026gt; kthSmallestPrimeFraction(vector\u0026lt;int\u0026gt;\u0026amp; arr, int k) { std::ios::sync_with_stdio(false); cin.tie(0); cout.tie(0); auto comparePair = [](const pair\u0026lt;int,int\u0026gt;\u0026amp; a,const pair\u0026lt;int,int\u0026gt;\u0026amp; b) { return a.first*b.second \u0026gt; b.first*a.second; }; priority_queue\u0026lt;pair\u0026lt;int,int\u0026gt;,vector\u0026lt;pair\u0026lt;int,int\u0026gt;\u0026gt;, decltype(comparePair)\u0026gt;minheap; for(int i = 0;i\u0026lt;arr.size();i++) { for(int j=i+1;j\u0026lt;arr.size();j++) { minheap.push(make_pair(arr[i],arr[j])); } } vector\u0026lt;int\u0026gt;answer(2,0); while(k\u0026gt;1 \u0026amp;\u0026amp; !minheap.empty()) { k--; minheap.pop(); } answer[0] = minheap.top().first; answer[1] = minheap.top().second; return answer; } }; Complexity Analysis Time Complexity - O(n^2logn) Space Complexity - O(n^2) Time complexity of adding a node to the heap is O(logn) and we are adding n*(n-1)/2 nodes to the heap. So, the time complexity is O(n^2logn). Space complexity is O(n^2) because we are storing n*(n-1)/2 pairs in the heap. Explanation 1. Intuition Since we need to find the kth smallest fraction, we can use a min heap to store the fractions. For that we need to have all the possible fractions in the heap. We can generate all the possible fractions by iterating over the array and adding the fractions to the heap. 2. Implementation We need to have a min heap whose contents are pairs of integers.\nEach pair {a,b} in the heap represents the fraction a/b.\nWe need to define a custom comparator for the heap, because by default the heap will be a max heap.\nThe function comparePair checks if the fraction a/b is smaller than the fraction c/d.\nA fraction \\(\\dfrac{a}{b}\\ \u003e \\dfrac{c}{d}\\ = a \\cdot d \u003e b \\cdot c\\) The comparator returns false if a*d \u0026gt; b*c, which means that the fraction a/b is smaller than c/d.\nSince by default the heap is a max heap, we need to make sure that the comparator returns false if a*d \u0026gt; b*c.\nThen the node which has {a,b} will move up in the heap than the node which has {c,d}.\nWe will iterate over the array and generate all the possible fractions.\nFirst loop will set the numerator and the second loop will set the denominator.\nWe will add the fraction to the heap.\nWe will pop k-1 elements from the heap.\nThe kth element will be the kth smallest fraction.\nWe will return the kth smallest fraction as answer[0] and answer[1].\nAdditional Notes This problem can also be solved using binary search. We can use binary search to find the fraction that is the kth smallest. class Solution { public: vector\u0026lt;int\u0026gt; kthSmallestPrimeFraction(vector\u0026lt;int\u0026gt;\u0026amp; arr, int k) { const int n = arr.size(); double l = 0.0; double r = 1.0; while (l \u0026lt; r) { const double m = (l + r) / 2.0; int fractionsNoGreaterThanM = 0; int p = 0; int q = 1; // For each index i, find the first index j s.t. arr[i] / arr[j] \u0026lt;= m, // so fractionsNoGreaterThanM for index i will be n - j. for (int i = 0, j = 1; i \u0026lt; n; ++i) { while (j \u0026lt; n \u0026amp;\u0026amp; arr[i] \u0026gt; m * arr[j]) ++j; if (j == n) break; fractionsNoGreaterThanM += n - j; if (p * arr[j] \u0026lt; q * arr[i]) { p = arr[i]; q = arr[j]; } } if (fractionsNoGreaterThanM == k) return {p, q}; if (fractionsNoGreaterThanM \u0026gt; k) r = m; else l = m; } throw; } }; The above code uses binary search to find the kth smallest fraction. We start with the range [0,1] and find the middle value. We iterate over the array and find the number of fractions that are less than or equal to m. If the number of fractions is equal to k, we return the fraction. If the number of fractions is greater than k, we reduce the range to [l,m]. If the number of fractions is less than k, we increase the range to [m,r]. Time Complexity - O(nlogn) Space Complexity - O(1) This problem helps us to understand how to use a min heap to solve a problem that requires finding the kth smallest element.\n","permalink":"https://KTS-o7.github.io/blog/posts/problem-k-th-smallest-prime-fraction/","tags":["priority-queue","binary-search","array","math","heap","cpp"],"title":"Problem K th Smallest Prime Fraction"},{"categories":null,"content":"Problem Statement Link - Problem 3075 Question You are given an array happiness of length n, and a positive integer k.\nThere are n children standing in a queue, where the ith child has happiness value happiness[i]. You want to select k children from these n children in k turns.\nIn each turn, when you select a child, the happiness value of all the children that have not been selected till now decreases by 1. Note that the happiness value cannot become negative and gets decremented only if it is positive.\nReturn the maximum sum of the happiness values of the selected children you can achieve by selecting k children.\nExample 1 Input: happiness = [1,2,3], k = 2 Output: 4 Explanation: We can pick 2 children in the following way: - Pick the child with the happiness value == 3. The happiness value of the remaining children becomes [0,1]. - Pick the child with the happiness value == 1. The happiness value of the remaining child becomes [0]. - Note that the happiness value cannot become less than 0. The sum of the happiness values of the selected children is 3 + 1 = 4. Example 2 Input: happiness = [1,1,1,1], k = 2 Output: 1 Explanation: We can pick 2 children in the following way: - Pick any child with the happiness value == 1. The happiness value of the remaining children becomes [0,0,0]. - Pick the child with the happiness value == 0. The happiness value of the remaining child becomes [0,0]. The sum of the happiness values of the selected children is 1 + 0 = 1. Example 3 Input: happiness = [2,3,4,5], k = 1 Output: 5 Explanation: We can pick 1 child in the following way: - Pick the child with the happiness value == 5. The happiness value of the remaining children becomes [1,2,3]. The sum of the happiness values of the selected children is 5. Constraints 1 \u0026lt;= n == happiness.length \u0026lt;= 2 * 10^5 1 \u0026lt;= happiness[i] \u0026lt;= 10^8 1 \u0026lt;= k \u0026lt;= n Solution class Solution { public: long long maximumHappinessSum(vector\u0026lt;int\u0026gt;\u0026amp; happiness, int k) { std::ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); priority_queue\u0026lt;int\u0026gt;heap; for(const int it:happiness) heap.push(it); long long count = 0; long long answer = 0; while(k\u0026gt;0 \u0026amp;\u0026amp; !heap.empty()) { answer = ((heap.top()-count)\u0026gt;=0)?answer+heap.top()-count:answer+0; heap.pop(); k--; count++; } return answer; } }; Complexity Analysis Time: O(nlogn) Space: O(n) Explanation 1. Intuition Since the order of selection does not matter, we can select the children with the highest happiness values first. this greedy approach will ensure that we maximize the sum of happiness values of the selected children. For this we need the array in sorted order, so we use a max heap to store the happiness values of the children. 2. Implementation We use a max heap to store the happiness values of the children. We iterate over the heap and select the children with the highest happiness values. We keep track of the count to ensure that the happiness value of the children that have not been selected decreases by 1. We will check if the difference between the happiness value and the count is greater than or equal to 0, if yes we add the difference to the answer, else we add 0. This makes sure that the happiness value does not become negative. We return the answer. Alternate Approach We can use the sorted vector to store the happiness values of the children. class Solution { public: long long maximumHappinessSum(vector\u0026lt;int\u0026gt;\u0026amp; happiness, int k) { ios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0); sort(happiness.begin(), happiness.end(), greater\u0026lt;int\u0026gt;()); long long sum = 0; for(int i = 0; i \u0026lt; k; i++) { happiness[i] = max(0, happiness[i]-i); sum += happiness[i]; } return sum; } }; This will be faster than the heap approach, as we do not need to maintain the heap.\nThis problem demonstrates the use of a max heap to solve a greedy problem.\n","permalink":"https://KTS-o7.github.io/blog/posts/problem-maximize-happiness-of-selected-children/","tags":["cpp","vector","heap","priority-queue","greedy"],"title":"Problem Maximize Happiness of Selected Children"},{"categories":null,"content":"Problem Statement Link - Problem 506 Question You are given an integer array score of size n, where score[i] is the score of the ith athlete in a competition. All the scores are guaranteed to be unique.\nThe athletes are placed based on their scores, where the 1st place athlete has the highest score, the 2nd place athlete has the 2nd highest score, and so on. The placement of each athlete determines their rank:\nThe 1st place athlete\u0026rsquo;s rank is \u0026quot;Gold Medal\u0026quot;. The 2nd place athlete\u0026rsquo;s rank is \u0026quot;Silver Medal\u0026quot;. The 3rd place athlete\u0026rsquo;s rank is \u0026quot;Bronze Medal\u0026quot;. For the 4th place to the nth place athlete, their rank is their placement number (i.e., the xth place athlete\u0026rsquo;s rank is \u0026quot;x\u0026quot;). Return an array answer of size n where answer[i] is the rank of the ith athlete.\nExample 1 Input: score = [5,4,3,2,1] Output: [\u0026#34;Gold Medal\u0026#34;,\u0026#34;Silver Medal\u0026#34;,\u0026#34;Bronze Medal\u0026#34;,\u0026#34;4\u0026#34;,\u0026#34;5\u0026#34;] Explanation: The placements are [1st, 2nd, 3rd, 4th, 5th]. Example 2 Input: score = [10,3,8,9,4] Output: [\u0026#34;Gold Medal\u0026#34;,\u0026#34;5\u0026#34;,\u0026#34;Bronze Medal\u0026#34;,\u0026#34;Silver Medal\u0026#34;,\u0026#34;4\u0026#34;] Explanation: The placements are [1st, 5th, 3rd, 2nd, 4th]. Constraints n == score.length 1 \u0026lt;= n \u0026lt;= 10^4 0 \u0026lt;= score[i] \u0026lt;= 10^6 All the values in score are unique. Solution class Solution { public: vector\u0026lt;string\u0026gt; findRelativeRanks(vector\u0026lt;int\u0026gt;\u0026amp; score) { auto comparePair = [](const pair\u0026lt;int,int\u0026gt;\u0026amp; a,const pair\u0026lt;int,int\u0026gt;\u0026amp; b) { return a.first\u0026lt;b.first; }; priority_queue\u0026lt;pair\u0026lt;int,int\u0026gt;, vector\u0026lt;pair\u0026lt;int,int\u0026gt;\u0026gt;, decltype(comparePair)\u0026gt; maxHeap; for(int i = 0;i\u0026lt;score.size();i++) maxHeap.push(make_pair(score[i],i)); vector\u0026lt;string\u0026gt;answer(score.size()); pair\u0026lt;int,int\u0026gt; holder; int place = 0; vector\u0026lt;string\u0026gt;places = {\u0026#34;Gold Medal\u0026#34;,\u0026#34;Silver Medal\u0026#34;,\u0026#34;Bronze Medal\u0026#34;}; while(!maxHeap.empty() \u0026amp;\u0026amp; place \u0026lt;3) { holder = maxHeap.top(); maxHeap.pop(); answer[holder.second] = places[place]; place++; } while(!maxHeap.empty()) { holder = maxHeap.top(); maxHeap.pop(); answer[holder.second] = to_string(++place); } return answer; } }; Complexity Analysis Time: O(nlogn) Space: O(n) Explanation 1. Intuition Since the scores need to be relatively ordered in decreasing order, along with the index which they occured. We can use a priority queue to store the scores and their index. We would need to have a custom comparator to compare the scores. This needs to be a max heap, so that we can get the highest score first. 2. Implementation We can use a priority queue to store the scores and their index. We can use a custom comparator to compare the scores. The custom comparator comparePair compares the pair\u0026lt;score,index_which_it_occured\u0026gt;. The lambda function comparePair does a.first\u0026lt;b.first because internally the priority queue is a max heap, hence the highest score would be at the top. The custom comparator ensures that the the pair with highest score is at the top of the heap. The keyword decltype is used to get the type of the lambda function. Priority queue needs to have a callable object as a comparator, hence we pass the lambda function comparePair. We will first push the scores and their index into the priority queue. We will have a vector of strings answer to store the ranks of the athletes. We will have a variable place to keep track of the rank. We will have a vector of strings places to store the medals of the athletes. We will iterate the priority queue until the place is less than 3. We will pop the top element from the priority queue. We will assign the rank to the athlete based on the place. 1st place athlete\u0026rsquo;s rank is \u0026quot;Gold Medal\u0026quot;. 2nd place athlete\u0026rsquo;s rank is \u0026quot;Silver Medal\u0026quot;. 3rd place athlete\u0026rsquo;s rank is \u0026quot;Bronze Medal\u0026quot;. We will increment the place after assigning the rank each time. Then check if there are any more athletes left. If there are any athletes left, assign the rank based on the place. The ranks is a string hence use the to_string function to convert the integer to string. Return the answer vector. Alternate Solution A solution with a map can be used to store the scores and their index. class Solution { public: vector\u0026lt;string\u0026gt; findRelativeRanks(vector\u0026lt;int\u0026gt;\u0026amp; score) { int n = score.size(); map\u0026lt;int, int\u0026gt; mp1; vector\u0026lt;string\u0026gt; result(n); for (int i = 0; i \u0026lt; n; i++) { mp1[score[i]] = i; } sort(score.begin(), score.end(), greater\u0026lt;int\u0026gt;()); for (int i = 0; i \u0026lt; n; i++) { if (i == 0) { result[mp1[score[i]]] = \u0026#34;Gold Medal\u0026#34;; } else if (i == 1) { result[mp1[score[i]]] = \u0026#34;Silver Medal\u0026#34;; } else if (i == 2) { result[mp1[score[i]]] = \u0026#34;Bronze Medal\u0026#34;; } else { result[mp1[score[i]]] = to_string(i + 1); } } return result; } }; Time Complexity: O(nlogn) Space Complexity: O(n) A solution with built in comparator for priority queue can be used. class Solution { public: vector\u0026lt;string\u0026gt; findRelativeRanks(vector\u0026lt;int\u0026gt;\u0026amp; score) { std::ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); priority_queue\u0026lt;pair\u0026lt;int,int\u0026gt;\u0026gt; maxHeap; for(int i = 0;i\u0026lt;score.size();i++) maxHeap.push(make_pair(score[i],i)); vector\u0026lt;string\u0026gt;answer(score.size()); pair\u0026lt;int,int\u0026gt; holder; int place = 0; vector\u0026lt;string\u0026gt;places = {\u0026#34;Gold Medal\u0026#34;,\u0026#34;Silver Medal\u0026#34;,\u0026#34;Bronze Medal\u0026#34;}; while(!maxHeap.empty() \u0026amp;\u0026amp; place \u0026lt;3) { holder = maxHeap.top(); maxHeap.pop(); answer[holder.second] = places[place]; place++; } while(!maxHeap.empty()) { holder = maxHeap.top(); maxHeap.pop(); answer[holder.second] = to_string(++place); } return answer; } }; This problem demonstrtaes the use of priority queue and custom comparators to solve the problem. The alternate solutions are also provided for the same problem.\n","permalink":"https://KTS-o7.github.io/blog/posts/problem-relative-ranks/","tags":["priority-queue","cpp","vector","strings","heap","custom-comparator"],"title":"Problem Relative Ranks"},{"categories":null,"content":"Problem Statement Link - Problem 2816 Question You are given the head of a non-empty linked list representing a non-negative integer without leading zeroes.\nReturn the head of the linked list after doubling it\nExample 1 Input graph LR A((1))--\u003eB((8)) B--\u003eC((9)) Output graph LR A((3))--\u003eB((7)) B--\u003eC((8)) Input: head = [1,8,9] Output: [3,7,8] Explanation: The figure above corresponds to the given linked list which represents the number 189. Hence, the returned linked list represents the number 189 * 2 = 378. Example 2 Input graph LR A((9))--\u003eB((9)) B--\u003eC((9)) Output graph LR A((1))--\u003eB((9)) B--\u003eC((9)) C--\u003eD((8)) Input: head = [9,9,9] Output: [1,9,9,8] Explanation: The figure above corresponds to the given linked list which represents the number 999. Hence, the returned linked list reprersents the number 999 * 2 = 1998. Constraints The number of nodes in the list is in the range [1, 10^4]. 0 \u0026lt;= Node.val \u0026lt;= 9 The input is generated such that the list represents a number that does not have leading zeros, except the number 0 itself. Solution /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ class Solution { public: ListNode* doubleIt(ListNode* head) { std::ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); stack\u0026lt;ListNode*\u0026gt;st; ListNode* temp = head; while(temp!=nullptr) { st.push(temp); temp=temp-\u0026gt;next; } int carry = 0, newVal = 0; while(!st.empty()) { temp = st.top(); st.pop(); newVal = 2*temp-\u0026gt;val + carry; carry = newVal/10; newVal = newVal%10; //cout\u0026lt;\u0026lt;carry\u0026lt;\u0026lt;newVal\u0026lt;\u0026lt;endl; temp-\u0026gt;val = newVal; } if(carry) { ListNode* newhead = new ListNode(carry,head); return newhead; } return head; } }; Complexity Time : O(n) Space : O(n) Explanation 1. Intuition We need to iterate the linked list in reverse order to double the number. From the last node we need to double the value and keep track of the carry. We can use a stack to store the nodes in reverse order. 2. Implementation Have a stack to store the nodes in reverse order. Push all the nodes into the stack. Pop the nodes from the stack and double the value of the node. Calculate the carry and the new value. Carry = NewValue/10, NewValue = NewValue%10. Update the value of the node. Do this for all the nodes. If there is a carry left after the last node, create a new node with the carry and return the new head. Else return the head of the linked list. This is a problem where FIFO principle of stack is used to reverse the linkedlist without manipulating any pointers.\n","permalink":"https://KTS-o7.github.io/blog/posts/problem-double-a-number-represented-as-a-linked-list/","tags":["linked-list","cpp","stack","pointers"],"title":"Problem Double a Number Represented as a Linked List"},{"categories":null,"content":"Problem Statement Link - Problem 2487 Question You are given the head of a linked list.\nRemove every node which has a node with a greater value anywhere to the right side of it.\nReturn the head of the modified linked list.\nExample 1 Input graph LR A((5))--\u003eB((2)) B--\u003eC((13)) C--\u003eD((3)) D--\u003eE((8)) Output graph LR A((13))--\u003eB((8)) Input: head = [5,2,13,3,8] Output: [13,8] Explanation: The nodes that should be removed are 5, 2 and 3. - Node 13 is to the right of node 5. - Node 13 is to the right of node 2. - Node 8 is to the right of node 3. Example 2 Input graph LR A((1))--\u003eB((1)) B--\u003eC((1)) C--\u003eD((1)) Output graph LR A((1))--\u003eB((1)) B--\u003eC((1)) C--\u003eD((1)) Input: head = [1,1,1,1] Output: [1,1,1,1] Explanation: Every node has value 1, so no nodes are removed. Constraints The number of the nodes in the given list is in the range [1, 10^5]. 1 \u0026lt;= Node.val \u0026lt;= 10^5 Solution /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ class Solution { public: ListNode* removeNodes(ListNode* head) { std::ios::sync_with_stdio(false); stack\u0026lt;ListNode*\u0026gt; st; ListNode* temp = head; while(temp != nullptr) { if(st.empty()) { st.push(temp); temp = temp-\u0026gt;next; } else { while(!st.empty() \u0026amp;\u0026amp; temp-\u0026gt;val \u0026gt; st.top()-\u0026gt;val) st.pop(); st.push(temp); temp=temp-\u0026gt;next; } } ListNode* newHead = nullptr; while(!st.empty()) { temp = st.top(); st.pop(); temp-\u0026gt;next = newHead; newHead = temp; } return newHead; } }; Complexity Time : O(n) Space : O(n) Explanation 1. Intuition We want to remove every node which has a node with value greater than current node to the right side of it. If we use a loop once and check for every node to the right side of it, it will take O(n^2) time. We can use a stack to store the nodes in decreasing order. This monotonically decreasing stack will help us to remove the nodes which have a greater value to the right side of it. The idea is to traverse the linked list and keep pushing the nodes into the stack. If the current node has a greater value than the top of the stack, we will pop the stack until the top of the stack has a greater value than the current node. After traversing the linked list, we will pop the stack and create a new linked list in reverse order. We need it in reverse order because the stack will have the nodes from the end of the linked list to the start of the linked list. 2. Implementation We will create a stack to store the nodes. We will traverse the linked list and push the nodes into the stack. If the stack is empty, we will push the current node into the stack. If the stack is not empty, we will check if the current node has a greater value than the top of the stack. If the current node has a greater value than the top of the stack, we will pop the stack until the top of the stack has a greater value than the current node. After traversing the linked list, we will pop the stack and create a new linked list in reverse order. We will return the head of the new linked list. Note: This problem showcases the use of monotonic stack\n","permalink":"https://KTS-o7.github.io/blog/posts/problem-remove-nodes-from-linked-list/","tags":["monotonic stack","linked list","pointers","stack","cpp"],"title":"Problem Remove Nodes From Linked List"},{"categories":null,"content":"Problem Statement Link - Problem 237 Question There is a singly-linked list head and we want to delete a node node in it.\nYou are given the node to be deleted node. You will not be given access to the first node of head.\nAll the values of the linked list are unique, and it is guaranteed that the given node node is not the last node in the linked list.\nDelete the given node. Note that by deleting the node, we mean that :\nThe value of the given node should not exist in the linked list. The number of nodes in the linked list should decrease by one. All the values before node should be in the same order. All the values after node should be in the same order. Example 1 Input: head = [4,5,1,9], node = 5 Output: [4,1,9] Explanation: You are given the second node with value 5, the linked list should become 4 -\u0026gt; 1 -\u0026gt; 9 after calling your function. Before deletion graph LR A((4)) --\u003e B((5)) B --\u003e C((1)) C --\u003e D((9)) After deletion graph LR A((4)) --\u003e C((1)) C --\u003e D((9)) Example 2 Input: head = [4,5,1,9], node = 1 Output: [4,5,9] Explanation: You are given the third node with value 1, the linked list should become 4 -\u0026gt; 5 -\u0026gt; 9 after calling your function. Before deletion graph LR A((4)) --\u003e B((5)) B --\u003e C((1)) C --\u003e D((9)) After deletion graph LR A((4)) --\u003e B((5)) B --\u003e D((9)) Constraints The number of the nodes in the given list is in the range [2, 1000]. -1000 \u0026lt;= Node.val \u0026lt;= 1000 The value of each node in the list is unique. The node to be deleted is in the list and is not a tail node. Solution /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */ class Solution { public: void deleteNode(ListNode* node) { ListNode* toDel = node-\u0026gt;next; node-\u0026gt;val = toDel-\u0026gt;val; node-\u0026gt;next = toDel-\u0026gt;next; delete toDel; } }; Complexity Analysis Time complexity : O(1) Space complexity : O(1) Explanation 1. Intuition We are given the node to be deleted and we can\u0026rsquo;t access the head of the linked list. We can\u0026rsquo;t delete the node directly as we don\u0026rsquo;t have access to the previous node. The idea is to copy the value of the next node to the current node and then delete the next node. 2. Code explained We store the next node in a temporary pointer toDel. We copy the value of the next node to the current node. We update the next pointer of the current node to the next of the next node. We delete the next node. This is a demonstration of Linked List manipulation.\n","permalink":"https://KTS-o7.github.io/blog/posts/problem-delete-node-in-a-linked-list/","tags":["linked list","pointers","leetcode","cpp"],"title":"Problem Delete Node in a Linked List"},{"categories":null,"content":"Problem Statement Link - Problem 881 Question You are given an array people where people[i] is the weight of the ith person, and an infinite number of boats where each boat can carry a maximum weight of limit. Each boat carries at most two people at the same time, provided the sum of the weight of those people is at most limit.\nReturn the minimum number of boats to carry every given person.\nExample 1 Input: people = [1,2], limit = 3 Output: 1 Explanation: 1 boat (1, 2) Example 2 Input: people = [3,2,2,1], limit = 3 Output: 3 Explanation: 3 boats (1, 2), (2) and (3) Example 3 Input: people = [3,5,3,4], limit = 5 Output: 4 Explanation: 4 boats (3), (3), (4), (5) Constraints 1 \u0026lt;= people.length \u0026lt;= 5 * 10^4 1 \u0026lt;= people[i] \u0026lt;= limit \u0026lt;= 3 * 10^4 Solution class Solution { public: int numRescueBoats(vector\u0026lt;int\u0026gt;\u0026amp; people, int limit) { std::ios_base::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); sort(people.begin(),people.end()); int left = 0,right = people.size()-1; int answer = 0; while(left\u0026lt;=right) { if(people[left]+people[right]\u0026gt;limit) { answer++; right--; } else { answer++; left++; right--; } } return answer; } }; Complexity Analysis Time : O(nlogn) Space : O(1) Explanation 1. Intuition We can see that the number of boats needed at minimum is n/2 where n is the number of people. Maximum number of boats needed is n where each person is in a separate boat. The idea is to give the heaviest person a boat and then check if the lightest person can be accomodated in the same boat. If the lightest person can be accomodated then we can move to the next lightest person. If the lightest person cannot be accomodated then we need to give the heaviest person a separate boat. 2. Code explained Sort the given vector. Initialize two pointers left and right at the start and end of the vector. Initialize the answer variable to 0. Iterate over the vector until left is less than or equal to right. If the sum of the weights of the people at left and right is greater than the limit then we need to give the person at right a separate boat. If the sum of the weights of the people at left and right is less than or equal to the limit then we can accomodate both the people in the same boat. Increment the answer variable accordingly. Return the answer variable. Note : This is a very simple problem and can be solved using the two pointer approach. The idea is to sort the given vector and then use two pointers to iterate over the vector. The time complexity of this approach is O(nlogn) where n is the number of people. The space complexity is O(1).\n","permalink":"https://KTS-o7.github.io/blog/posts/problem-boats-to-save-people/","tags":["two pointers","greedy","medium","leetcode","cpp"],"title":"Problem Boats to Save People"},{"categories":null,"content":"Problem Statement Link - Problem 2000 Question Given a 0-indexed string word and a character ch, reverse the segment of word that starts at index 0 and ends at the index of the first occurrence of ch (inclusive). If the character ch does not exist in word, do nothing.\nFor example, if word = \u0026quot;abcdefd\u0026quot; and ch = \u0026quot;d\u0026quot;, then you should reverse the segment that starts at 0 and ends at 3 (inclusive). The resulting string will be \u0026quot;dcbaefd\u0026quot;.\nReturn the resulting string.\nExample 1 Input: word = \u0026#34;abcdefd\u0026#34;, ch = \u0026#34;d\u0026#34; Output: \u0026#34;dcbaefd\u0026#34; Explanation: The first occurrence of \u0026#34;d\u0026#34; is at index 3. Reverse the part of word from 0 to 3 (inclusive), the resulting string is \u0026#34;dcbaefd\u0026#34;. Example 2 Input: word = \u0026#34;xyxzxe\u0026#34;, ch = \u0026#34;z\u0026#34; Output: \u0026#34;zxyxxe\u0026#34; Explanation: The first and only occurrence of \u0026#34;z\u0026#34; is at index 3. Reverse the part of word from 0 to 3 (inclusive), the resulting string is \u0026#34;zxyxxe\u0026#34;. Example 3 Input: word = \u0026#34;abcd\u0026#34;, ch = \u0026#34;z\u0026#34; Output: \u0026#34;abcd\u0026#34; Explanation: \u0026#34;z\u0026#34; does not exist in word. You should not do any reverse operation, the resulting string is \u0026#34;abcd\u0026#34;. Constraints 1 \u0026lt;= word.length \u0026lt;= 250 word consists of lowercase English letters. ch is a lowercase English letter. Solution class Solution { public: string reversePrefix(string word, char ch) { std::ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); int prefixIndex = INT_MIN; for(int i = 0;i\u0026lt;word.size();i++) { if(word[i]==ch) { prefixIndex = i; break; } } if(prefixIndex == INT_MIN)\\ return word; string ans = \u0026#34;\u0026#34;; for(int i = prefixIndex;i\u0026gt;=0;i--) ans += word[i]; for(int i = prefixIndex+1;i\u0026lt;word.size();i++) ans += word[i]; return ans; } }; Complexity Analysis Time - O(N) Space - O(N) Explanation Iterate through the string and check if the character ch exists in word. If not return the word as it is. If it exisits swap construct a new string ans in the following fashion. Append characters from prefixIndex to 0, then append characters from prefixIndex +1 to word.size(). Return the ans string. Note A solution using STL functions is as follows class Solution { public: string reversePrefix(string word, char ch) { int j = word.find(ch); if (j != -1) { reverse(word.begin(), word.begin() + j + 1); } return word; } }; Showcases the string manipulation.\n","permalink":"https://KTS-o7.github.io/blog/posts/problem-reverse-prefix-of-word/","tags":["leetcode","cpp","string"],"title":"Problem Reverse Prefix of Word"},{"categories":null,"content":"Problem Statement Link: Problem Minimum Falling Path Sum II Question Given an n x n integer matrix grid, return the minimum sum of a falling path with non-zero shifts.\nA falling path with non-zero shifts is a choice of exactly one element from each row of grid such that no two elements chosen in adjacent rows are in the same column.\nExample 1 1 2 3 4 5 6 7 8 9 Input: grid = [[1,2,3],[4,5,6],[7,8,9]] Output: 13 Explanation: The possible falling paths are: [1,5,9], [1,5,7], [1,6,7], [1,6,8], [2,4,8], [2,4,9], [2,6,7], [2,6,8], [3,4,8], [3,4,9], [3,5,7], [3,5,9] The falling path with the smallest sum is [1,5,7], so the answer is 13. Example 2 7 Input: grid = [[7]] Output: 7 Constraints n == grid.length == grid[i].length 1 \u0026lt;= n \u0026lt;= 200 -99 \u0026lt;= grid[i][j] \u0026lt;= 99 Solution class Solution { public: int minFallingPathSum(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; grid) { std::ios::sync_with_stdio(false); vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;dp(grid.size(),vector\u0026lt;int\u0026gt;(grid[0].size(),-1)); int rows = grid.size(), cols = grid[0].size(); int result = INT_MAX,temp; for(int j =0;j\u0026lt;cols;j++) dp[0][j] = grid[0][j]; for(int i = 1;i\u0026lt;rows;i++) { for(int j = 0;j\u0026lt;cols;j++) { temp = INT_MAX; for(int k = 0;k\u0026lt;cols;k++) { if(k!=j) { temp = min(temp, grid[i][j]+dp[i-1][k]); } } dp[i][j] = temp; } } for(int j = 0;j\u0026lt;cols;j++) result = min(result,dp[rows-1][j]); return result; } }; Complexity Time : O(Rows * Cols^2) Space : O(Rows * Cols) Explaination We will use a 2D dp array to store the minimum sum of the falling path ending at the cell dp[i][j]. The minimum falling path sum of first row will be same as first row of grid, hence we initialize dp[0][j] = grid[0][j]. For each cell dp[i][j] we will iterate over the previous row and find the minimum sum of the falling path ending at the cell dp[i][j]. We will find the minimmum sum of falling path which is not from the same column, hence we use if (k != j) condition. The answer will be the minimum value stored at the final row of dp matrix. This shows the usage of iterative DP to solve a grid problem.\nWe can also use Dijkstras Algorithm to solve the same problem.\n","permalink":"https://KTS-o7.github.io/blog/posts/problem-minimum-falling-path-sum-ii/","tags":["leetcode","dp","matrix"],"title":"Problem Minimum Falling Path Sum II"},{"categories":null,"content":"Problem Statement Link - Problem 1137 Question The Tribonacci sequence T(n) is defined as follows:\nT(0) = 0, T(1) = 1, T(2) = 1, and T(n+3) = T(n) + T(n+1) + T(n+2) for n \u0026gt;= 0.\nGiven n, return the value of T(n).\nNote to self This is a straight forward Recursion Problem. We can convert this to DP by using memoization. We will use an array to store the intermediate values to prevent repeated calculations. Example 1 Input: n = 4 Output: 4 Explanation: T_3 = 0 + 1 + 1 = 2 T_4 = 1 + 1 + 2 = 4 Example 2 Input: n = 25 Output: 1389537 Constraints 0 \u0026lt;= n \u0026lt;= 37 The answer is guaranteed to fit within a 32-bit integer, ie. answer \u0026lt;= 2^31 - 1. Solution class Solution { public: int tribonacci(int n) { if(!n) return 0; if(n==1) return 1; if(n==2) return 1; vector\u0026lt;int\u0026gt;dp(n+1); dp[0]= 0; dp[1] = 1; dp[2] = 1; for(int i=3;i\u0026lt;=n;i++) dp[i]= dp[i-1]+dp[i-2]+dp[i-3]; return dp[n]; } }; Complexity Time: O(n) Space: O(n) Explaination We will use the DP array to store the intermediate values. We will store 0,1,1 as first 3 values. Then inside a loop from 3 to n, we will calculate the value of T(n) using the formula T(n) = T(n-1) + T(n-2) + T(n-3). We will return the value of T(n) at the end. DP without using array It is still memoization class Solution { public: int tribonacci(int n) { if(!n) return 0; if(n==1) return 1; if(n==2) return 1; int a=0,b=1,c=1; for(int i=3;i\u0026lt;=n;i++) { int temp = a+b+c; a=b; b=c; c=temp; } return c; } }; Time: O(n)\nSpace: O(1)\nWe can also solve this using recursion but it will be slow as it will have a time complexity of O(3^n).\nWe can also solve this using matrix exponentiation but it will be an overkill for this problem.\nThis is a demonstration of memoization technique used in DP. With this we can convert a recursive method into dynamic programming method.\n","permalink":"https://KTS-o7.github.io/blog/posts/problem-nth-tribonacci-number/","tags":["leetcode","cpp","math","dp"],"title":"Problem Nth Tribonacci Number"},{"categories":null,"content":"Problem Statement Link - Problem 752 Question You have a lock in front of you with 4 circular wheels. Each wheel has 10 slots: '0', '1', '2', '3', '4', '5', '6', '7', '8', '9'. The wheels can rotate freely and wrap around: for example we can turn '9' to be '0', or '0' to be '9'. Each move consists of turning one wheel one slot.\nThe lock initially starts at '0000', a string representing the state of the 4 wheels.\nYou are given a list of deadends dead ends, meaning if the lock displays any of these codes, the wheels of the lock will stop turning and you will be unable to open it.\nGiven a target representing the value of the wheels that will unlock the lock, return the minimum total number of turns required to open the lock, or -1 if it is impossible.\nNote What they want us to find is the shortest path from the start node to the target node. The start node is '0000' and the target node is the target string. There will be an edge between two nodes if they differ by one digit. There are no outgoing edges from the deadend nodes. We can reach the target by changing the digits of the start node one by one, We can change them in either direction. The logic what we will be using is of BFS. BFS will always give us the shortest path. Note that the starting node also maybe a deadend. Example 1 Input: deadends = [\u0026#34;0201\u0026#34;,\u0026#34;0101\u0026#34;,\u0026#34;0102\u0026#34;,\u0026#34;1212\u0026#34;,\u0026#34;2002\u0026#34;], target = \u0026#34;0202\u0026#34; Output: 6 Explanation: A sequence of valid moves would be \u0026#34;0000\u0026#34; -\u0026gt; \u0026#34;1000\u0026#34; -\u0026gt; \u0026#34;1100\u0026#34; -\u0026gt; \u0026#34;1200\u0026#34; -\u0026gt; \u0026#34;1201\u0026#34; -\u0026gt; \u0026#34;1202\u0026#34; -\u0026gt; \u0026#34;0202\u0026#34;. Note that a sequence like \u0026#34;0000\u0026#34; -\u0026gt; \u0026#34;0001\u0026#34; -\u0026gt; \u0026#34;0002\u0026#34; -\u0026gt; \u0026#34;0102\u0026#34; -\u0026gt; \u0026#34;0202\u0026#34; would be invalid, because the wheels of the lock become stuck after the display becomes the dead end \u0026#34;0102\u0026#34;. Example 2 Input: deadends = [\u0026#34;8888\u0026#34;], target = \u0026#34;0009\u0026#34; Output: 1 Explanation: We can turn the last wheel in reverse to move from \u0026#34;0000\u0026#34; -\u0026gt; \u0026#34;0009\u0026#34;. Example 3 Input: deadends = [\u0026#34;8887\u0026#34;,\u0026#34;8889\u0026#34;,\u0026#34;8878\u0026#34;,\u0026#34;8898\u0026#34;,\u0026#34;8788\u0026#34;,\u0026#34;8988\u0026#34;,\u0026#34;7888\u0026#34;,\u0026#34;9888\u0026#34;], target = \u0026#34;8888\u0026#34; Output: -1 Explanation: We cannot reach the target without getting stuck. Constraints 1 \u0026lt;= deadends.length \u0026lt;= 500 deadends[i].length == 4 target.length == 4 target will not be in the list deadends. target and deadends[i] consist of digits only. Solution class Solution { public: int openLock(vector\u0026lt;string\u0026gt;\u0026amp; deadends, string target) { std::ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); unordered_set\u0026lt;string\u0026gt; dead(deadends.begin(),deadends.end()); if(dead.find(\u0026#34;0000\u0026#34;) != dead.end()) return -1; if(target == \u0026#34;0000\u0026#34;) return 0; int steps = 0; queue\u0026lt;string\u0026gt; q; q.push(\u0026#34;0000\u0026#34;); char actual; while(!q.empty()) { steps++; for(int size = q.size();size\u0026gt;0;size--) { string passwd = q.front(); q.pop(); for(int i= 0;i\u0026lt;4;i++) { actual = passwd[i]; passwd[i] = (passwd[i]==\u0026#39;9\u0026#39;)?\u0026#39;0\u0026#39;:passwd[i]+1; if(passwd == target) return steps; if(dead.find(passwd) == dead.end()) { q.push(passwd); dead.insert(passwd); } passwd[i] = actual; passwd[i] = (passwd[i]==\u0026#39;0\u0026#39;)?\u0026#39;9\u0026#39;:passwd[i]-1; if(passwd == target) return steps; if(dead.find(passwd) == dead.end()) { q.push(passwd); dead.insert(passwd); } passwd[i] = actual; } } } return -1; } }; Complexity Analysis Time complexity - O(10000) = O(1) - As we are iterating over all the possible combinations of the lock. Space complexity - O(10000) = O(1) - As we are storing all the possible combinations of the lock in the queue. Explanation First we create a unordered_set of deadends which will help us to check if the current combination is a deadend or not. We add all the deadends to the set. This makes sure that immidiate children of the deadends are not added to the queue. We check if the target is already a deadend or not. We check if the target is the start node itself. We create a queue and push the start node to it. We will keep track on number steps needed to reach the target. We will iterate over the current queue size. This is because we need to check only the current level nodes. We will iterate over the current node and change the digits one by one. If the child node is the target we return the number of steps. If child node is not target and is not a deadend or not visited till now, we will add it to the queue and mark it as visited. We will do the same for the other direction of the digit. If we are not able to reach the target we return -1. Note - This is a very good problem to understand the concept of BFS. We can also solve this problem using DFS but BFS is more efficient in this case.\n","permalink":"https://KTS-o7.github.io/blog/posts/problem-open-the-lock/","tags":["leetcode","cpp","bfs","graph"],"title":"Problem Open the Lock"},{"categories":null,"content":"Problem Statement Link - Problem 1971 Question There is a bi-directional graph with n vertices, where each vertex is labeled from 0 to n-1 (inclusive). The edges in the graph are represented as a 2D integer array edges, where each edges[i] = [ui, vi] denotes a bi-directional edge between vertex ui and vertex vi. Every vertex pair is connected by at most one edge, and no vertex has an edge to itself.\nYou want to determine if there is a valid path that exists from vertex source to vertex destination.\nGiven edges and the integers n, source, and destination, return true if there is a valid path from source to destination, or false otherwise.\nExample 1 graph LR A((0))\u003c--\u003eB((1)) B((1))\u003c--\u003eC((2)) C((2))\u003c--\u003eA((0)) Input: n = 3, edges = [[0,1],[1,2],[2,0]], source = 0, destination = 2 Output: true Explanation: There are two paths from vertex 0 to vertex 2: - 0  1  2 - 0  2 Example 2 graph TD A((0))\u003c--\u003eB((1)) C((2))\u003c--\u003eA((0)) D((3))\u003c--\u003eE((4)) E((4))\u003c--\u003eF((5)) F((5))\u003c--\u003eD((3)) Input: n = 6, edges = [[0,1],[0,2],[3,5],[5,4],[4,3]], source = 0, destination = 5 Output: false Explanation: There is no path from vertex 0 to vertex 5. Edge Case graph TD A((0)) Input: n = 1, edges = [], source = 0, destination = 0 Output = true Explanation: We are already in destination node. Constraints 1 \u0026lt;= n \u0026lt;= 2 * 10^5 0 \u0026lt;= edges.length \u0026lt;= 2 * 10^5 edges[i].length == 2 0 \u0026lt;= ui, vi \u0026lt;= n - 1 ui != vi 0 \u0026lt;= source, destination \u0026lt;= n - 1 There are no duplicate edges. There are no self edges Solution class Solution { public: bool dfs(unordered_map\u0026lt;int,vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; graph, int curr, int dest, unordered_set\u0026lt;int\u0026gt;\u0026amp; visited) { if(curr == dest) return true; visited.insert(curr); for(int next:graph[curr]) { if(visited.find(next) == visited.end()) if( dfs(graph,next,dest,visited)) return true; } return false; } bool validPath(int n, vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; edges, int source, int destination) { unordered_map\u0026lt;int, vector\u0026lt;int\u0026gt;\u0026gt; graph; for (const auto\u0026amp; edge : edges) { graph[edge[0]].push_back(edge[1]); graph[edge[1]].push_back(edge[0]); } unordered_set\u0026lt;int\u0026gt; visited; return dfs(graph, source, destination, visited); } }; Complexity Time : O(V + E), DFS visits each node and checks each edge atleast once. Space : O(V + E), the map stores each vertex V and corresponding edges E. Explanation We are given a vector of vector of int which denote the edges of a graph, the source vertex and destination vertex. Graph is bidirectional and there are no Self-Edges (From given). First we create an adjacency list graph which stores the vertex and the edges which is connected to them. We keep track of visited nodes in an unordered set visited. The DFS function then first checks if the current node is destination. If yes then we return true. Else we will append it to visited set, then try to find if any path exists from the connected nodes of current node. We will explore all the unvisited conntected nodes. If no path is found we return false. This shows the dfs method of graph traversal when a graph is represented in adjacency list format.\n","permalink":"https://KTS-o7.github.io/blog/posts/problem-find-if-path-exists-in-graph/","tags":["leetcode","cpp","graph","dfs"],"title":"Problem Find if Path Exists in Graph"},{"categories":null,"content":"Problem Statement Link - Problem 1992 Question You are given a 0-indexed m x n binary matrix land where a 0 represents a hectare of forested land and a 1 represents a hectare of farmland.\nTo keep the land organized, there are designated rectangular areas of hectares that consist entirely of farmland. These rectangular areas are called groups. No two groups are adjacent, meaning farmland in one group is not four-directionally adjacent to another farmland in a different group.\nland can be represented by a coordinate system where the top left corner of land is (0, 0) and the bottom right corner of land is (m-1, n-1). Find the coordinates of the top left and bottom right corner of each group of farmland. A group of farmland with a top left corner at (r1, c1) and a bottom right corner at (r2, c2) is represented by the 4-length array [r1, c1, r2, c2].\nReturn a 2D array containing the 4-length arrays described above for each group of farmland in land. If there are no groups of farmland, return an empty array. You may return the answer in any order.\nExample 1 Input: land = [[1,0,0],[0,1,1],[0,1,1]] Output: [[0,0,0,0],[1,1,2,2]] Explanation: The first group has a top left corner at land[0][0] and a bottom right corner at land[0][0]. The second group has a top left corner at land[1][1] and a bottom right corner at land[2][2]. Example 2 Input: land = [[1,1],[1,1]] Output: [[0,0,1,1]] Explanation: The first group has a top left corner at land[0][0] and a bottom right corner at land[1][1]. Example 3 Input: land = [[0]] Output: [] Explanation: There are no groups of farmland. Constraints m == land.length n == land[i].length 1 \u0026lt;= m, n \u0026lt;= 300 land consists of only 0's and 1's. Groups of farmland are rectangular in shape. Solution class Solution { public: void dfs(int i, int j, int\u0026amp; r1, int\u0026amp; c1, int\u0026amp; r2, int\u0026amp; c2,vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; land){ if(i \u0026lt; 0 || j \u0026lt; 0 || i \u0026gt;= land.size() || j \u0026gt;= land[0].size() || land[i][j] != 1) return; land[i][j] = 0; r1=min(r1, i), c1=min(c1, j), r2=max(r2, i), c2=max(c2, j); dfs(i+1,j, r1, c1, r2, c2, land); dfs(i,j+1, r1, c1, r2, c2, land); // No need to check top and left because it is given that it is always a rectangle. //dfs(i-1,j, r1, c1, r2, c2, land); //dfs(i,j-1, r1, c1, r2, c2, land); } vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; findFarmland(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; land) { std::ios::sync_with_stdio(false); int n=land.size(); int m=land[0].size(); int r1,r2,c1,c2; vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; answer; for(int i=0; i\u0026lt;n; i++) for(int j=0; j\u0026lt;m; j++){ if(land[i][j]==1){ r1=i, c1=j, r2=i, c2=j; dfs(i, j, r1, c1, r2, c2, land); answer.push_back({r1, c1, r2, c2}); } } return answer; } }; Complexity Time complexity : O(n*m) Space complexity : O(n*m) Explaination We will use the DFS technique to find the farmland. This is very similar to the number of islands problem. Check it Out . We will iterate over the matrix given only if the current cell is 1. In the dfs function, we will check if the current cell is in bounds and is 1. If it is, we will mark it as 0 and update the r1, c1, r2, c2 values. The r1, c1 will be the minimum values of the current cell and the r2, c2 will be the maximum values of the current cell. r1, c1 will be the top left corner and r2, c2 will be the bottom right corner of the farmland. We will call the dfs function recursively on the right and bottom cells. We need not to check the top and left cells because it is given that the farmland is always a rectangle. Once the dfs function is ended, we will push the r1, c1, r2, c2 values to the answer array. This demonstrates the use of DFS to traverse a 2D matrix and find the components or groups.\n","permalink":"https://KTS-o7.github.io/blog/posts/problem-find-all-groups-of-farmland/","tags":["leetcode","cpp","matrix","dfs"],"title":"Problem Find All Groups of Farmland"},{"categories":null,"content":"Problem Statement Link - Problem 200 Question Given an m x n 2D binary grid grid which represents a map of '1's (land) and '0's (water), return the number of islands.\nAn island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.\nNote to self They use characters not integers for 1 and 0. This is a classic dfs problem. Example 1 Input:\ngrid = [ [\u0026#34;1\u0026#34;,\u0026#34;1\u0026#34;,\u0026#34;1\u0026#34;,\u0026#34;1\u0026#34;,\u0026#34;0\u0026#34;], [\u0026#34;1\u0026#34;,\u0026#34;1\u0026#34;,\u0026#34;0\u0026#34;,\u0026#34;1\u0026#34;,\u0026#34;0\u0026#34;], [\u0026#34;1\u0026#34;,\u0026#34;1\u0026#34;,\u0026#34;0\u0026#34;,\u0026#34;0\u0026#34;,\u0026#34;0\u0026#34;], [\u0026#34;0\u0026#34;,\u0026#34;0\u0026#34;,\u0026#34;0\u0026#34;,\u0026#34;0\u0026#34;,\u0026#34;0\u0026#34;] ] Output:\n1 Example 2 Input:\ngrid = [ [\u0026#34;1\u0026#34;,\u0026#34;1\u0026#34;,\u0026#34;0\u0026#34;,\u0026#34;0\u0026#34;,\u0026#34;0\u0026#34;], [\u0026#34;1\u0026#34;,\u0026#34;1\u0026#34;,\u0026#34;0\u0026#34;,\u0026#34;0\u0026#34;,\u0026#34;0\u0026#34;], [\u0026#34;0\u0026#34;,\u0026#34;0\u0026#34;,\u0026#34;1\u0026#34;,\u0026#34;0\u0026#34;,\u0026#34;0\u0026#34;], [\u0026#34;0\u0026#34;,\u0026#34;0\u0026#34;,\u0026#34;0\u0026#34;,\u0026#34;1\u0026#34;,\u0026#34;1\u0026#34;] ] Output:\n3 Constraints m == grid.length n == grid[i].length 1 \u0026lt;= m, n \u0026lt;= 300 grid[i][j] is '0' or '1'. Solution class Solution { public: void checkIsland(int row,int col,vector\u0026lt;vector\u0026lt;char\u0026gt;\u0026gt;\u0026amp; grid) { if(row \u0026lt; 0 || col \u0026lt; 0 || row \u0026gt;= grid.size() || col \u0026gt;= grid[0].size() || grid[row][col] != \u0026#39;1\u0026#39;) return; grid[row][col] = \u0026#39;0\u0026#39;; checkIsland(row - 1, col,grid); checkIsland(row + 1, col,grid); checkIsland(row, col - 1,grid); checkIsland(row, col + 1,grid); } int numIslands(vector\u0026lt;vector\u0026lt;char\u0026gt;\u0026gt;\u0026amp; grid) { std::ios::sync_with_stdio(false); if(grid.empty() || grid[0].empty()) return 0; int rows = grid.size(); int cols = grid[0].size(); int islands = 0; for(int row = 0; row \u0026lt; rows; row++) { for(int col = 0; col \u0026lt; cols; col++) { if(grid[row][col] == \u0026#39;1\u0026#39;) { checkIsland(row, col,grid); islands++; } } } return islands; } }; Complexity Time : O(m*n) Space : O(m*n) Explaination We use the classic dfs approach to solve this. The logic is to check if the current cell is in bounds, and is '1'. If it is then the cell is marked as visited and call the function recursively on all the 4 directions. This recursive call checks if its adjacent cells are '0' or '1'. If they all are Zeroes then the call will end and the count of islands Islands will be incremented. If the current cell has an unvisited land neighbour then we extend our search there. So whenever the checkIsland function is ended by the base case it means it has found a valid island. This demonstrates the use of DFS to traverse a 2D matrix and find the components or groups.\n","permalink":"https://KTS-o7.github.io/blog/posts/problem-number-of-islands/","tags":["leetcode","cpp","matrix","dfs","array"],"title":"Problem Number of Islands"},{"categories":null,"content":"Problem Statement Link - Problem 463 Question You are given row x col grid representing a map where grid[i][j] = 1 represents land and grid[i][j] = 0 represents water.\nGrid cells are connected horizontally/vertically (not diagonally). The grid is completely surrounded by water, and there is exactly one island (i.e., one or more connected land cells).\nThe island doesn\u0026rsquo;t have \u0026ldquo;lakes\u0026rdquo;, meaning the water inside isn\u0026rsquo;t connected to the water around the island. One cell is a square with side length 1. The grid is rectangular, width and height don\u0026rsquo;t exceed 100. Determine the perimeter of the island.\nExample 1 Input: grid = [[0,1,0,0],[1,1,1,0],[0,1,0,0],[1,1,0,0]] Output: 16 Example 2 Input: grid = [[1]] Output: 4 Example 3 Input: grid = [[1,0]] Output: 4 Constraints row == grid.length col == grid[i].length 1 \u0026lt;= row, col \u0026lt;= 100 grid[i][j] is 0 or 1. There is exactly one island in grid. Solution class Solution { public: int islandPerimeter(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; grid) { int row = grid.size(), col = grid[0].size(); int peri = 0; for(int i=0;i\u0026lt;row;i++) { for(int j=0;j\u0026lt;col;j++) { if(grid[i][j]\u0026amp;1) { peri+=4; if(i\u0026gt;0 \u0026amp;\u0026amp; (grid[i-1][j] \u0026amp; 1)) peri-=2; if(j\u0026gt;0 \u0026amp;\u0026amp; (grid[i][j-1] \u0026amp; 1)) peri-=2; } } } return peri; } }; Complexity Time : O(N*M) Space : O(1) Explanation We iterate over the grid. If the cell is land then add 4 to the perimeter. Then we check the left and top of the cell. If they are land then we subtract 2 from the perimeter each. This is because when two lands are adjacent then they share a side and hence the perimeter is reduced by 2. Finally return the perimeter. This problem demonstrates the traversal of a matrix and checking the adjacent cells.\n","permalink":"https://KTS-o7.github.io/blog/posts/problem-island-perimeter/","tags":["leetcode","cpp","matrix","array"],"title":"Problem Island Perimeter"},{"categories":null,"content":"Problem Statement Link - Problem 988 Question You are given the root of a binary tree where each node has a value in the range [0, 25] representing the letters 'a' to 'z'.\nReturn the lexicographically smallest string that starts at a leaf of this tree and ends at the root.\nAs a reminder, any shorter prefix of a string is lexicographically smaller.\nFor example, \u0026quot;ab\u0026quot; is lexicographically smaller than \u0026quot;aba\u0026quot;. A leaf of a node is a node that has no children.\nExample 1 graph TD A[0] --\u003e B[1] A --\u003e C[2] B --\u003e D[3] B --\u003e E[4] C --\u003e F[3] C --\u003e G[4] Input: root = [0,1,2,3,4,3,4] Output: \u0026#34;dba\u0026#34; Example 2 graph TD A[25] --\u003e B[1] B --\u003e C[1] B --\u003e D[3] A --\u003e E[3] E --\u003e F[0] E --\u003e G[2] Input: root = [25,1,3,1,3,0,2] Output: \u0026#34;adz\u0026#34; Example 3 graph TD A[2] --\u003e B[2] A --\u003e C[1] B --\u003e D[1] C--\u003e E[0] D--\u003eF[0] Input: root = [2,2,1,null,1,0,null,0] Output: \u0026#34;abc\u0026#34; Important Edge Case graph TD A[0] --\u003e B[1] Input: root = [0,null,1] Output: \u0026#34;ba\u0026#34; Constraints The number of nodes in the tree is in the range [1, 8500]. 0 \u0026lt;= Node.val \u0026lt;= 25 Solution /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: void dfs(TreeNode* root, string str, string\u0026amp; smallest) { if(root == NULL) return; str+= char(\u0026#39;a\u0026#39;+root-\u0026gt;val); if(root-\u0026gt;left == NULL \u0026amp;\u0026amp; root-\u0026gt;right == NULL) { reverse(str.begin(),str.end()); if(smallest.empty() || str\u0026lt;smallest) smallest = str; reverse(str.begin(),str.end()); } dfs(root-\u0026gt;left,str,smallest); dfs(root-\u0026gt;right,str,smallest); } string smallestFromLeaf(TreeNode* root) { string small; dfs(root,\u0026#34;\u0026#34;,small); return small; } }; Complexity Time : O(N) Space : O(N) Explanation We perform a DFS traversal of the tree. First we start from the root of the tree and traverse down. We use a string called smallest to keep track of the smallest string from leafnode to rootnode found so far. Base Case for recursion - if root is NULL then just return. We append the character to the string str which is the character at the current node. String str actually stores the current path which is being developed from rootnode to leafnode. If we reach a leafnode then we reverse the str and check if its the lexographically smallest string which we saw so far. If yes then update the smallest. Then reverse str again so that we can continue exploring the path. Then we recursively explore the left subtree and right subtree looking for leaf nodes. This solution effectively demonstrates the usage of DFS to build a string from a tree following the given set of rules.\n","permalink":"https://KTS-o7.github.io/blog/posts/problem-smallest-string-starting-from-leaf/","tags":["leetcode","cpp","binary tree","dfs"],"title":"Problem Smallest String Starting From Leaf"},{"categories":null,"content":"Problem Statement Link - Problem 623 Question Given the root of a binary tree and two integers val and depth, add a row of nodes with value val at the given depth depth.\nNote that the root node is at depth 1.\nThe adding rule is:\nGiven the integer depth, for each not null tree node cur at the depth depth - 1, create two tree nodes with value val as cur's left subtree root and right subtree root. cur's original left subtree should be the left subtree of the new left subtree root. cur's original right subtree should be the right subtree of the new right subtree root. If depth == 1 that means there is no depth depth - 1 at all, then create a tree node with value val as the new root of the whole original tree, and the original tree is the new root\u0026rsquo;s left subtree. Example 1 Input: root = [4,2,6,3,1,5], val = 1, depth = 2 Output: [4,1,1,2,null,null,6,3,1,5] Example 2 Input: root = [4,2,null,3,1], val = 1, depth = 3 Output: [4,2,null,1,1,3,null,null,1] Constraints The number of nodes in the tree is in the range [1, 10^4]. The depth of the tree is in the range [1, 10^4]. -100 \u0026lt;= Node.val \u0026lt;= 100 -10^5 \u0026lt;= val \u0026lt;= 10^5 1 \u0026lt;= depth \u0026lt;= the depth of tree + 1 Solution /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(NULL), right(NULL) {} * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: void dfs(TreeNode* root,int val,int currDepth,int depth) { if(root == NULL) return; if(currDepth == depth-1) { root-\u0026gt;left = new TreeNode(val,root-\u0026gt;left,NULL); root-\u0026gt;right = new TreeNode(val,NULL,root-\u0026gt;right); return; } dfs(root-\u0026gt;left,val,currDepth+1,depth); dfs(root-\u0026gt;right,val,currDepth+1,depth); } TreeNode* addOneRow(TreeNode* root, int val, int depth) { if(depth == 1) { return new TreeNode(val,root,NULL); } dfs(root,val,1,depth); return root; } }; Complexity Time : O(N) Space : O(N) Explaination The provided code is a C++ solution for adding a new row of nodes with a given value to a binary tree at a specified depth. The solution uses a depth-first search (DFS) approach to traverse the tree and add the new nodes. Here\u0026rsquo;s a breakdown of the approach and logic:\nApproach Depth-First Search (DFS): The solution uses a DFS approach to traverse the binary tree. DFS is chosen because it allows us to explore each path from the root to a leaf node in a systematic manner, which is crucial for adding nodes at a specific depth.\nAdding Nodes at the Specified Depth: The dfs function is designed to add new nodes at the specified depth. It takes four parameters: the current node (root), the value to be added to the new nodes (val), the current depth (currDepth), and the target depth (depth).\nBase Case: The base case for the DFS is when the current depth equals the target depth minus one. At this point, the function creates new nodes with the given value and adds them as the left and right children of the current node. This effectively adds a new row of nodes at the specified depth.\nRecursive Calls: For each node, the function makes recursive calls to itself for the left and right children of the current node, incrementing the current depth by one. This allows the function to explore all nodes at the specified depth and add the new nodes.\nHandling the Root Node: If the target depth is 1, the addOneRow function creates a new root node with the given value and the original root as its right child. This effectively adds a new row of nodes at the root level.\nLogic DFS Traversal: The DFS traversal starts from the root and explores each path from the root to a leaf node. The traversal is controlled by the currDepth and depth parameters, ensuring that nodes are added only at the specified depth.\nAdding New Nodes: When the DFS reaches the specified depth, it adds new nodes with the given value as the left and right children of the current node. This is done by creating new TreeNode instances with the given value and the existing left and right children of the current node.\nReturning the Modified Tree: After adding the new nodes, the addOneRow function returns the modified tree. If the target depth is 1, it returns a new root node; otherwise, it returns the original root node.\nWhy This Approach Works ? Systematic Exploration: DFS ensures that we explore all nodes in the tree in a systematic manner, allowing us to add new nodes at the specified depth.\nDepth Control: By comparing currDepth with depth - 1, we can precisely control when to add new nodes, ensuring that they are added only at the specified depth.\nFlexibility: This approach can handle adding a new row of nodes at any depth within the tree, making it versatile for different scenarios.\nThis solution effectively demonstrates how to use DFS to modify a binary tree by adding a new row of nodes at a specified depth.\n","permalink":"https://KTS-o7.github.io/blog/posts/problem-add-one-row-to-tree/","tags":["leetcode","cpp","binary tree","dfs"],"title":"Problem Add One Row to Tree"},{"categories":null,"content":"Problem Statement Link - Problem 129 Question You are given the root of a binary tree containing digits from 0 to 9 only.\nEach root-to-leaf path in the tree represents a number.\nFor example, the root-to-leaf path 1 -\u0026gt; 2 -\u0026gt; 3 represents the number 123. Return the total sum of all root-to-leaf numbers. Test cases are generated so that the answer will fit in a 32-bit integer.\nA leaf node is a node with no children.\nExample 1 Input: root = [1,2,3] Output: 25 Explanation: The root-to-leaf path 1-\u0026gt;2 represents the number 12. The root-to-leaf path 1-\u0026gt;3 represents the number 13. Therefore, sum = 12 + 13 = 25. Example 2 Input: root = [4,9,0,5,1] Output: 1026 Explanation: The root-to-leaf path 4-\u0026gt;9-\u0026gt;5 represents the number 495. The root-to-leaf path 4-\u0026gt;9-\u0026gt;1 represents the number 491. The root-to-leaf path 4-\u0026gt;0 represents the number 40. Therefore, sum = 495 + 491 + 40 = 1026. Constraints Constraints: The number of nodes in the tree is in the range [1, 1000]. 0 \u0026lt;= Node.val \u0026lt;= 9 The depth of the tree will not exceed 10. Solution /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: int dfs(TreeNode* root, int path) { if(root==nullptr) return 0; path = path*10 + root-\u0026gt;val; if(root-\u0026gt;left == nullptr \u0026amp;\u0026amp; root-\u0026gt;right == nullptr) return path; return dfs(root-\u0026gt;left,path)+dfs(root-\u0026gt;right,path); } int sumNumbers(TreeNode* root) { return dfs(root,0); } }; Complexity Time : O(N) Space : O(N) Explanation Depth-First Search (DFS): The solution uses a depth-first search (DFS) approach to traverse the binary tree. DFS is chosen because it allows us to explore each path from the root to a leaf node in a systematic manner. Path Representation: As we traverse the tree, we keep track of the current path from the root to the current node. This path is represented as an integer, where each digit in the path corresponds to the value of a node in the path. Appending Node Values: For each node we visit, we append its value to the current path. This is done by multiplying the current path by 10 (to shift the digits to the left) and adding the node\u0026rsquo;s value. This operation effectively appends the node\u0026rsquo;s value to the end of the path. Base Case: The base case for the DFS is when we reach a leaf node (a node with no children). At this point, the path represents a number, and we return this number. Recursive Calls: For each non-leaf node, we make recursive calls to the DFS function for its left and right children, passing along the updated path. This allows us to explore all possible paths from the root to the leaves. Summing Numbers: The sum of all numbers represented by the paths from the root to the leaves is calculated by adding up the numbers returned by the recursive calls. Why this technique works ? Systematic Exploration: DFS ensures that we explore all possible paths from the root to the leaves in a systematic manner. This is crucial for calculating the sum of all numbers represented by these paths. Path Representation: By representing the path as an integer, we can easily append the value of each node to the path and calculate the number represented by the path. This representation is efficient and straightforward. Base Case Handling: The base case (reaching a leaf node) allows us to calculate the number represented by the path from the root to the leaf. This is the key step in solving the problem. Recursive Summing: By making recursive calls and summing the results, we ensure that the sum of all numbers represented by the paths from the root to the leaves is calculated correctly. This technique works because it systematically explores all paths from the root to the leaves of the binary tree, calculates the number represented by each path, and sums these numbers to find the total sum of all root-to-leaf numbers.\n","permalink":"https://KTS-o7.github.io/blog/posts/problem-sum-root-to-leaf-numbers/","tags":["leetcode","cpp","binary tree","dfs"],"title":"Problem Sum Root to Leaf Numbers"},{"categories":null,"content":"Raspberry Pi Zero Headless WiFi Setup Using Linux The following instructions will ultimately enable your Pi Zero to connect the WiFi to the router during every boot up, for a headless management.\nAppendix Prerequisite Enabling USB ethernet gadget mode on Pi Things to do once connected to Pi via USB 3.1. Enabling Internet access in Raspberry Pi 3.2. SSH into Raspberry Pi 3.3. Change locale settings 3.4. Update the OS 3.5. WiFi configuration for auto connecting to the access point 1. Prerequisite a) Raspberry Pi Zero v1.3\nb) USB data cable\nc) Raspbian OS\nd) A charger\ne) Manjaro Linux ( mentioned as host OS in this article )\nf) Raspberry Pi Imager tool\ng) SD card\n2. Enabling USB ether net gadget mode on Pi To enable the gadget mode, edit config.txt and cmdline.txt files in thebootpartition of the SD card.\\\nAdd dtoverlay=dwc2 to config.txt and\nAdd modules-load=dwc2,g_ether after the rootwait in cmdline.txt\nNote: Leave a space before and after the add modules-load=dwc2,g_ether line.\nMake an empty ssh file inside the same partition to enable SSH on boot.\nNow connect the USB data cable to the USB port of the Pi and plug it in the PC\u0026rsquo;s\nUSB port.\nImportant ! In the newer version of Raspbian there is no default pi user. We have to create it ourselves. Following steps will instruct you how to create that default user.\nCreate an empty file called userconf in the boot partition. touch useconf Now copy paste the following into the file pi:$6$/4.VdYgDm7RJ0qM1$FwXCeQgDKkqrOU3RIRuDSKpauAbBvP11msq9X58c8Que2l1Dwq3vdJMgiZlQSbEXGaY5esVHGBNbCxKLVNqZW1 The above will create a default user named pi and password is raspberry. You can change it later on. Without this you wont be able to SSH into the raspberry pi zero.\n3. Things to do once connected to Pi via USB 3.1 Enabling Internet access in Raspberry Pi Before enabling the internet, make sure that the Pi is connected as a USB gadget. Check sudo dmesg to confirm it. Look for lines similar to\n[ 343.853507] usb 1-4: new full-speed USB device number 3 using xhci_hcd [ 345.088725] usb 1-4: new high-speed USB device number 4 using xhci_hcd [ 345.243731] usb 1-4: New USB device found, idVendor=0525, idProduct=a4a2, bcdDevice= 5.10 [ 345.243740] usb 1-4: New USB device strings: Mfr=1, Product=2, SerialNumber=0 [ 345.243743] usb 1-4: Product: RNDIS/Ethernet Gadget [ 345.243746] usb 1-4: Manufacturer: Linux 5.10.17+ with 20980000.usb [ 345.463183] cdc_subset: probe of 1-4:1.0 failed with error -22 [ 345.464195] cdc_subset 1-4:1.1 usb0: register \u0026#39;cdc_subset\u0026#39; at usb-0000:03:00.3-4, Linux Device, e2:38:73:2d:01:39 [ 345.464248] usbcore: registered new interface driver cdc_subset [ 345.464297] cdc_ether: probe of 1-4:1.0 failed with error -16 [ 345.464337] usbcore: registered new interface driver cdc_ether [ 345.743346] bpfilter: Loaded bpfilter_umh pid 4407 [ 345.743711] Started bpfilter Note:\nGive at least 30 seconds or more before trying the dmesg\nIf the last line says something like\n[ 887.699447] usb 1-4: USB disconnect, device number 4 [ 887.699969] cdc_subset 1-4:1.1 usb0: unregister \u0026#39;cdc_subset\u0026#39; usb-0000:03:00.3-4, Linux Device that means the USB gadget mode was enabled and for some reason it got disconnected.\nIf you get this, check whether the USB cable was connected to the USB port on the Pi, not on the power port.\nOnce confirmed that everything is working fine, goto gnome-network-manager gui and change the USB ethernet\u0026rsquo;s IPv4 setting to shared to other computers.\nDisconnect and then reconnect the USB ethernet in the gui. If that doesn\u0026rsquo;t allow you to ssh into the Pi, you might also need to dis/reconnect the PCI ethernet option.\nNow you should be able to SSH into the Internet ready Pi.\n3.2 SSH into Raspberry Pi ssh pi@IP_ADDRESS password: raspberry replace the IP_ADDRESS with the IP Address of the Raspberry Pi zero.\n3.3 Change locale settings To eliminate perl: LC errors during package installations; sudo dpkg-reconfigure locales select the appropriate locale. For example; en_US.UTF-8\nSet timezone sudo ln -sf /usr/share/timezone/Country/Region /etc/localtime Expand file system expand the file system by using\nsudo raspi-config Now its time to shutdown the Pi to take effect the changes.\nReboot seems to be breaking the USB ether net gadget mode for some reason. Hence you need to shutdown the system.\nNote :\nCheck dmesg again . If you see some messages similar to below, reboot the host linux OS. Only then re-connect the Pi.\n[ 1131.255131] ------------[ cut here ]------------ [ 1131.255137] NETDEV WATCHDOG: enx1a4d1a4fb05e (cdc_ether): transmit queue 0 timed out [ 1131.255158] WARNING: CPU: 6 PID: 0 at net/sched/sch_generic.c:467 dev_watchdog+0x24f/0x260 . . . [ 1131.255535] ---[ end trace 07a143fded20143c ]--- I got this message even after a reboot. In that case disconnect the Pi and check the SD card for any file system errors. Reboot the host OS again and reconnect the Pi.\nThen follow the instructions on 3.1 .\n3.4 Update the OS It\u0026rsquo;s better to setup the WiFi connection and then upgrade the OS. It can be done by referring to\nsudo apt update sudo apt upgrade Shutdown and unplug or re plug the Pi. Follow 3.1 .\nNow we need to setup the WiFi to automatically connect to the access point during the next reboot.\n3.5 WiFi configuration for auto connecting to the access point You can add the WiFi Configuration using raspi-config after SSH-ing via USB.\narp -a This will display the IP address of the USB Ethernet ( usually its of form 10.42.0.x ) SSH into the board. Use the following command to enter the Raspi configuration\nsudo raspi-config Then connect to WiFi via the Connection options by entering the SSID and Password of your network.\nOR\nAdd these lines to /etc/wpa_supplicant/wpa_supplicant.conf;\ncountry=\u0026#34;your country code\u0026#34; network={ scan_ssid=1 ssid=\u0026#34;wifi name\u0026#34; psk=\u0026#34;wifi password\u0026#34; } Now shutdown the Pi. Connect the WiFi adapter and power cable then turn it on.\n","permalink":"https://KTS-o7.github.io/blog/posts/raspberrypi_zero_setup/","tags":["raspberrypi","setup"],"title":"RaspberryPi_Zero_Setup"},{"categories":null,"content":" Hello! I\u0026rsquo;m Krishnatejaswi S, a passionate Computer Science and Engineering student from Bangalore, India. My journey in the world of technology has been both challenging and rewarding, and I\u0026rsquo;m excited to share my experiences and projects with you.\nAcademic Background I\u0026rsquo;m currently pursuing my B.E degree in Computer Science and Engineering at RV College of Engineering, where I\u0026rsquo;ve had the opportunity to dive deep into various technologies and programming languages. My academic and research projects have allowed me to explore and master languages like Python and C++, and I\u0026rsquo;m always eager to learn and experiment with new technologies. Portfolio I\u0026rsquo;ve worked on a variety of projects that have helped me grow as a developer. Check out my portfolio to see some of my work. From web development to machine learning, I\u0026rsquo;ve tackled projects that challenge me and push my boundaries.\nPassion for Coding My passion for coding extends beyond the classroom. I\u0026rsquo;m particularly interested in exploring the cutting-edge technologies that are shaping the future of the tech industry. Some of the areas I\u0026rsquo;m currently exploring include:\nOpenCV: A facinating library to work with image processing in python. Ollama: A platform that\u0026rsquo;s revolutionizing the way we interact with AI. Generative AI: Creating content and models that can generate human-like text and images. JavaScript, Next.js: Building dynamic and responsive web applications. PyTorch: Diving into the world of machine learning and AI. Contact Me If you\u0026rsquo;re interested in my work, have questions, or would like to collaborate on a project, feel free to contact me . I\u0026rsquo;m always open to new connections and opportunities.\nThank you for visiting my About page. I look forward to sharing more of my journey with you!\nYou can also connect me via Linktree ","permalink":"https://KTS-o7.github.io/blog/about/about/","tags":null,"title":"About"},{"categories":null,"content":"What is this ? Lets find out !\nmermaid sequenceDiagram participant Alice participant Bob Alice-\u003e\u003eJohn: Hello John, how are you? loop Healthcheck John-\u003e\u003eJohn: Fight against hypochondria end Note right of John: Rational thoughts prevail! John--\u003e\u003eAlice: Great! John-\u003e\u003eBob: How about you? Bob--\u003e\u003eJohn: Jolly good! Code while(True): print(\u0026#34;Hello World\u0026#34;) ","permalink":"https://KTS-o7.github.io/blog/posts/newpost/","tags":["new","post"],"title":"New Post"},{"categories":null,"content":"This is the first post to test the things. Looks like its working !\n","permalink":"https://KTS-o7.github.io/blog/posts/firstpost/","tags":null,"title":"First Post"},{"categories":null,"content":"","permalink":"https://KTS-o7.github.io/blog/search/_index.es/","tags":null,"title":""},{"categories":null,"content":"","permalink":"https://KTS-o7.github.io/blog/search/_index.fr/","tags":null,"title":""},{"categories":null,"content":"","permalink":"https://KTS-o7.github.io/blog/search/_index.hi/","tags":null,"title":""},{"categories":null,"content":"","permalink":"https://KTS-o7.github.io/blog/search/_index.jp/","tags":null,"title":""},{"categories":null,"content":"","permalink":"https://KTS-o7.github.io/blog/search/_index.pl/","tags":null,"title":""},{"categories":null,"content":"","permalink":"https://KTS-o7.github.io/blog/search/_index.ru/","tags":null,"title":""},{"categories":null,"content":"","permalink":"https://KTS-o7.github.io/blog/search/_index.zh-cn/","tags":null,"title":""}]