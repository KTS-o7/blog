[{"categories":null,"content":"Problem Statement Link - Problem 237 Question There is a singly-linked list head and we want to delete a node node in it.\nYou are given the node to be deleted node. You will not be given access to the first node of head.\nAll the values of the linked list are unique, and it is guaranteed that the given node node is not the last node in the linked list.\nDelete the given node. Note that by deleting the node, we mean that :\nThe value of the given node should not exist in the linked list. The number of nodes in the linked list should decrease by one. All the values before node should be in the same order. All the values after node should be in the same order. Example 1 Input: head = [4,5,1,9], node = 5 Output: [4,1,9] Explanation: You are given the second node with value 5, the linked list should become 4 -\u0026gt; 1 -\u0026gt; 9 after calling your function. Before deletion graph LR A((4)) --\u003e B((5)) B --\u003e C((1)) C --\u003e D((9)) After deletion graph LR A((4)) --\u003e C((1)) C --\u003e D((9)) Example 2 Input: head = [4,5,1,9], node = 1 Output: [4,5,9] Explanation: You are given the third node with value 1, the linked list should become 4 -\u0026gt; 5 -\u0026gt; 9 after calling your function. Before deletion graph LR A((4)) --\u003e B((5)) B --\u003e C((1)) C --\u003e D((9)) After deletion graph LR A((4)) --\u003e B((5)) B --\u003e D((9)) Constraints The number of the nodes in the given list is in the range [2, 1000]. -1000 \u0026lt;= Node.val \u0026lt;= 1000 The value of each node in the list is unique. The node to be deleted is in the list and is not a tail node. Solution /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */ class Solution { public: void deleteNode(ListNode* node) { ListNode* toDel = node-\u0026gt;next; node-\u0026gt;val = toDel-\u0026gt;val; node-\u0026gt;next = toDel-\u0026gt;next; delete toDel; } }; Complexity Analysis Time complexity : O(1) Space complexity : O(1) Explanation 1. Intuition We are given the node to be deleted and we can\u0026rsquo;t access the head of the linked list. We can\u0026rsquo;t delete the node directly as we don\u0026rsquo;t have access to the previous node. The idea is to copy the value of the next node to the current node and then delete the next node. 2. Code explained We store the next node in a temporary pointer toDel. We copy the value of the next node to the current node. We update the next pointer of the current node to the next of the next node. We delete the next node. This is a demonstration of Linked List manipulation.\n","permalink":"https://KTS-o7.github.io/blog/posts/problem-delete-node-in-a-linked-list/","tags":["linked list","pointers","leetcode","cpp"],"title":"Problem Delete Node in a Linked List"},{"categories":null,"content":"Problem Statement Link - Problem 881 Question You are given an array people where people[i] is the weight of the ith person, and an infinite number of boats where each boat can carry a maximum weight of limit. Each boat carries at most two people at the same time, provided the sum of the weight of those people is at most limit.\nReturn the minimum number of boats to carry every given person.\nExample 1 Input: people = [1,2], limit = 3 Output: 1 Explanation: 1 boat (1, 2) Example 2 Input: people = [3,2,2,1], limit = 3 Output: 3 Explanation: 3 boats (1, 2), (2) and (3) Example 3 Input: people = [3,5,3,4], limit = 5 Output: 4 Explanation: 4 boats (3), (3), (4), (5) Constraints 1 \u0026lt;= people.length \u0026lt;= 5 * 10^4 1 \u0026lt;= people[i] \u0026lt;= limit \u0026lt;= 3 * 10^4 Solution class Solution { public: int numRescueBoats(vector\u0026lt;int\u0026gt;\u0026amp; people, int limit) { std::ios_base::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); sort(people.begin(),people.end()); int left = 0,right = people.size()-1; int answer = 0; while(left\u0026lt;=right) { if(people[left]+people[right]\u0026gt;limit) { answer++; right--; } else { answer++; left++; right--; } } return answer; } }; Complexity Analysis Time : O(nlogn) Space : O(1) Explanation 1. Intuition We can see that the number of boats needed at minimum is n/2 where n is the number of people. Maximum number of boats needed is n where each person is in a separate boat. The idea is to give the heaviest person a boat and then check if the lightest person can be accomodated in the same boat. If the lightest person can be accomodated then we can move to the next lightest person. If the lightest person cannot be accomodated then we need to give the heaviest person a separate boat. 2. Code explained Sort the given vector. Initialize two pointers left and right at the start and end of the vector. Initialize the answer variable to 0. Iterate over the vector until left is less than or equal to right. If the sum of the weights of the people at left and right is greater than the limit then we need to give the person at right a separate boat. If the sum of the weights of the people at left and right is less than or equal to the limit then we can accomodate both the people in the same boat. Increment the answer variable accordingly. Return the answer variable. Note : This is a very simple problem and can be solved using the two pointer approach. The idea is to sort the given vector and then use two pointers to iterate over the vector. The time complexity of this approach is O(nlogn) where n is the number of people. The space complexity is O(1).\n","permalink":"https://KTS-o7.github.io/blog/posts/problem-boats-to-save-people/","tags":["two pointers","greedy","medium","leetcode","cpp"],"title":"Problem Boats to Save People"},{"categories":null,"content":"Problem Statement Link - Problem 2000 Question Given a 0-indexed string word and a character ch, reverse the segment of word that starts at index 0 and ends at the index of the first occurrence of ch (inclusive). If the character ch does not exist in word, do nothing.\nFor example, if word = \u0026quot;abcdefd\u0026quot; and ch = \u0026quot;d\u0026quot;, then you should reverse the segment that starts at 0 and ends at 3 (inclusive). The resulting string will be \u0026quot;dcbaefd\u0026quot;.\nReturn the resulting string.\nExample 1 Input: word = \u0026#34;abcdefd\u0026#34;, ch = \u0026#34;d\u0026#34; Output: \u0026#34;dcbaefd\u0026#34; Explanation: The first occurrence of \u0026#34;d\u0026#34; is at index 3. Reverse the part of word from 0 to 3 (inclusive), the resulting string is \u0026#34;dcbaefd\u0026#34;. Example 2 Input: word = \u0026#34;xyxzxe\u0026#34;, ch = \u0026#34;z\u0026#34; Output: \u0026#34;zxyxxe\u0026#34; Explanation: The first and only occurrence of \u0026#34;z\u0026#34; is at index 3. Reverse the part of word from 0 to 3 (inclusive), the resulting string is \u0026#34;zxyxxe\u0026#34;. Example 3 Input: word = \u0026#34;abcd\u0026#34;, ch = \u0026#34;z\u0026#34; Output: \u0026#34;abcd\u0026#34; Explanation: \u0026#34;z\u0026#34; does not exist in word. You should not do any reverse operation, the resulting string is \u0026#34;abcd\u0026#34;. Constraints 1 \u0026lt;= word.length \u0026lt;= 250 word consists of lowercase English letters. ch is a lowercase English letter. Solution class Solution { public: string reversePrefix(string word, char ch) { std::ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); int prefixIndex = INT_MIN; for(int i = 0;i\u0026lt;word.size();i++) { if(word[i]==ch) { prefixIndex = i; break; } } if(prefixIndex == INT_MIN)\\ return word; string ans = \u0026#34;\u0026#34;; for(int i = prefixIndex;i\u0026gt;=0;i--) ans += word[i]; for(int i = prefixIndex+1;i\u0026lt;word.size();i++) ans += word[i]; return ans; } }; Complexity Analysis Time - O(N) Space - O(N) Explanation Iterate through the string and check if the character ch exists in word. If not return the word as it is. If it exisits swap construct a new string ans in the following fashion. Append characters from prefixIndex to 0, then append characters from prefixIndex +1 to word.size(). Return the ans string. Note A solution using STL functions is as follows class Solution { public: string reversePrefix(string word, char ch) { int j = word.find(ch); if (j != -1) { reverse(word.begin(), word.begin() + j + 1); } return word; } }; Showcases the string manipulation.\n","permalink":"https://KTS-o7.github.io/blog/posts/problem-reverse-prefix-of-word/","tags":["leetcode","cpp","string"],"title":"Problem Reverse Prefix of Word"},{"categories":null,"content":"Problem Statement Link: Problem Minimum Falling Path Sum II Question Given an n x n integer matrix grid, return the minimum sum of a falling path with non-zero shifts.\nA falling path with non-zero shifts is a choice of exactly one element from each row of grid such that no two elements chosen in adjacent rows are in the same column.\nExample 1 1 2 3 4 5 6 7 8 9 Input: grid = [[1,2,3],[4,5,6],[7,8,9]] Output: 13 Explanation: The possible falling paths are: [1,5,9], [1,5,7], [1,6,7], [1,6,8], [2,4,8], [2,4,9], [2,6,7], [2,6,8], [3,4,8], [3,4,9], [3,5,7], [3,5,9] The falling path with the smallest sum is [1,5,7], so the answer is 13. Example 2 7 Input: grid = [[7]] Output: 7 Constraints n == grid.length == grid[i].length 1 \u0026lt;= n \u0026lt;= 200 -99 \u0026lt;= grid[i][j] \u0026lt;= 99 Solution class Solution { public: int minFallingPathSum(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; grid) { std::ios::sync_with_stdio(false); vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;dp(grid.size(),vector\u0026lt;int\u0026gt;(grid[0].size(),-1)); int rows = grid.size(), cols = grid[0].size(); int result = INT_MAX,temp; for(int j =0;j\u0026lt;cols;j++) dp[0][j] = grid[0][j]; for(int i = 1;i\u0026lt;rows;i++) { for(int j = 0;j\u0026lt;cols;j++) { temp = INT_MAX; for(int k = 0;k\u0026lt;cols;k++) { if(k!=j) { temp = min(temp, grid[i][j]+dp[i-1][k]); } } dp[i][j] = temp; } } for(int j = 0;j\u0026lt;cols;j++) result = min(result,dp[rows-1][j]); return result; } }; Complexity Time : O(Rows * Cols^2) Space : O(Rows * Cols) Explaination We will use a 2D dp array to store the minimum sum of the falling path ending at the cell dp[i][j]. The minimum falling path sum of first row will be same as first row of grid, hence we initialize dp[0][j] = grid[0][j]. For each cell dp[i][j] we will iterate over the previous row and find the minimum sum of the falling path ending at the cell dp[i][j]. We will find the minimmum sum of falling path which is not from the same column, hence we use if (k != j) condition. The answer will be the minimum value stored at the final row of dp matrix. This shows the usage of iterative DP to solve a grid problem.\nWe can also use Dijkstras Algorithm to solve the same problem.\n","permalink":"https://KTS-o7.github.io/blog/posts/problem-minimum-falling-path-sum-ii/","tags":["leetcode","dp","matrix"],"title":"Problem Minimum Falling Path Sum II"},{"categories":null,"content":"Problem Statement Link - Problem 1137 Question The Tribonacci sequence T(n) is defined as follows:\nT(0) = 0, T(1) = 1, T(2) = 1, and T(n+3) = T(n) + T(n+1) + T(n+2) for n \u0026gt;= 0.\nGiven n, return the value of T(n).\nNote to self This is a straight forward Recursion Problem. We can convert this to DP by using memoization. We will use an array to store the intermediate values to prevent repeated calculations. Example 1 Input: n = 4 Output: 4 Explanation: T_3 = 0 + 1 + 1 = 2 T_4 = 1 + 1 + 2 = 4 Example 2 Input: n = 25 Output: 1389537 Constraints 0 \u0026lt;= n \u0026lt;= 37 The answer is guaranteed to fit within a 32-bit integer, ie. answer \u0026lt;= 2^31 - 1. Solution class Solution { public: int tribonacci(int n) { if(!n) return 0; if(n==1) return 1; if(n==2) return 1; vector\u0026lt;int\u0026gt;dp(n+1); dp[0]= 0; dp[1] = 1; dp[2] = 1; for(int i=3;i\u0026lt;=n;i++) dp[i]= dp[i-1]+dp[i-2]+dp[i-3]; return dp[n]; } }; Complexity Time: O(n) Space: O(n) Explaination We will use the DP array to store the intermediate values. We will store 0,1,1 as first 3 values. Then inside a loop from 3 to n, we will calculate the value of T(n) using the formula T(n) = T(n-1) + T(n-2) + T(n-3). We will return the value of T(n) at the end. DP without using array It is still memoization class Solution { public: int tribonacci(int n) { if(!n) return 0; if(n==1) return 1; if(n==2) return 1; int a=0,b=1,c=1; for(int i=3;i\u0026lt;=n;i++) { int temp = a+b+c; a=b; b=c; c=temp; } return c; } }; Time: O(n)\nSpace: O(1)\nWe can also solve this using recursion but it will be slow as it will have a time complexity of O(3^n).\nWe can also solve this using matrix exponentiation but it will be an overkill for this problem.\nThis is a demonstration of memoization technique used in DP. With this we can convert a recursive method into dynamic programming method.\n","permalink":"https://KTS-o7.github.io/blog/posts/problem-nth-tribonacci-number/","tags":["leetcode","cpp","math","dp"],"title":"Problem Nth Tribonacci Number"},{"categories":null,"content":"Problem Statement Link - Problem 752 Question You have a lock in front of you with 4 circular wheels. Each wheel has 10 slots: '0', '1', '2', '3', '4', '5', '6', '7', '8', '9'. The wheels can rotate freely and wrap around: for example we can turn '9' to be '0', or '0' to be '9'. Each move consists of turning one wheel one slot.\nThe lock initially starts at '0000', a string representing the state of the 4 wheels.\nYou are given a list of deadends dead ends, meaning if the lock displays any of these codes, the wheels of the lock will stop turning and you will be unable to open it.\nGiven a target representing the value of the wheels that will unlock the lock, return the minimum total number of turns required to open the lock, or -1 if it is impossible.\nNote What they want us to find is the shortest path from the start node to the target node. The start node is '0000' and the target node is the target string. There will be an edge between two nodes if they differ by one digit. There are no outgoing edges from the deadend nodes. We can reach the target by changing the digits of the start node one by one, We can change them in either direction. The logic what we will be using is of BFS. BFS will always give us the shortest path. Note that the starting node also maybe a deadend. Example 1 Input: deadends = [\u0026#34;0201\u0026#34;,\u0026#34;0101\u0026#34;,\u0026#34;0102\u0026#34;,\u0026#34;1212\u0026#34;,\u0026#34;2002\u0026#34;], target = \u0026#34;0202\u0026#34; Output: 6 Explanation: A sequence of valid moves would be \u0026#34;0000\u0026#34; -\u0026gt; \u0026#34;1000\u0026#34; -\u0026gt; \u0026#34;1100\u0026#34; -\u0026gt; \u0026#34;1200\u0026#34; -\u0026gt; \u0026#34;1201\u0026#34; -\u0026gt; \u0026#34;1202\u0026#34; -\u0026gt; \u0026#34;0202\u0026#34;. Note that a sequence like \u0026#34;0000\u0026#34; -\u0026gt; \u0026#34;0001\u0026#34; -\u0026gt; \u0026#34;0002\u0026#34; -\u0026gt; \u0026#34;0102\u0026#34; -\u0026gt; \u0026#34;0202\u0026#34; would be invalid, because the wheels of the lock become stuck after the display becomes the dead end \u0026#34;0102\u0026#34;. Example 2 Input: deadends = [\u0026#34;8888\u0026#34;], target = \u0026#34;0009\u0026#34; Output: 1 Explanation: We can turn the last wheel in reverse to move from \u0026#34;0000\u0026#34; -\u0026gt; \u0026#34;0009\u0026#34;. Example 3 Input: deadends = [\u0026#34;8887\u0026#34;,\u0026#34;8889\u0026#34;,\u0026#34;8878\u0026#34;,\u0026#34;8898\u0026#34;,\u0026#34;8788\u0026#34;,\u0026#34;8988\u0026#34;,\u0026#34;7888\u0026#34;,\u0026#34;9888\u0026#34;], target = \u0026#34;8888\u0026#34; Output: -1 Explanation: We cannot reach the target without getting stuck. Constraints 1 \u0026lt;= deadends.length \u0026lt;= 500 deadends[i].length == 4 target.length == 4 target will not be in the list deadends. target and deadends[i] consist of digits only. Solution class Solution { public: int openLock(vector\u0026lt;string\u0026gt;\u0026amp; deadends, string target) { std::ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); unordered_set\u0026lt;string\u0026gt; dead(deadends.begin(),deadends.end()); if(dead.find(\u0026#34;0000\u0026#34;) != dead.end()) return -1; if(target == \u0026#34;0000\u0026#34;) return 0; int steps = 0; queue\u0026lt;string\u0026gt; q; q.push(\u0026#34;0000\u0026#34;); char actual; while(!q.empty()) { steps++; for(int size = q.size();size\u0026gt;0;size--) { string passwd = q.front(); q.pop(); for(int i= 0;i\u0026lt;4;i++) { actual = passwd[i]; passwd[i] = (passwd[i]==\u0026#39;9\u0026#39;)?\u0026#39;0\u0026#39;:passwd[i]+1; if(passwd == target) return steps; if(dead.find(passwd) == dead.end()) { q.push(passwd); dead.insert(passwd); } passwd[i] = actual; passwd[i] = (passwd[i]==\u0026#39;0\u0026#39;)?\u0026#39;9\u0026#39;:passwd[i]-1; if(passwd == target) return steps; if(dead.find(passwd) == dead.end()) { q.push(passwd); dead.insert(passwd); } passwd[i] = actual; } } } return -1; } }; Complexity Analysis Time complexity - O(10000) = O(1) - As we are iterating over all the possible combinations of the lock. Space complexity - O(10000) = O(1) - As we are storing all the possible combinations of the lock in the queue. Explanation First we create a unordered_set of deadends which will help us to check if the current combination is a deadend or not. We add all the deadends to the set. This makes sure that immidiate children of the deadends are not added to the queue. We check if the target is already a deadend or not. We check if the target is the start node itself. We create a queue and push the start node to it. We will keep track on number steps needed to reach the target. We will iterate over the current queue size. This is because we need to check only the current level nodes. We will iterate over the current node and change the digits one by one. If the child node is the target we return the number of steps. If child node is not target and is not a deadend or not visited till now, we will add it to the queue and mark it as visited. We will do the same for the other direction of the digit. If we are not able to reach the target we return -1. Note - This is a very good problem to understand the concept of BFS. We can also solve this problem using DFS but BFS is more efficient in this case.\n","permalink":"https://KTS-o7.github.io/blog/posts/problem-open-the-lock/","tags":["leetcode","cpp","bfs","graph"],"title":"Problem Open the Lock"},{"categories":null,"content":"Problem Statement Link - Problem 1971 Question There is a bi-directional graph with n vertices, where each vertex is labeled from 0 to n-1 (inclusive). The edges in the graph are represented as a 2D integer array edges, where each edges[i] = [ui, vi] denotes a bi-directional edge between vertex ui and vertex vi. Every vertex pair is connected by at most one edge, and no vertex has an edge to itself.\nYou want to determine if there is a valid path that exists from vertex source to vertex destination.\nGiven edges and the integers n, source, and destination, return true if there is a valid path from source to destination, or false otherwise.\nExample 1 graph LR A((0))\u003c--\u003eB((1)) B((1))\u003c--\u003eC((2)) C((2))\u003c--\u003eA((0)) Input: n = 3, edges = [[0,1],[1,2],[2,0]], source = 0, destination = 2 Output: true Explanation: There are two paths from vertex 0 to vertex 2: - 0 → 1 → 2 - 0 → 2 Example 2 graph TD A((0))\u003c--\u003eB((1)) C((2))\u003c--\u003eA((0)) D((3))\u003c--\u003eE((4)) E((4))\u003c--\u003eF((5)) F((5))\u003c--\u003eD((3)) Input: n = 6, edges = [[0,1],[0,2],[3,5],[5,4],[4,3]], source = 0, destination = 5 Output: false Explanation: There is no path from vertex 0 to vertex 5. Edge Case graph TD A((0)) Input: n = 1, edges = [], source = 0, destination = 0 Output = true Explanation: We are already in destination node. Constraints 1 \u0026lt;= n \u0026lt;= 2 * 10^5 0 \u0026lt;= edges.length \u0026lt;= 2 * 10^5 edges[i].length == 2 0 \u0026lt;= ui, vi \u0026lt;= n - 1 ui != vi 0 \u0026lt;= source, destination \u0026lt;= n - 1 There are no duplicate edges. There are no self edges Solution class Solution { public: bool dfs(unordered_map\u0026lt;int,vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; graph, int curr, int dest, unordered_set\u0026lt;int\u0026gt;\u0026amp; visited) { if(curr == dest) return true; visited.insert(curr); for(int next:graph[curr]) { if(visited.find(next) == visited.end()) if( dfs(graph,next,dest,visited)) return true; } return false; } bool validPath(int n, vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; edges, int source, int destination) { unordered_map\u0026lt;int, vector\u0026lt;int\u0026gt;\u0026gt; graph; for (const auto\u0026amp; edge : edges) { graph[edge[0]].push_back(edge[1]); graph[edge[1]].push_back(edge[0]); } unordered_set\u0026lt;int\u0026gt; visited; return dfs(graph, source, destination, visited); } }; Complexity Time : O(V + E), DFS visits each node and checks each edge atleast once. Space : O(V + E), the map stores each vertex V and corresponding edges E. Explanation We are given a vector of vector of int which denote the edges of a graph, the source vertex and destination vertex. Graph is bidirectional and there are no Self-Edges (From given). First we create an adjacency list graph which stores the vertex and the edges which is connected to them. We keep track of visited nodes in an unordered set visited. The DFS function then first checks if the current node is destination. If yes then we return true. Else we will append it to visited set, then try to find if any path exists from the connected nodes of current node. We will explore all the unvisited conntected nodes. If no path is found we return false. This shows the dfs method of graph traversal when a graph is represented in adjacency list format.\n","permalink":"https://KTS-o7.github.io/blog/posts/problem-find-if-path-exists-in-graph/","tags":["leetcode","cpp","graph","dfs"],"title":"Problem Find if Path Exists in Graph"},{"categories":null,"content":"Problem Statement Link - Problem 1992 Question You are given a 0-indexed m x n binary matrix land where a 0 represents a hectare of forested land and a 1 represents a hectare of farmland.\nTo keep the land organized, there are designated rectangular areas of hectares that consist entirely of farmland. These rectangular areas are called groups. No two groups are adjacent, meaning farmland in one group is not four-directionally adjacent to another farmland in a different group.\nland can be represented by a coordinate system where the top left corner of land is (0, 0) and the bottom right corner of land is (m-1, n-1). Find the coordinates of the top left and bottom right corner of each group of farmland. A group of farmland with a top left corner at (r1, c1) and a bottom right corner at (r2, c2) is represented by the 4-length array [r1, c1, r2, c2].\nReturn a 2D array containing the 4-length arrays described above for each group of farmland in land. If there are no groups of farmland, return an empty array. You may return the answer in any order.\nExample 1 Input: land = [[1,0,0],[0,1,1],[0,1,1]] Output: [[0,0,0,0],[1,1,2,2]] Explanation: The first group has a top left corner at land[0][0] and a bottom right corner at land[0][0]. The second group has a top left corner at land[1][1] and a bottom right corner at land[2][2]. Example 2 Input: land = [[1,1],[1,1]] Output: [[0,0,1,1]] Explanation: The first group has a top left corner at land[0][0] and a bottom right corner at land[1][1]. Example 3 Input: land = [[0]] Output: [] Explanation: There are no groups of farmland. Constraints m == land.length n == land[i].length 1 \u0026lt;= m, n \u0026lt;= 300 land consists of only 0's and 1's. Groups of farmland are rectangular in shape. Solution class Solution { public: void dfs(int i, int j, int\u0026amp; r1, int\u0026amp; c1, int\u0026amp; r2, int\u0026amp; c2,vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; land){ if(i \u0026lt; 0 || j \u0026lt; 0 || i \u0026gt;= land.size() || j \u0026gt;= land[0].size() || land[i][j] != 1) return; land[i][j] = 0; r1=min(r1, i), c1=min(c1, j), r2=max(r2, i), c2=max(c2, j); dfs(i+1,j, r1, c1, r2, c2, land); dfs(i,j+1, r1, c1, r2, c2, land); // No need to check top and left because it is given that it is always a rectangle. //dfs(i-1,j, r1, c1, r2, c2, land); //dfs(i,j-1, r1, c1, r2, c2, land); } vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; findFarmland(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; land) { std::ios::sync_with_stdio(false); int n=land.size(); int m=land[0].size(); int r1,r2,c1,c2; vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; answer; for(int i=0; i\u0026lt;n; i++) for(int j=0; j\u0026lt;m; j++){ if(land[i][j]==1){ r1=i, c1=j, r2=i, c2=j; dfs(i, j, r1, c1, r2, c2, land); answer.push_back({r1, c1, r2, c2}); } } return answer; } }; Complexity Time complexity : O(n*m) Space complexity : O(n*m) Explaination We will use the DFS technique to find the farmland. This is very similar to the number of islands problem. Check it Out . We will iterate over the matrix given only if the current cell is 1. In the dfs function, we will check if the current cell is in bounds and is 1. If it is, we will mark it as 0 and update the r1, c1, r2, c2 values. The r1, c1 will be the minimum values of the current cell and the r2, c2 will be the maximum values of the current cell. r1, c1 will be the top left corner and r2, c2 will be the bottom right corner of the farmland. We will call the dfs function recursively on the right and bottom cells. We need not to check the top and left cells because it is given that the farmland is always a rectangle. Once the dfs function is ended, we will push the r1, c1, r2, c2 values to the answer array. This demonstrates the use of DFS to traverse a 2D matrix and find the components or groups.\n","permalink":"https://KTS-o7.github.io/blog/posts/problem-find-all-groups-of-farmland/","tags":["leetcode","cpp","matrix","dfs"],"title":"Problem Find All Groups of Farmland"},{"categories":null,"content":"Problem Statement Link - Problem 200 Question Given an m x n 2D binary grid grid which represents a map of '1's (land) and '0's (water), return the number of islands.\nAn island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.\nNote to self They use characters not integers for 1 and 0. This is a classic dfs problem. Example 1 Input:\ngrid = [ [\u0026#34;1\u0026#34;,\u0026#34;1\u0026#34;,\u0026#34;1\u0026#34;,\u0026#34;1\u0026#34;,\u0026#34;0\u0026#34;], [\u0026#34;1\u0026#34;,\u0026#34;1\u0026#34;,\u0026#34;0\u0026#34;,\u0026#34;1\u0026#34;,\u0026#34;0\u0026#34;], [\u0026#34;1\u0026#34;,\u0026#34;1\u0026#34;,\u0026#34;0\u0026#34;,\u0026#34;0\u0026#34;,\u0026#34;0\u0026#34;], [\u0026#34;0\u0026#34;,\u0026#34;0\u0026#34;,\u0026#34;0\u0026#34;,\u0026#34;0\u0026#34;,\u0026#34;0\u0026#34;] ] Output:\n1 Example 2 Input:\ngrid = [ [\u0026#34;1\u0026#34;,\u0026#34;1\u0026#34;,\u0026#34;0\u0026#34;,\u0026#34;0\u0026#34;,\u0026#34;0\u0026#34;], [\u0026#34;1\u0026#34;,\u0026#34;1\u0026#34;,\u0026#34;0\u0026#34;,\u0026#34;0\u0026#34;,\u0026#34;0\u0026#34;], [\u0026#34;0\u0026#34;,\u0026#34;0\u0026#34;,\u0026#34;1\u0026#34;,\u0026#34;0\u0026#34;,\u0026#34;0\u0026#34;], [\u0026#34;0\u0026#34;,\u0026#34;0\u0026#34;,\u0026#34;0\u0026#34;,\u0026#34;1\u0026#34;,\u0026#34;1\u0026#34;] ] Output:\n3 Constraints m == grid.length n == grid[i].length 1 \u0026lt;= m, n \u0026lt;= 300 grid[i][j] is '0' or '1'. Solution class Solution { public: void checkIsland(int row,int col,vector\u0026lt;vector\u0026lt;char\u0026gt;\u0026gt;\u0026amp; grid) { if(row \u0026lt; 0 || col \u0026lt; 0 || row \u0026gt;= grid.size() || col \u0026gt;= grid[0].size() || grid[row][col] != \u0026#39;1\u0026#39;) return; grid[row][col] = \u0026#39;0\u0026#39;; checkIsland(row - 1, col,grid); checkIsland(row + 1, col,grid); checkIsland(row, col - 1,grid); checkIsland(row, col + 1,grid); } int numIslands(vector\u0026lt;vector\u0026lt;char\u0026gt;\u0026gt;\u0026amp; grid) { std::ios::sync_with_stdio(false); if(grid.empty() || grid[0].empty()) return 0; int rows = grid.size(); int cols = grid[0].size(); int islands = 0; for(int row = 0; row \u0026lt; rows; row++) { for(int col = 0; col \u0026lt; cols; col++) { if(grid[row][col] == \u0026#39;1\u0026#39;) { checkIsland(row, col,grid); islands++; } } } return islands; } }; Complexity Time : O(m*n) Space : O(m*n) Explaination We use the classic dfs approach to solve this. The logic is to check if the current cell is in bounds, and is '1'. If it is then the cell is marked as visited and call the function recursively on all the 4 directions. This recursive call checks if its adjacent cells are '0' or '1'. If they all are Zeroes then the call will end and the count of islands Islands will be incremented. If the current cell has an unvisited land neighbour then we extend our search there. So whenever the checkIsland function is ended by the base case it means it has found a valid island. This demonstrates the use of DFS to traverse a 2D matrix and find the components or groups.\n","permalink":"https://KTS-o7.github.io/blog/posts/problem-number-of-islands/","tags":["leetcode","cpp","matrix","dfs","array"],"title":"Problem Number of Islands"},{"categories":null,"content":"Problem Statement Link - Problem 463 Question You are given row x col grid representing a map where grid[i][j] = 1 represents land and grid[i][j] = 0 represents water.\nGrid cells are connected horizontally/vertically (not diagonally). The grid is completely surrounded by water, and there is exactly one island (i.e., one or more connected land cells).\nThe island doesn\u0026rsquo;t have \u0026ldquo;lakes\u0026rdquo;, meaning the water inside isn\u0026rsquo;t connected to the water around the island. One cell is a square with side length 1. The grid is rectangular, width and height don\u0026rsquo;t exceed 100. Determine the perimeter of the island.\nExample 1 Input: grid = [[0,1,0,0],[1,1,1,0],[0,1,0,0],[1,1,0,0]] Output: 16 Example 2 Input: grid = [[1]] Output: 4 Example 3 Input: grid = [[1,0]] Output: 4 Constraints row == grid.length col == grid[i].length 1 \u0026lt;= row, col \u0026lt;= 100 grid[i][j] is 0 or 1. There is exactly one island in grid. Solution class Solution { public: int islandPerimeter(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; grid) { int row = grid.size(), col = grid[0].size(); int peri = 0; for(int i=0;i\u0026lt;row;i++) { for(int j=0;j\u0026lt;col;j++) { if(grid[i][j]\u0026amp;1) { peri+=4; if(i\u0026gt;0 \u0026amp;\u0026amp; (grid[i-1][j] \u0026amp; 1)) peri-=2; if(j\u0026gt;0 \u0026amp;\u0026amp; (grid[i][j-1] \u0026amp; 1)) peri-=2; } } } return peri; } }; Complexity Time : O(N*M) Space : O(1) Explanation We iterate over the grid. If the cell is land then add 4 to the perimeter. Then we check the left and top of the cell. If they are land then we subtract 2 from the perimeter each. This is because when two lands are adjacent then they share a side and hence the perimeter is reduced by 2. Finally return the perimeter. This problem demonstrates the traversal of a matrix and checking the adjacent cells.\n","permalink":"https://KTS-o7.github.io/blog/posts/problem-island-perimeter/","tags":["leetcode","cpp","matrix","array"],"title":"Problem Island Perimeter"},{"categories":null,"content":"Problem Statement Link - Problem 988 Question You are given the root of a binary tree where each node has a value in the range [0, 25] representing the letters 'a' to 'z'.\nReturn the lexicographically smallest string that starts at a leaf of this tree and ends at the root.\nAs a reminder, any shorter prefix of a string is lexicographically smaller.\nFor example, \u0026quot;ab\u0026quot; is lexicographically smaller than \u0026quot;aba\u0026quot;. A leaf of a node is a node that has no children.\nExample 1 graph TD A[0] --\u003e B[1] A --\u003e C[2] B --\u003e D[3] B --\u003e E[4] C --\u003e F[3] C --\u003e G[4] Input: root = [0,1,2,3,4,3,4] Output: \u0026#34;dba\u0026#34; Example 2 graph TD A[25] --\u003e B[1] B --\u003e C[1] B --\u003e D[3] A --\u003e E[3] E --\u003e F[0] E --\u003e G[2] Input: root = [25,1,3,1,3,0,2] Output: \u0026#34;adz\u0026#34; Example 3 graph TD A[2] --\u003e B[2] A --\u003e C[1] B --\u003e D[1] C--\u003e E[0] D--\u003eF[0] Input: root = [2,2,1,null,1,0,null,0] Output: \u0026#34;abc\u0026#34; Important Edge Case graph TD A[0] --\u003e B[1] Input: root = [0,null,1] Output: \u0026#34;ba\u0026#34; Constraints The number of nodes in the tree is in the range [1, 8500]. 0 \u0026lt;= Node.val \u0026lt;= 25 Solution /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: void dfs(TreeNode* root, string str, string\u0026amp; smallest) { if(root == NULL) return; str+= char(\u0026#39;a\u0026#39;+root-\u0026gt;val); if(root-\u0026gt;left == NULL \u0026amp;\u0026amp; root-\u0026gt;right == NULL) { reverse(str.begin(),str.end()); if(smallest.empty() || str\u0026lt;smallest) smallest = str; reverse(str.begin(),str.end()); } dfs(root-\u0026gt;left,str,smallest); dfs(root-\u0026gt;right,str,smallest); } string smallestFromLeaf(TreeNode* root) { string small; dfs(root,\u0026#34;\u0026#34;,small); return small; } }; Complexity Time : O(N) Space : O(N) Explanation We perform a DFS traversal of the tree. First we start from the root of the tree and traverse down. We use a string called smallest to keep track of the smallest string from leafnode to rootnode found so far. Base Case for recursion - if root is NULL then just return. We append the character to the string str which is the character at the current node. String str actually stores the current path which is being developed from rootnode to leafnode. If we reach a leafnode then we reverse the str and check if its the lexographically smallest string which we saw so far. If yes then update the smallest. Then reverse str again so that we can continue exploring the path. Then we recursively explore the left subtree and right subtree looking for leaf nodes. This solution effectively demonstrates the usage of DFS to build a string from a tree following the given set of rules.\n","permalink":"https://KTS-o7.github.io/blog/posts/problem-smallest-string-starting-from-leaf/","tags":["leetcode","cpp","binary tree","dfs"],"title":"Problem Smallest String Starting From Leaf"},{"categories":null,"content":"Problem Statement Link - Problem 623 Question Given the root of a binary tree and two integers val and depth, add a row of nodes with value val at the given depth depth.\nNote that the root node is at depth 1.\nThe adding rule is:\nGiven the integer depth, for each not null tree node cur at the depth depth - 1, create two tree nodes with value val as cur's left subtree root and right subtree root. cur's original left subtree should be the left subtree of the new left subtree root. cur's original right subtree should be the right subtree of the new right subtree root. If depth == 1 that means there is no depth depth - 1 at all, then create a tree node with value val as the new root of the whole original tree, and the original tree is the new root\u0026rsquo;s left subtree. Example 1 Input: root = [4,2,6,3,1,5], val = 1, depth = 2 Output: [4,1,1,2,null,null,6,3,1,5] Example 2 Input: root = [4,2,null,3,1], val = 1, depth = 3 Output: [4,2,null,1,1,3,null,null,1] Constraints The number of nodes in the tree is in the range [1, 10^4]. The depth of the tree is in the range [1, 10^4]. -100 \u0026lt;= Node.val \u0026lt;= 100 -10^5 \u0026lt;= val \u0026lt;= 10^5 1 \u0026lt;= depth \u0026lt;= the depth of tree + 1 Solution /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(NULL), right(NULL) {} * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: void dfs(TreeNode* root,int val,int currDepth,int depth) { if(root == NULL) return; if(currDepth == depth-1) { root-\u0026gt;left = new TreeNode(val,root-\u0026gt;left,NULL); root-\u0026gt;right = new TreeNode(val,NULL,root-\u0026gt;right); return; } dfs(root-\u0026gt;left,val,currDepth+1,depth); dfs(root-\u0026gt;right,val,currDepth+1,depth); } TreeNode* addOneRow(TreeNode* root, int val, int depth) { if(depth == 1) { return new TreeNode(val,root,NULL); } dfs(root,val,1,depth); return root; } }; Complexity Time : O(N) Space : O(N) Explaination The provided code is a C++ solution for adding a new row of nodes with a given value to a binary tree at a specified depth. The solution uses a depth-first search (DFS) approach to traverse the tree and add the new nodes. Here\u0026rsquo;s a breakdown of the approach and logic:\nApproach Depth-First Search (DFS): The solution uses a DFS approach to traverse the binary tree. DFS is chosen because it allows us to explore each path from the root to a leaf node in a systematic manner, which is crucial for adding nodes at a specific depth.\nAdding Nodes at the Specified Depth: The dfs function is designed to add new nodes at the specified depth. It takes four parameters: the current node (root), the value to be added to the new nodes (val), the current depth (currDepth), and the target depth (depth).\nBase Case: The base case for the DFS is when the current depth equals the target depth minus one. At this point, the function creates new nodes with the given value and adds them as the left and right children of the current node. This effectively adds a new row of nodes at the specified depth.\nRecursive Calls: For each node, the function makes recursive calls to itself for the left and right children of the current node, incrementing the current depth by one. This allows the function to explore all nodes at the specified depth and add the new nodes.\nHandling the Root Node: If the target depth is 1, the addOneRow function creates a new root node with the given value and the original root as its right child. This effectively adds a new row of nodes at the root level.\nLogic DFS Traversal: The DFS traversal starts from the root and explores each path from the root to a leaf node. The traversal is controlled by the currDepth and depth parameters, ensuring that nodes are added only at the specified depth.\nAdding New Nodes: When the DFS reaches the specified depth, it adds new nodes with the given value as the left and right children of the current node. This is done by creating new TreeNode instances with the given value and the existing left and right children of the current node.\nReturning the Modified Tree: After adding the new nodes, the addOneRow function returns the modified tree. If the target depth is 1, it returns a new root node; otherwise, it returns the original root node.\nWhy This Approach Works ? Systematic Exploration: DFS ensures that we explore all nodes in the tree in a systematic manner, allowing us to add new nodes at the specified depth.\nDepth Control: By comparing currDepth with depth - 1, we can precisely control when to add new nodes, ensuring that they are added only at the specified depth.\nFlexibility: This approach can handle adding a new row of nodes at any depth within the tree, making it versatile for different scenarios.\nThis solution effectively demonstrates how to use DFS to modify a binary tree by adding a new row of nodes at a specified depth.\n","permalink":"https://KTS-o7.github.io/blog/posts/problem-add-one-row-to-tree/","tags":["leetcode","cpp","binary tree","dfs"],"title":"Problem Add One Row to Tree"},{"categories":null,"content":"Problem Statement Link - Problem 129 Question You are given the root of a binary tree containing digits from 0 to 9 only.\nEach root-to-leaf path in the tree represents a number.\nFor example, the root-to-leaf path 1 -\u0026gt; 2 -\u0026gt; 3 represents the number 123. Return the total sum of all root-to-leaf numbers. Test cases are generated so that the answer will fit in a 32-bit integer.\nA leaf node is a node with no children.\nExample 1 Input: root = [1,2,3] Output: 25 Explanation: The root-to-leaf path 1-\u0026gt;2 represents the number 12. The root-to-leaf path 1-\u0026gt;3 represents the number 13. Therefore, sum = 12 + 13 = 25. Example 2 Input: root = [4,9,0,5,1] Output: 1026 Explanation: The root-to-leaf path 4-\u0026gt;9-\u0026gt;5 represents the number 495. The root-to-leaf path 4-\u0026gt;9-\u0026gt;1 represents the number 491. The root-to-leaf path 4-\u0026gt;0 represents the number 40. Therefore, sum = 495 + 491 + 40 = 1026. Constraints Constraints: The number of nodes in the tree is in the range [1, 1000]. 0 \u0026lt;= Node.val \u0026lt;= 9 The depth of the tree will not exceed 10. Solution /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: int dfs(TreeNode* root, int path) { if(root==nullptr) return 0; path = path*10 + root-\u0026gt;val; if(root-\u0026gt;left == nullptr \u0026amp;\u0026amp; root-\u0026gt;right == nullptr) return path; return dfs(root-\u0026gt;left,path)+dfs(root-\u0026gt;right,path); } int sumNumbers(TreeNode* root) { return dfs(root,0); } }; Complexity Time : O(N) Space : O(N) Explanation Depth-First Search (DFS): The solution uses a depth-first search (DFS) approach to traverse the binary tree. DFS is chosen because it allows us to explore each path from the root to a leaf node in a systematic manner. Path Representation: As we traverse the tree, we keep track of the current path from the root to the current node. This path is represented as an integer, where each digit in the path corresponds to the value of a node in the path. Appending Node Values: For each node we visit, we append its value to the current path. This is done by multiplying the current path by 10 (to shift the digits to the left) and adding the node\u0026rsquo;s value. This operation effectively appends the node\u0026rsquo;s value to the end of the path. Base Case: The base case for the DFS is when we reach a leaf node (a node with no children). At this point, the path represents a number, and we return this number. Recursive Calls: For each non-leaf node, we make recursive calls to the DFS function for its left and right children, passing along the updated path. This allows us to explore all possible paths from the root to the leaves. Summing Numbers: The sum of all numbers represented by the paths from the root to the leaves is calculated by adding up the numbers returned by the recursive calls. Why this technique works ? Systematic Exploration: DFS ensures that we explore all possible paths from the root to the leaves in a systematic manner. This is crucial for calculating the sum of all numbers represented by these paths. Path Representation: By representing the path as an integer, we can easily append the value of each node to the path and calculate the number represented by the path. This representation is efficient and straightforward. Base Case Handling: The base case (reaching a leaf node) allows us to calculate the number represented by the path from the root to the leaf. This is the key step in solving the problem. Recursive Summing: By making recursive calls and summing the results, we ensure that the sum of all numbers represented by the paths from the root to the leaves is calculated correctly. This technique works because it systematically explores all paths from the root to the leaves of the binary tree, calculates the number represented by each path, and sums these numbers to find the total sum of all root-to-leaf numbers.\n","permalink":"https://KTS-o7.github.io/blog/posts/problem-sum-root-to-leaf-numbers/","tags":["leetcode","cpp","binary tree","dfs"],"title":"Problem Sum Root to Leaf Numbers"},{"categories":null,"content":"Raspberry Pi Zero Headless WiFi Setup Using Linux The following instructions will ultimately enable your Pi Zero to connect the WiFi to the router during every boot up, for a headless management.\nAppendix Prerequisite Enabling USB ethernet gadget mode on Pi Things to do once connected to Pi via USB 3.1. Enabling Internet access in Raspberry Pi 3.2. SSH into Raspberry Pi 3.3. Change locale settings 3.4. Update the OS 3.5. WiFi configuration for auto connecting to the access point 1. Prerequisite a) Raspberry Pi Zero v1.3\nb) USB data cable\nc) Raspbian OS\nd) A charger\ne) Manjaro Linux ( mentioned as host OS in this article )\nf) Raspberry Pi Imager tool\ng) SD card\n2. Enabling USB ether net gadget mode on Pi To enable the gadget mode, edit config.txt and cmdline.txt files in thebootpartition of the SD card.\\\nAdd dtoverlay=dwc2 to config.txt and\nAdd modules-load=dwc2,g_ether after the rootwait in cmdline.txt\nNote: Leave a space before and after the add modules-load=dwc2,g_ether line.\nMake an empty ssh file inside the same partition to enable SSH on boot.\nNow connect the USB data cable to the USB port of the Pi and plug it in the PC\u0026rsquo;s\nUSB port.\nImportant ! In the newer version of Raspbian there is no default pi user. We have to create it ourselves. Following steps will instruct you how to create that default user.\nCreate an empty file called userconf in the boot partition. touch useconf Now copy paste the following into the file pi:$6$/4.VdYgDm7RJ0qM1$FwXCeQgDKkqrOU3RIRuDSKpauAbBvP11msq9X58c8Que2l1Dwq3vdJMgiZlQSbEXGaY5esVHGBNbCxKLVNqZW1 The above will create a default user named pi and password is raspberry. You can change it later on. Without this you wont be able to SSH into the raspberry pi zero.\n3. Things to do once connected to Pi via USB 3.1 Enabling Internet access in Raspberry Pi Before enabling the internet, make sure that the Pi is connected as a USB gadget. Check sudo dmesg to confirm it. Look for lines similar to\n[ 343.853507] usb 1-4: new full-speed USB device number 3 using xhci_hcd [ 345.088725] usb 1-4: new high-speed USB device number 4 using xhci_hcd [ 345.243731] usb 1-4: New USB device found, idVendor=0525, idProduct=a4a2, bcdDevice= 5.10 [ 345.243740] usb 1-4: New USB device strings: Mfr=1, Product=2, SerialNumber=0 [ 345.243743] usb 1-4: Product: RNDIS/Ethernet Gadget [ 345.243746] usb 1-4: Manufacturer: Linux 5.10.17+ with 20980000.usb [ 345.463183] cdc_subset: probe of 1-4:1.0 failed with error -22 [ 345.464195] cdc_subset 1-4:1.1 usb0: register \u0026#39;cdc_subset\u0026#39; at usb-0000:03:00.3-4, Linux Device, e2:38:73:2d:01:39 [ 345.464248] usbcore: registered new interface driver cdc_subset [ 345.464297] cdc_ether: probe of 1-4:1.0 failed with error -16 [ 345.464337] usbcore: registered new interface driver cdc_ether [ 345.743346] bpfilter: Loaded bpfilter_umh pid 4407 [ 345.743711] Started bpfilter Note:\nGive at least 30 seconds or more before trying the dmesg\nIf the last line says something like\n[ 887.699447] usb 1-4: USB disconnect, device number 4 [ 887.699969] cdc_subset 1-4:1.1 usb0: unregister \u0026#39;cdc_subset\u0026#39; usb-0000:03:00.3-4, Linux Device that means the USB gadget mode was enabled and for some reason it got disconnected.\nIf you get this, check whether the USB cable was connected to the USB port on the Pi, not on the power port.\nOnce confirmed that everything is working fine, goto gnome-network-manager gui and change the USB ethernet\u0026rsquo;s IPv4 setting to shared to other computers.\nDisconnect and then reconnect the USB ethernet in the gui. If that doesn\u0026rsquo;t allow you to ssh into the Pi, you might also need to dis/reconnect the PCI ethernet option.\nNow you should be able to SSH into the Internet ready Pi.\n3.2 SSH into Raspberry Pi ssh pi@IP_ADDRESS password: raspberry replace the IP_ADDRESS with the IP Address of the Raspberry Pi zero.\n3.3 Change locale settings To eliminate perl: LC errors during package installations; sudo dpkg-reconfigure locales select the appropriate locale. For example; en_US.UTF-8\nSet timezone sudo ln -sf /usr/share/timezone/Country/Region /etc/localtime Expand file system expand the file system by using\nsudo raspi-config Now its time to shutdown the Pi to take effect the changes.\nReboot seems to be breaking the USB ether net gadget mode for some reason. Hence you need to shutdown the system.\nNote :\nCheck dmesg again . If you see some messages similar to below, reboot the host linux OS. Only then re-connect the Pi.\n[ 1131.255131] ------------[ cut here ]------------ [ 1131.255137] NETDEV WATCHDOG: enx1a4d1a4fb05e (cdc_ether): transmit queue 0 timed out [ 1131.255158] WARNING: CPU: 6 PID: 0 at net/sched/sch_generic.c:467 dev_watchdog+0x24f/0x260 . . . [ 1131.255535] ---[ end trace 07a143fded20143c ]--- I got this message even after a reboot. In that case disconnect the Pi and check the SD card for any file system errors. Reboot the host OS again and reconnect the Pi.\nThen follow the instructions on 3.1 .\n3.4 Update the OS It\u0026rsquo;s better to setup the WiFi connection and then upgrade the OS. It can be done by referring to\nsudo apt update sudo apt upgrade Shutdown and unplug or re plug the Pi. Follow 3.1 .\nNow we need to setup the WiFi to automatically connect to the access point during the next reboot.\n3.5 WiFi configuration for auto connecting to the access point You can add the WiFi Configuration using raspi-config after SSH-ing via USB.\narp -a This will display the IP address of the USB Ethernet ( usually its of form 10.42.0.x ) SSH into the board. Use the following command to enter the Raspi configuration\nsudo raspi-config Then connect to WiFi via the Connection options by entering the SSID and Password of your network.\nOR\nAdd these lines to /etc/wpa_supplicant/wpa_supplicant.conf;\ncountry=\u0026#34;your country code\u0026#34; network={ scan_ssid=1 ssid=\u0026#34;wifi name\u0026#34; psk=\u0026#34;wifi password\u0026#34; } Now shutdown the Pi. Connect the WiFi adapter and power cable then turn it on.\n","permalink":"https://KTS-o7.github.io/blog/posts/raspberrypi_zero_setup/","tags":["raspberrypi","setup"],"title":"RaspberryPi_Zero_Setup"},{"categories":null,"content":" Hello! I\u0026rsquo;m Krishnatejaswi S, a passionate Computer Science and Engineering student from Bangalore, India. My journey in the world of technology has been both challenging and rewarding, and I\u0026rsquo;m excited to share my experiences and projects with you.\nAcademic Background I\u0026rsquo;m currently pursuing my B.E degree in Computer Science and Engineering at RV College of Engineering, where I\u0026rsquo;ve had the opportunity to dive deep into various technologies and programming languages. My academic and research projects have allowed me to explore and master languages like Python and C++, and I\u0026rsquo;m always eager to learn and experiment with new technologies. Portfolio I\u0026rsquo;ve worked on a variety of projects that have helped me grow as a developer. Check out my portfolio to see some of my work. From web development to machine learning, I\u0026rsquo;ve tackled projects that challenge me and push my boundaries.\nPassion for Coding My passion for coding extends beyond the classroom. I\u0026rsquo;m particularly interested in exploring the cutting-edge technologies that are shaping the future of the tech industry. Some of the areas I\u0026rsquo;m currently exploring include:\nOpenCV: A facinating library to work with image processing in python. Ollama: A platform that\u0026rsquo;s revolutionizing the way we interact with AI. Generative AI: Creating content and models that can generate human-like text and images. JavaScript, Next.js: Building dynamic and responsive web applications. PyTorch: Diving into the world of machine learning and AI. Contact Me If you\u0026rsquo;re interested in my work, have questions, or would like to collaborate on a project, feel free to contact me . I\u0026rsquo;m always open to new connections and opportunities.\nThank you for visiting my About page. I look forward to sharing more of my journey with you!\nYou can also connect me via Linktree ","permalink":"https://KTS-o7.github.io/blog/about/about/","tags":null,"title":"About"},{"categories":null,"content":"What is this ? Lets find out !\nmermaid sequenceDiagram participant Alice participant Bob Alice-\u003e\u003eJohn: Hello John, how are you? loop Healthcheck John-\u003e\u003eJohn: Fight against hypochondria end Note right of John: Rational thoughts prevail! John--\u003e\u003eAlice: Great! John-\u003e\u003eBob: How about you? Bob--\u003e\u003eJohn: Jolly good! Code while(True): print(\u0026#34;Hello World\u0026#34;) ","permalink":"https://KTS-o7.github.io/blog/posts/newpost/","tags":["new","post"],"title":"New Post"},{"categories":null,"content":"This is the first post to test the things. Looks like its working !\n","permalink":"https://KTS-o7.github.io/blog/posts/firstpost/","tags":null,"title":"First Post"},{"categories":null,"content":"","permalink":"https://KTS-o7.github.io/blog/search/_index.es/","tags":null,"title":""},{"categories":null,"content":"","permalink":"https://KTS-o7.github.io/blog/search/_index.fr/","tags":null,"title":""},{"categories":null,"content":"","permalink":"https://KTS-o7.github.io/blog/search/_index.hi/","tags":null,"title":""},{"categories":null,"content":"","permalink":"https://KTS-o7.github.io/blog/search/_index.jp/","tags":null,"title":""},{"categories":null,"content":"","permalink":"https://KTS-o7.github.io/blog/search/_index.pl/","tags":null,"title":""},{"categories":null,"content":"","permalink":"https://KTS-o7.github.io/blog/search/_index.ru/","tags":null,"title":""},{"categories":null,"content":"","permalink":"https://KTS-o7.github.io/blog/search/_index.zh-cn/","tags":null,"title":""}]