[{"content":" Problem Statement Link - Problem 2022 Question You are given a 0-indexed 1-dimensional (1D) integer array original, and two integers, m and n. You are tasked with creating a 2-dimensional (2D) array with m rows and n columns using all the elements from original.\nThe elements from indices 0 to n - 1 (inclusive) of original should form the first row of the constructed 2D array, the elements from indices n to 2 * n - 1 (inclusive) should form the second row of the constructed 2D array, and so on.\nReturn an m x n 2D array constructed according to the above procedure, or an empty 2D array if it is impossible.\nExample 1 Input: original = [1,2,3,4], m = 2, n = 2 Output: [[1,2],[3,4]] Explanation: The constructed 2D array should contain 2 rows and 2 columns. The first group of n=2 elements in original, [1,2], becomes the first row in the constructed 2D array. The second group of n=2 elements in original, [3,4], becomes the second row in the constructed 2D array. Example 2 placeHoldeInput: original = [1,2,3], m = 1, n = 3 Output: [[1,2,3]] Explanation: The constructed 2D array should contain 1 row and 3 columns. Put all three elements in original into the first row of the constructed 2D array. Example 3 Input: original = [1,2], m = 1, n = 1 Output: [] Explanation: There are 2 elements in original. It is impossible to fit 2 elements in a 1x1 2D array, so return an empty 2D array. Constraints - `1 \u0026lt;= original.length \u0026lt;= 5 * 10^4` - `1 \u0026lt;= original[i] \u0026lt;= 10^5` - `1 \u0026lt;= m, n \u0026lt;= 4 * 10^4` Solution class Solution { public: vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; construct2DArray(vector\u0026lt;int\u0026gt;\u0026amp; original, int m, int n) { int size = original.size(); if(size != m*n) return {}; vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;ans(m,vector\u0026lt;int\u0026gt;(n)); int idx = 0; for(int i=0;i\u0026lt;m;i++){ for(int j=0;j\u0026lt;n;j++){ ans[i][j]=original[idx]; idx++; } } return ans; } }; Complexity Analysis | Algorithm | Time Complexity | Space Complexity | | --------------- | --------------- | ---------------- | | Array traversal | O(n) | O(mn) | Explanation 1. Intuition The problem is about converting a 1-dimensional array into a 2-dimensional matrix with specified dimensions m (rows) and n (columns). The key observation is that for this conversion to be possible, the total number of elements in the 1D array must exactly match the number of elements in the desired 2D array (m * n). If they don\u0026rsquo;t match, it is impossible to form the desired 2D array, and we should return an empty array.\nHere\u0026rsquo;s the step-by-step breakdown of the approach:\nCheck the Feasibility: First, we need to check if the number of elements in the original array is equal to m * n. If not, return an empty 2D array.\nMatrix Construction: If the sizes match, we can proceed to fill the matrix row by row. Each row in the matrix will take n consecutive elements from the original array.\nTraversing the Original Array: We simply iterate through the original array and place each element in its corresponding position in the 2D matrix. This is done by keeping track of an index that moves through the original array and fills the 2D array in row-major order.\n2. Implementation The implementation directly follows the intuition:\nWe first check if the total number of elements in the original array equals m * n. If not, we return an empty 2D array. We initialize a 2D array with m rows and n columns. We then use nested loops to fill the 2D array, iterating through each element in the original array and placing it in the correct position in the matrix. ","date":"September 1, 2024","permalink":"/blog/leetcode-potd/problem-2022-convert-1d-array-to-2d-array/","summary":"Problem Statement Link - Problem 2022 Question You are given a 0-indexed 1-dimensional (1D) integer array original, and two integers, m and n.","title":"Problem 2022 Convert 1D Array to 2D Array","type":"leetcode-potd"},{"content":" Problem Statement Link - Problem 3275 Question There is an infinite 2D plane.\nYou are given a positive integer k. You are also given a 2D array queries, which contains the following queries:\nqueries[i] = [x, y]: Build an obstacle at coordinate (x, y) in the plane. It is guaranteed that there is no obstacle at this coordinate when this query is made. After each query, you need to find the distance of the kth nearest obstacle from the origin.\nReturn an integer array results where results[i] denotes the kth nearest obstacle after query i, or results[i] == -1 if there are less than k obstacles.\nNote that initially there are no obstacles anywhere.\nThe distance of an obstacle at coordinate (x, y) from the origin is given by |x| + |y|.\nExample 1 Input: queries = [[1,2],[3,4],[2,3],[-3,0]], k = 2 Output: [-1,7,5,3] Explanation: Initially, there are 0 obstacles. After queries[0], there are less than 2 obstacles. After queries[1], there are obstacles at distances 3 and 7. After queries[2], there are obstacles at distances 3, 5, and 7. After queries[3], there are obstacles at distances 3, 3, 5, and 7. Example 2 Input: queries = [[5,5],[4,4],[3,3]], k = 1 Output: [10,8,6] Explanation: After queries[0], there is an obstacle at distance 10. After queries[1], there are obstacles at distances 8 and 10. After queries[2], there are obstacles at distances 6, 8, and 10. Constraints - `1 \u0026lt;= queries.length \u0026lt;= 2 * 10^5` - `All queries[i] are unique.` - `-10^9 \u0026lt;= queries[i][0], queries[i][1] \u0026lt;= 10^9` - `1 \u0026lt;= k \u0026lt;= 10^5` Solution class Solution { public: vector\u0026lt;int\u0026gt; resultsArray(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; queries, int k) { vector\u0026lt;int\u0026gt;res; priority_queue\u0026lt;int\u0026gt;pq; for (const auto\u0026amp; query : queries) { int x = query[0]; int y = query[1]; int dist = abs(x) + abs(y); if (pq.size() \u0026lt; k) { pq.push(dist); } else if (dist \u0026lt; pq.top()) { pq.pop(); pq.push(dist); } if (pq.size() \u0026lt; k) { res.push_back(-1); } else { res.push_back(pq.top()); } } return res; } }; Complexity Analysis | Algorithm | Time Complexity | Space Complexity | | -------------- | --------------- | ---------------- | | Priority Queue | O(N log K) | O(K) | Explanation 1. Intuition We need to keep track of obstacles being placed on a 2D plane and find the kth nearest obstacle to the origin after each query. The distance from the origin to any obstacle at coordinate (x, y) is given by the Manhattan distance: |x| + |y|. Initially, there are no obstacles. After each query, a new obstacle is added, and we need to update our result based on the current state of the plane. Priority Queue (Max-Heap) Usage\nTo efficiently manage and retrieve the kth nearest obstacle, we use a max-heap (priority queue). The heap will always store the distances of the nearest k obstacles to the origin. The top of the max-heap will represent the kth nearest obstacle, as the heap property ensures that the largest of the k nearest distances is at the top. Handling Each Query\nFor each query (x, y) Calculate the Manhattan distance from the origin. If the heap has fewer than k elements, simply add the distance to the heap. If the heap already has k elements, compare the new distance with the top of the heap: If the new distance is smaller, it should be part of the k closest distances, so replace the largest one (heap\u0026rsquo;s top). If not, discard the new distance as it’s not closer than the current k nearest distances. After processing each query, check the heap\u0026rsquo;s size: If it has fewer than k elements, return -1 (indicating that there aren’t enough obstacles yet). Otherwise, return the top of the heap, which is the kth nearest obstacle. 2. Implementation - Define a function `resultsArray` that takes the queries and k as input. - Initialize an empty vector `res` to store the results. - Create a max-heap (priority queue) `pq` to store the k nearest distances. - Iterate over each query in the queries array: - Extract the x and y coordinates from the query. - Calculate the Manhattan distance from the origin. - If the heap size is less than k, add the distance to the heap. - If the heap size is k, compare the new distance with the top of the heap: - If the new distance is smaller, replace the top of the heap with the new distance. - If the heap size is less than k, add -1 to the results array. - Otherwise, add the top of the heap to the results array. - Return the results array. ","date":"September 1, 2024","permalink":"/blog/posts/leetcode-contest/problem-3275-k-th-nearest-obstacle-queries/","summary":"Problem Statement Link - Problem 3275 Question There is an infinite 2D plane.","title":"Problem 3275 K Th Nearest Obstacle Queries","type":"posts"},{"content":" Problem Statement Link - Problem 3274 Question You are given two strings, coordinate1 and coordinate2, representing the coordinates of a square on an 8 x 8 chessboard.\nBelow is the chessboard for reference.\nReturn true if these two squares have the same color and false otherwise.\nThe coordinate will always represent a valid chessboard square. The coordinate will always have the letter first (indicating its column), and the number second (indicating its row).\nExample 1 Input: coordinate1 = \u0026#34;a1\u0026#34;, coordinate2 = \u0026#34;c3\u0026#34; Output: true Explanation: Both squares are black. Example 2 Input: coordinate1 = \u0026#34;a1\u0026#34;, coordinate2 = \u0026#34;h3\u0026#34; Output: false Explanation: Square \u0026#34;a1\u0026#34; is black and \u0026#34;h3\u0026#34; is white. Constraints - `coordinate1.length == coordinate2.length == 2` - `\u0026#39;a\u0026#39; \u0026lt;= coordinate1[0], coordinate2[0] \u0026lt;= \u0026#39;h\u0026#39;` - `\u0026#39;1\u0026#39; \u0026lt;= coordinate1[1], coordinate2[1] \u0026lt;= \u0026#39;8\u0026#39;` Solution class Solution { public: bool checkTwoChessboards(string c1, string c2) { int col1 = (c1[0] - \u0026#39;a\u0026#39; + 1 + c1[1] - \u0026#39;0\u0026#39;) % 2; int col2 = (c2[0] - \u0026#39;a\u0026#39; + 1 + c2[1] - \u0026#39;0\u0026#39;) % 2; return col1 == col2; } }; Complexity Analysis | Algorithm | Time Complexity | Space Complexity | | ---------- | --------------- | ---------------- | | Simulation | O(1) | O(1) | Explanation 1. Intuition - From the board we can see that `a,c,e,g` are black and `b,d,f,h` are white. - Similarly `1,3,5,7` are black and `2,4,6,8` are white. - If we assign black as `0` and white as `1` then we can see that the sum of the column and row is `even` for black and `odd` for white. - So given each cordinate, convert it into integer and then find remiander when divided by `2`. - Then we need to compare the remainder of both the cordinates. 2. Implementation - A cordinate is given in the form of `a1` where `a` is the column and `1` is the row. - We need to convert the column and row into integer. - intger value is calculated as `(column value+1) + row value`. - Then we find the remainder when divided by `2`. - We then compare the remainder of both the cordinates. - Return `true` if both the remainders are same and `false` otherwise. ","date":"September 1, 2024","permalink":"/blog/posts/leetcode-contest/problem-3274-check-if-two-chessboard-squares-have-the-same-color/","summary":"Problem Statement Link - Problem 3274 Question You are given two strings, coordinate1 and coordinate2, representing the coordinates of a square on an 8 x 8 chessboard.","title":"Problem 3274 Check if Two Chessboard Squares Have the Same Color","type":"posts"},{"content":" Problem Statement Link - Problem 3273 Question You are given an integer power and two integer arrays damage and health, both having length n.\nBob has n enemies, where enemy i will deal Bob damage[i] points of damage per second while they are alive (i.e. health[i] \u0026gt; 0).\nEvery second, after the enemies deal damage to Bob, he chooses one of the enemies that is still alive and deals power points of damage to them.\nDetermine the minimum total amount of damage points that will be dealt to Bob before all n enemies are dead.\nExample 1 Input: power = 4, damage = [1,2,3,4], health = [4,5,6,8] Output: 39 Explanation: Attack enemy 3 in the first two seconds, after which enemy `3` will go down, the number of damage points dealt to Bob is `10 + 10 = 20` points. Attack enemy 2 in the next two seconds, after which enemy `2` will go down, the number of damage points dealt to Bob is `6 + 6 = 12` points. Attack enemy 0 in the next second, after which enemy `0` will go down, the number of damage points dealt to Bob is `3` points. Attack enemy `1` in the next two seconds, after which enemy `1` will go down, the number of damage points dealt to Bob is `2 + 2 = 4` points. Example 2 placeHoldeInput: power = 1, damage = [1,1,1,1], health = [1,2,3,4] Output: 20 Explanation: Attack enemy 0 in the first second, after which enemy 0 will go down, the number of damage points dealt to Bob is 4 points. Attack enemy 1 in the next two seconds, after which enemy 1 will go down, the number of damage points dealt to Bob is 3 + 3 = 6 points. Attack enemy 2 in the next three seconds, after which enemy 2 will go down, the number of damage points dealt to Bob is 2 + 2 + 2 = 6 points. Attack enemy 3 in the next four seconds, after which enemy 3 will go down, the number of damage points dealt to Bob is 1 + 1 + 1 + 1 = 4 points. Example 3 Input: power = 8, damage = [40], health = [59] Output: 320 Edge Case Input power = 28 damage = [95,94] health = [23,2] Output 283 Input power = 62 damage = [80,79] health = [86,13] Output 319 Constraints 1 \u0026lt;= power \u0026lt;= 104 1 \u0026lt;= n == damage.length == health.length \u0026lt;= 105 1 \u0026lt;= damage[i], health[i] \u0026lt;= 104 Solution class Solution { public: long long minDamage(int power, vector\u0026lt;int\u0026gt;\u0026amp; damage, vector\u0026lt;int\u0026gt;\u0026amp; health) { int n = damage.size(); long long totdmg = 0; long long res = 0; vector\u0026lt;tuple\u0026lt;double, int, int\u0026gt;\u0026gt; e; for (int i = 0; i \u0026lt; n; i++) { int turns = (health[i] + power - 1) / power; double eff = static_cast\u0026lt;double\u0026gt;(damage[i]) / turns; e.push_back({eff, damage[i], turns}); totdmg += damage[i]; } sort(e.begin(), e.end(), [](const auto\u0026amp; a, const auto\u0026amp; b) { if (get\u0026lt;0\u0026gt;(a) != get\u0026lt;0\u0026gt;(b)) return get\u0026lt;0\u0026gt;(a) \u0026gt; get\u0026lt;0\u0026gt;(b); return get\u0026lt;1\u0026gt;(a) \u0026gt; get\u0026lt;1\u0026gt;(b); }); for (const auto\u0026amp; [eff, dmg, turns] : e) { res += totdmg * turns; totdmg -= dmg; } return res; } }; Complexity Analysis | Algorithm | Time Complexity | Space Complexity | | -------------- | --------------- | ---------------- | | Tuple creation | O(N) | O(N) | | Sorting | O(NlogN) | O(1) | | Total | O(NlogN) | O(N) | Explanation 1. Intuition We have different cases in our hand. To minimize the damage, we need to pay attention to both damage dealt by enemies and the health of the enemies.\nAn enemy can deal lot of damage if it has high damage or low health. An enemy can deal less damage if it has low damage and low health. An enemy can deal lot of damage if it has high damage and high health. An enemy can deal lot of damage if it has low damage and high health. Hence we need to calculate the effective damage dealt by each enemy and sort them in descending order.\nOrder of killing will be as follows If the enemy has high effective damage, kill it first. If two enemies has same effective damage, kill the one with high damage first. - First count the number of turns needed to kill an enemy using the formula (health[i] + power - 1) / power. - This is counted using ceil division. - Calculate the effective damage dealt by each enemy using the formula damage[i] / turns. - Store the effective damage, damage and turns in a tuple. - Sort the enemies in descending order of effective damage. - Calculate the total damage dealt by all enemies. - For each enemy, calculate the total damage dealt by all enemies and add it to the result. - Update the total damage dealt by all enemies by subtracting the damage dealt by the current enemy. Indicating that the enemy is dead. 2. Implementation - Declare a variable `n` to store the length of the damage array. - Declare a variable `totdmg` to store the total damage dealt by all enemies. - Declare a variable `res` to store the result. - Declare a vector of tuples `e` to store the effective damage, damage and turns needed to kill each enemy. - Iterate over from `0` to `n`. - Declare a variable `turns` to store the number of turns needed to kill the enemy. - Calculate the number of turns needed to kill the enemy using the formula `(health[i] + power - 1) / power`. - Calculate the effective damage dealt by the enemy using the formula `static_cast\u0026lt;double\u0026gt;(damage[i]) / turns`. - Push the tuple `{eff, damage[i], turns}` to the vector `e`. - Add the damage dealt by the enemy to the total damage dealt by all enemies. - Sort the vector `e` in descending order of effective damage. - Custom comparator is as follows - If the effective damage of the first enemy is not equal to the effective damage of the second enemy, sort in descending order of effective damage. - If the effective damage of the first enemy is equal to the effective damage of the second enemy, sort in descending order of damage. - For each enemy in the vector `e`, calculate the total damage dealt by all enemies and add it to the result. - Update the total damage dealt by all enemies by subtracting the damage dealt by the current enemy. Indicating that the enemy is dead. - Return the result. ","date":"September 1, 2024","permalink":"/blog/posts/leetcode-contest/problem-3273-minimum-amount-of-damage-dealt-to-bob/","summary":"Problem Statement Link - Problem 3273 Question You are given an integer power and two integer arrays damage and health, both having length n.","title":"Problem 3273 Minimum Amount of Damage Dealt to Bob","type":"posts"},{"content":" Problem Statement Link - Problem 3271 Question You are given a string s of length n and an integer k, where n is a multiple of k. Your task is to hash the string s into a new string called result, which has a length of n / k.\nFirst, divide s into n / k substrings , each with a length of k. Then, initialize result as an empty string.\nFor each substring in order from the beginning:\nThe hash value of a character is the index of that character in the English alphabet (e.g., 'a' → 0, 'b' → 1, \u0026hellip;, 'z' → 25). Calculate the sum of all the hash values of the characters in the substring. Find the remainder of this sum when divided by 26, which is called hashedChar. Identify the character in the English lowercase alphabet that corresponds to hashedChar. Append that character to the end of result. Return result.\nA substring is a contiguous non-empty sequence of characters within a string.\nExample 1 Input: s = \u0026#34;abcd\u0026#34;, k = 2 Output: \u0026#34;bf\u0026#34; Explanation: First substring: \u0026#34;ab\u0026#34;, 0 + 1 = 1, 1 % 26 = 1, result[0] = \u0026#39;b\u0026#39;. Second substring: \u0026#34;cd\u0026#34;, 2 + 3 = 5, 5 % 26 = 5, result[1] = \u0026#39;f\u0026#39;. Example 2 Input: s = \u0026#34;mxz\u0026#34;, k = 3 Output: \u0026#34;i\u0026#34; Explanation: The only substring: \u0026#34;mxz\u0026#34;, 12 + 23 + 25 = 60, 60 % 26 = 8, result[0] = \u0026#39;i\u0026#39;. Constraints - `1 \u0026lt;= k \u0026lt;= 100` - `k \u0026lt;= s.length \u0026lt;= 1000` - `s.length` is divisible by `k`. - `s` consists only of lowercase English letters. Solution class Solution { public: string stringHash(string s, int k) { std::ios::sync_with_stdio(false); int n = s.length(); int subcnt = n / k; string result = \u0026#34;\u0026#34;; for (int i = 0; i \u0026lt; subcnt; i++) { int sum = 0; for (int j = 0; j \u0026lt; k; j++) { sum += s[i * k + j] - \u0026#39;a\u0026#39;; } int val = sum % 26; result += (char)(val + \u0026#39;a\u0026#39;); } return result; } }; Complexity Analysis | Algorithm | Time Complexity | Space Complexity | | --------------- | --------------- | ---------------- | | Hash generation | O(N) | O(1) | Explanation 1. Intuition This question is also relatively simple. We need to do exactly what the question asks for.\nThen we need to chunk the string into substrings of length k. For each substring, we need to calculate the sum of the hash values of the characters. Then we need to find the remainder of this sum when divided by 26. Finally, we need to append the character corresponding to this remainder to the result string. - Calculate how many substrings we can form. - That is equal to the length of the string divided by k. - We need that many iterations. - For each iteration, calculate the sum of the hash values of the characters. - Hashvalue is simply the difference of the character and \u0026#39;a\u0026#39;. - Find the remainder of the sum when divided by 26. - Append the character corresponding to this remainder to the result string. 2. Implementation - Declare a variable `n` to store the length of the string. - Declare a variable `subcnt` to store the number of substrings. - Declare a string `result` to store the result. - `subcnt` = `n` / `k`. - Iterate over from `0` to `subcnt`. - Declare a variable `sum` to store the sum of the hash values of the characters. - Iterate over from `0` to `k`. - Add the hash value of the character to the `sum`. - Hash value is `s[i * k + j] - \u0026#39;a\u0026#39;`. - Find the remainder of the `sum` when divided by 26. - Append the character corresponding to this remainder to the `result`. ","date":"September 1, 2024","permalink":"/blog/posts/leetcode-contest/problem-3271-hash-divided-strings/","summary":"Problem Statement Link - Problem 3271 Question You are given a string s of length n and an integer k, where n is a multiple of k.","title":"Problem 3271 Hash Divided Strings","type":"posts"},{"content":" Problem Statement Link - Problem 3270 Question You are given three positive integers num1, num2, and num3.\nThe key of num1, num2, and num3 is defined as a four-digit number such that:\nInitially, if any number has less than four digits, it is padded with leading zeros. The ith digit (1 \u0026lt;= i \u0026lt;= 4) of the key is generated by taking the smallest digit among the ith digits of num1, num2, and num3. Return the key of the three numbers without leading zeros (if any).\nExample 1 Input: num1 = 1, num2 = 10, num3 = 1000 Output: 0 Explanation: On padding, num1 becomes \u0026#34;0001\u0026#34;, num2 becomes \u0026#34;0010\u0026#34;, and num3 remains \u0026#34;1000\u0026#34;. The 1st digit of the key is min(0, 0, 1). The 2nd digit of the key is min(0, 0, 0). The 3rd digit of the key is min(0, 1, 0). The 4th digit of the key is min(1, 0, 0). Hence, the key is \u0026#34;0000\u0026#34;, i.e. 0. Example 2 Input: num1 = 987, num2 = 879, num3 = 798 Output: 777 Example 3 Input: num1 = 1, num2 = 2, num3 = 3 Output: 1 Constraints - `1 \u0026lt;= num1, num2, num3 \u0026lt;= 9999` Solution class Solution { public: int generateKey(int num1, int num2, int num3) { std::ios::sync_with_stdio(false); string str1 = addzeros(num1); string str2 = addzeros(num2); string str3 = addzeros(num3); string key = \u0026#34;\u0026#34;; for (int i = 0; i \u0026lt; 4; ++i) { char mindigit = min({str1[i], str2[i], str3[i]}); key += mindigit; } return stoi(key); } string addzeros(int num) { string str = to_string(num); while (str.length() \u0026lt; 4) { str = \u0026#34;0\u0026#34; + str; } return str; } }; Complexity Analysis | Algorithm | Time Complexity | Space Complexity | | --------- | --------------- | ---------------- | | Traverse | O(1) | O(1) | Explanation 1. Intuition This is a simple problem where we need to just implement what the question asks for. There is no need for any complex algorithm.\n- For easy manipulation, we convert the numbers to strings and add leading zeros. - We then iterate over the strings and find the minimum digit at each position. - We then return the key as an integer. 2. Implementation Convert the numbers to strings and store as str1, str2, and str3. Declare a string key to store the key. Iterate over the strings and find the minimum digit at each position. Find the minimum digit at the ith position of str1, str2, and str3. Append the minimum digit to the key. Convert the key to an integer and return it. ","date":"September 1, 2024","permalink":"/blog/posts/leetcode-contest/problem-3270-find-the-key-of-numbers/","summary":"Problem Statement Link - Problem 3270 Question You are given three positive integers num1, num2, and num3.","title":"Problem 3270 Find the Key of Numbers","type":"posts"},{"content":" Problem Statement Link - Problem 108 Question Given an integer array nums where the elements are sorted in ascending order, convert it to a height-balanced binary search tree.\nA height-balanced binary tree is a binary tree in which the depth of the two subtrees of every node never differs by more than one.\nExample 1 Input: nums = [-10,-3,0,5,9] Output: [0,-3,9,-10,null,5] Explanation: [0,-10,5,null,-3,null,9] is also accepted: Example 2 Input: nums = [1,3] Output: [3,1] Explanation: [1,null,3] and [3,1] are both height-balanced BSTs. Constraints 1 \u0026lt;= nums.length \u0026lt;= 104 -104 \u0026lt;= nums[i] \u0026lt;= 104 nums is sorted in a strictly increasing order. Solution /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: TreeNode* helper(vector\u0026lt;int\u0026gt;\u0026amp; nums, int l, int r){ if(l\u0026gt;r) return nullptr; int mid = (l+r)/2; TreeNode* root = new TreeNode(nums[mid]); root-\u0026gt;left = helper(nums,l,mid-1); root-\u0026gt;right = helper(nums,mid+1,r); return root; } TreeNode* sortedArrayToBST(vector\u0026lt;int\u0026gt;\u0026amp; nums) { int size = nums.size()-1; TreeNode * root = helper(nums,0,size); return root; } }; Complexity Analysis | Algorithm | Time Complexity | Space Complexity | | --------- | --------------- | ---------------- | | Recursion | O(N) | O(N) | Explanation 1. Intuition - In a sorted array, the middle element is the root of the tree. - Sorted array is same as inorder traversal of the binary search tree. - So, we can recursively build the tree by finding the middle element and then recursively build the left and right subtree. - Assign the left and right child of the root node to the left and right subtree. - Left sub tree will be from 0 to mid-1 and right subtree will be from mid+1 to n. 2. Implementation - Define a function `helper` which takes the sorted array and the left and right index. - If left index is greater than right index, return nullptr. - Find the middle element of the range `l` to `r`. - Create a new node with the middle element as the value. - Recursively call the helper function for the left and right subtree. - Assign the left and right child of the root node to the left and right subtree. - Return the root node. ","date":"August 30, 2024","permalink":"/blog/posts/extraques/problem-108-convert-sorted-array-to-binary-search-tree/","summary":"Problem Statement Link - Problem 108 Question Given an integer array nums where the elements are sorted in ascending order, convert it to a height-balanced binary search tree.","title":"Problem 108 Convert Sorted Array to Binary Search Tree","type":"posts"},{"content":" Problem Statement Link - Problem 947 Question On a 2D plane, we place n stones at some integer coordinate points. Each coordinate point may have at most one stone.\nA stone can be removed if it shares either the same row or the same column as another stone that has not been removed.\nGiven an array stones of length n where stones[i] = [xi, yi] represents the location of the ith stone, return the largest possible number of stones that can be removed.\nExample 1 Input: stones = [[0,0],[0,1],[1,0],[1,2],[2,1],[2,2]] Output: 5 Explanation: One way to remove 5 stones is as follows: 1. Remove stone [2,2] because it shares the same row as [2,1]. 2. Remove stone [2,1] because it shares the same column as [0,1]. 3. Remove stone [1,2] because it shares the same row as [1,0]. 4. Remove stone [1,0] because it shares the same column as [0,0]. 5. Remove stone [0,1] because it shares the same row as [0,0]. Stone [0,0] cannot be removed since it does not share a row/column with another stone still on the plane. Example 2 Input: stones = [[0,0],[0,2],[1,1],[2,0],[2,2]] Output: 3 Explanation: One way to make 3 moves is as follows: 1. Remove stone [2,2] because it shares the same row as [2,0]. 2. Remove stone [2,0] because it shares the same column as [0,0]. 3. Remove stone [0,2] because it shares the same row as [0,0]. Stones [0,0] and [1,1] cannot be removed since they do not share a row/column with another stone still on the plane. Example 3 Input: stones = [[0,0]] Output: 0 Explanation: [0,0] is the only stone on the plane, so you cannot remove it. Constraints 1 \u0026lt;= stones.length \u0026lt;= 1000 0 \u0026lt;= xi, yi \u0026lt;= 104 No two stones are at the same coordinate point. Solution class Solution { public: int removeStones(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; stones) { int n = stones.size(); vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; adjlist(n); for (int i = 0; i \u0026lt; n; i++) { for (int j = i + 1; j \u0026lt; n; j++) { if (stones[i][0] == stones[j][0] || stones[i][1] == stones[j][1]) { adjlist[i].push_back(j); adjlist[j].push_back(i); } } } int numOfGrps = 0; vector\u0026lt;bool\u0026gt; visited(n, false); for (int i = 0; i \u0026lt; n; i++) { if (!visited[i]) { dfs(adjlist, visited, i); numOfGrps++; } } return n - numOfGrps; } private: void dfs(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; adjlist,vector\u0026lt;bool\u0026gt;\u0026amp; visited, int stone) { visited[stone] = true; for (int neighbor : adjlist[stone]) { if (!visited[neighbor]) { dfs(adjlist, visited, neighbor); } } } }; Complexity Analysis | Algorithm | Time Complexity | Space Complexity | | ----------------------- | --------------- | ---------------- | | Adjacency List creation | O(n^2) | O(n^2) | | DFS | O(n) | O(n) | | Overall | O(n^2) | O(n^2) | Explanation 1. Intuition Lets make a note of all the possible observations which might help us to build up a solution. We need to remove as many stones as possible. We can remove a stone only if it shares the same row or column with another stone. Basically the stone can be removed if its connected to another stone. We need to mathematically represent the connected stones. Such connections can be represented as a graph. Lets analyse how we can remove stones. - If we have a stone at `[0,0]` and `[0,1]`, we can remove one of the stones. - If we have a stone at `[0,0]` and `[1,0]`, we can remove one of the stones. - If we have a stone at `[0,0]` and `[1,1]`, we cannot remove any stone. Generalizing the observation - If we have a stone at `[x1,y1]` and `[x2,y2]`, we can remove one of the stones if `x1 == x2` or `y1 == y2`. One more observation is if there are n stones, we can remove n-1 stones. This is because we can remove a stone only if its connected to another stone. By this logic, We cant remove if there is only one stone. Lets try to build a mathematical model to represent the stones and their connections. Mathematical approach to determine the number of stones that can be picked Trivial case is when there is only one stone, we cannot remove it. Lets assume there are N stones on the plane such that N \u0026gt; 1. If N=2, we can remove one stone. Inductive hypothesis is that we can remove k stones if there are k+1 connected stones. then lets assume there is a stone S such that it is connected to k stones. We can remove k stones and S stone. So we can remove k+1 stones. Hence it is proved that we can remove k stones if there are k+1 connected stones. That means if there is 1 connected component with k stones, we can remove k-1 stones. In a plane there can be n stones which are distributed in C connected components. We can remove n-C stones. The problem is reduced to finding the number of connected components in the graph.\n_TL DR_ : - Build a graph of stones such that stones are connected if they share the same row or column. - Find the number of connected components in the graph, using DFS. - The number of stones that can be removed is `n - numOfConnectedComponents`. 2. Implementation - Intialize `n` as the number of stones. - Create an adjacency list `adjlist` to represent the graph. - For each stone `i` from `0` to `n-1`, - For each stone `j` from `i+1` to `n-1`, - If `stones[i][0] == stones[j][0]` or `stones[i][1] == stones[j][1]`, - Add `j` to the adjacency list of `i`. - Add `i` to the adjacency list of `j`. - Intialize `numOfGrps` as `0`. - Intialize a boolean vector `visited` of size `n` with all values as `false`. - For each stone `i` from `0` to `n-1`, - If `visited[i]` is `false`, - Call `dfs` with `adjlist`, `visited` and `i`. - Increment `numOfGrps` by `1`. - Return `n - numOfGrps`. - Define a `dfs` function which takes `adjlist`, `visited` and `stone` as arguments. - Mark `stone` as `visited`. - For each `neighbor` in the adjacency list of `stone`, - If `neighbor` is not visited, - Call `dfs` with `adjlist`, `visited` and `neighbor`. There is a better union-find solution for this problem.\nclass Disjoint { public: vector\u0026lt;int\u0026gt; size, parent; Disjoint(int n) { for(int i = 0; i \u0026lt;= n; ++i) { size.push_back(1); parent.push_back(i); } } int findPar(int node) { if(node == parent[node]) return node; return parent[node] = findPar(parent[node]); } void unionn(int a, int b) { a = findPar(a); b = findPar(b); if(a == b) return; if(size[a] \u0026lt; size[b]) { parent[a] = b; size[b] += size[a]; } else { parent[b] = a; size[a] += size[b]; } } }; class Solution { public: int removeStones(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; stones) { int n = stones.size(); int maxRow = 0, maxCol = 0; for(int i = 0; i \u0026lt; n; ++i) { maxRow = max(maxRow, stones[i][0]); maxCol = max(maxCol, stones[i][1]); } Disjoint *dsu = new Disjoint(maxRow + maxCol + 1); for(int i = 0; i \u0026lt; n; ++i) { int col = stones[i][1]; int row = stones[i][0] + maxCol + 1; dsu -\u0026gt; unionn(row, col); } set\u0026lt;int\u0026gt; numComp; for(int i = 0; i \u0026lt; n; ++i) { int row = stones[i][0] + maxCol + 1; int col = stones[i][1]; numComp.insert(dsu -\u0026gt; findPar(row)); numComp.insert(dsu -\u0026gt; findPar(col)); } return n - (int)numComp.size(); } }; ","date":"August 29, 2024","permalink":"/blog/leetcode-potd/problem-947-most-stones-removed-with-same-row-or-column/","summary":"Problem Statement Link - Problem 947 Question On a 2D plane, we place n stones at some integer coordinate points.","title":"Problem 947 Most Stones Removed With Same Row or Column","type":"leetcode-potd"},{"content":" Filesystems: FAT vs. NTFS vs. ext4 FAT FAT (File Allocation Table) is an older file system that is widely compatible with various devices and legacy systems.\nNTFS NTFS (New Technology File System) is a modern file system used primarily with Windows, offering advanced features and better performance.\next4 ext4 (Fourth Extended Filesystem) is a widely used file system in Linux environments, known for its robustness and performance.\nKey Differences Feature FAT NTFS ext4 File Size and Volume Limits Supports files up to 4GB and volumes up to 2TB Handles files up to 16TB and volumes up to 256TB Supports files up to 16TB and volumes up to 1EB File Permissions and Security No built-in file permissions or encryption Supports ACLs, encryption (EFS), and advanced security features Supports Unix-style permissions and ACLs Journaling No journaling; file system integrity must be checked manually Uses journaling for reliability and recovery Supports journaling for improved reliability and quick recovery Compression and Quotas No support for file compression or disk quotas Supports file/folder compression and disk quotas No native support for file compression, but supports disk quotas Compatibility Highly compatible with various devices and legacy systems Primarily used with Windows; limited compatibility with other operating systems Primarily used with Linux; limited compatibility with other operating systems Performance Faster for simple tasks but less efficient with large files Better performance with large files and volumes Generally offers good performance, especially with large files and volumes ","date":"August 29, 2024","permalink":"/blog/core-subjects/fat-vs-ntfs-vs-ext4/","summary":"Filesystems: FAT vs.","title":"FAT vs NTFS vs EXT4","type":"core-subjects"},{"content":" Problem Statement Link - Problem 1905 Question You are given two m x n binary matrices grid1 and grid2 containing only 0\u0026rsquo;s (representing water) and 1\u0026rsquo;s (representing land). An island is a group of 1\u0026rsquo;s connected 4-directionally (horizontal or vertical). Any cells outside of the grid are considered water cells.\nAn island in grid2 is considered a sub-island if there is an island in grid1 that contains all the cells that make up this island in grid2.\nReturn the number of islands in grid2 that are considered sub-islands.\nExample 1 Input: grid1 = [[1,1,1,0,0],[0,1,1,1,1],[0,0,0,0,0],[1,0,0,0,0],[1,1,0,1,1]], grid2 = [[1,1,1,0,0],[0,0,1,1,1],[0,1,0,0,0],[1,0,1,1,0],[0,1,0,1,0]] Output: 3 Explanation: In the picture above, the grid on the left is grid1 and the grid on the right is grid2. The 1s colored red in grid2 are those considered to be part of a sub-island. There are three sub-islands. Example 2 Input: grid1 = [[1,0,1,0,1],[1,1,1,1,1],[0,0,0,0,0],[1,1,1,1,1],[1,0,1,0,1]], grid2 = [[0,0,0,0,0],[1,1,1,1,1],[0,1,0,1,0],[0,1,0,1,0],[1,0,0,0,1]] Output: 2 Explanation: The grid on the left is grid1 and the grid on the right is grid2. There are two sub-islands. Constraints - `m == grid1.length == grid2.length` - `n == grid1[i].length == grid2[i].length` - `1 \u0026lt;= m, n \u0026lt;= 500` - `grid1[i][j] and grid2[i][j] are either 0 or 1.` Solution class Solution { public: bool dfs(int i, int j, vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; grid1, vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; grid2, int n, int m) { if(i \u0026lt; 0 || j \u0026lt; 0 || i \u0026gt;= n || j \u0026gt;= m) return true; if(grid2[i][j] == 0) return true; grid2[i][j] = 0; bool isSubIsland = true; if(grid1[i][j] == 0) isSubIsland = false; bool right = dfs(i + 1, j, grid1, grid2, n, m); bool down = dfs(i, j + 1, grid1, grid2, n, m); bool left = dfs(i - 1, j, grid1, grid2, n, m); bool up = dfs(i, j - 1, grid1, grid2, n, m); return isSubIsland \u0026amp;\u0026amp; right \u0026amp;\u0026amp; down \u0026amp;\u0026amp; left \u0026amp;\u0026amp; up; } int countSubIslands(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; grid1, vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; grid2) { int n = grid1.size(); int m = grid1[0].size(); int count = 0; for(int i = 0; i \u0026lt; n; i++) { for(int j = 0; j \u0026lt; m; j++) { if(grid2[i][j] == 1) { if(dfs(i, j, grid1, grid2, n, m)) { count++; } } } } return count; } }; Complexity Analysis | Algorithm | Time Complexity | Space Complexity | | --------- | --------------- | ---------------- | | DFS | O(NM) | O(NM) | Explanation 1. Intuition So lets take a moment to summarize the problem statement and build up intuition.\nWe need to find all the islands in grid2. Check whether each island in grid2 is covered by an island in grid1. So to a cover is generated when the island in grid1 is atleast as same as the island in grid2. That means we can say an island in grid2 is covered if all the corresponding cells in grid1 are 1. Even if a single cell is not same inside the islands on grids then its not covered. So that being said, Now we can observe that we need to find all the possible islands and then check if the corresponding cells are same in grid1 and grid2. To find all the islands we can use DFS as the classic island count problem. - We can count the number of islands in `grid2` using DFS. - First check if the co-ordinates are valid - Then check if the cell is water or not - If water then return - If not then mark the cell as water ( means visited ) - Then check if the cell is land in `grid1` - If not then its not a sub island - If yes then its a sub island - Then recursively check for all the 4 directions 2. Implementation - Define a `boolean` function `dfs` - Inputs are `i`, `j`, `grid1`, `grid2`, `n`, `m` - `i` is the row index, `j` is the column index - `grid1` and `grid2` are the 2D vectors - `n` and `m` are the dimensions of the grid - If the co-ordinates are out of bounds then return `true` - If the cell is water then return `true` - Mark the cell as water - Initialize `isSubIsland` as `true` - Check if the cell is land in `grid1` - If not then `isSubIsland` is `false` - Recursively check for all the 4 directions - `right`, `down`, `left`, `up` are the recursive calls - return `isSubIsland \u0026amp;\u0026amp; right \u0026amp;\u0026amp; down \u0026amp;\u0026amp; left \u0026amp;\u0026amp; up` - This represents if the current cell contributes to the sub island or not Similar question Problem 200 classic islands Solution to Problem 200 classic islands ","date":"August 28, 2024","permalink":"/blog/leetcode-potd/problem-1905-count-sub-islands/","summary":"Problem Statement Link - Problem 1905 Question You are given two m x n binary matrices grid1 and grid2 containing only 0\u0026rsquo;s (representing water) and 1\u0026rsquo;s (representing land).","title":"Problem 1905 Count Sub Islands","type":"leetcode-potd"},{"content":" Problem Statement Link - Problem 1514 Question You are given an undirected weighted graph of n nodes (0-indexed), represented by an edge list where edges[i] = [a, b] is an undirected edge connecting the nodes a and b with a probability of success of traversing that edge succProb[i].\nGiven two nodes start and end, find the path with the maximum probability of success to go from start to end and return its success probability.\nIf there is no path from start to end, return 0. Your answer will be accepted if it differs from the correct answer by at most 1e-5.\nExample 1 Input: n = 3, edges = [[0,1],[1,2],[0,2]], succProb = [0.5,0.5,0.2], start = 0, end = 2 Output: 0.25000 Explanation: There are two paths from start to end, one having a probability of success = 0.2 and the other has 0.5 * 0.5 = 0.25. Example 2 Input: n = 3, edges = [[0,1],[1,2],[0,2]], succProb = [0.5,0.5,0.3], start = 0, end = 2 Output: 0.30000 Example 3 Input: n = 3, edges = [[0,1]], succProb = [0.5], start = 0, end = 2 Output: 0.00000 Explanation: There is no path between 0 and 2. Constraints 2 \u0026lt;= n \u0026lt;= 104 0 \u0026lt;= start, end \u0026lt; n start != end 0 \u0026lt;= a, b \u0026lt; n a != b 0 \u0026lt;= succProb.length == edges.length \u0026lt;= 2*104 0 \u0026lt;= succProb[i] \u0026lt;= 1 There is at most one edge between every two nodes. Solution class Solution { public: double maxProbability(int n, vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; edges, vector\u0026lt;double\u0026gt;\u0026amp; succProb, int start, int end) { vector\u0026lt;double\u0026gt;prob(n,0.0); prob[start]= 1.0; vector\u0026lt;vector\u0026lt;pair\u0026lt;double,int\u0026gt;\u0026gt;\u0026gt;adj(n); for(int i = 0; i\u0026lt;edges.size(); i++){ adj[edges[i][0]].push_back({succProb[i],edges[i][1]}); adj[edges[i][1]].push_back({succProb[i],edges[i][0]}); } priority_queue\u0026lt;pair\u0026lt;double,int\u0026gt;,vector\u0026lt;pair\u0026lt;double,int\u0026gt;\u0026gt;\u0026gt;pq; pq.push({1.0,start}); while(!pq.empty()){ auto [curr,i] = pq.top(); pq.pop(); if(i == end) return curr; for(auto [nextprob,j]:adj[i]){ double newprob = curr*nextprob; if(newprob\u0026gt;prob[j]){ prob[j] = newprob; pq.push({newprob,j}); } } } return 0.0; } }; Complexity Analysis | Algorithm | Time Complexity | Space Complexity | | --------- | --------------- | ---------------- | | Dijkstra | O(ElogV) | O(V+E) | Explanation 1. Intuition - We can use Dijkstra\u0026#39;s algorithm to find the path with maximum probability. - But to make it work we need to store the maximum probabilty of reaching a node from the start node. It\u0026rsquo;s known that \\[P(A \\cap B) = P(A \\mid B) \\times P(B)\\]Let \\(B\\) denote the set for a path to the current vertex.\nLet \\(A\\) denote the set for paths to the next vertex.\nSo \\(A \\cap B\\) is the set for a path passing the current vertex and the next vertex.\nLet \\(P(B)\\) denote the probability to the current vertex.\nLet \\(P(A \\mid B)\\) denote the probability from the current vertex to the next vertex.\nThen \\(P(A \\cap B)\\) is the probability of the path passing the current vertex and then the next vertex.\n2. Implementation - Intialize a vector `prob` to store the maximum probability of reaching a node from the `start` node. - Intialize a vector of vectors `adj` to store the adjacency list of the graph. - Iterate over the edges and store the adjacency list. - Intialize a priority queue `pq` to store the maximum probability and the node. - Push the start node with probability 1.0 into the priority queue. - While the priority queue is not empty: - Pop the top element from the priority queue. - If the node is the end node, return the probability. - Iterate over the adjacency list of the node: - Calculate the new probability. - If the new probability is greater than the previous probability: - Update the probability. - Push the new probability and the node into the priority queue. - Return 0.0 if there is no path. ","date":"August 27, 2024","permalink":"/blog/leetcode-potd/problem-1514-path-with-maximum-probability/","summary":"Problem Statement Link - Problem 1514 Question You are given an undirected weighted graph of n nodes (0-indexed), represented by an edge list where edges[i] = [a, b] is an undirected edge connecting the nodes a and b with a probability of success of traversing that edge succProb[i].","title":"Problem 1514 Path With Maximum Probability","type":"leetcode-potd"},{"content":" Problem Statement Link - Problem 145 Question Given the root of a binary tree, return the postorder traversal of its nodes\u0026rsquo; values.\nExample 1 Input: root = [1,null,2,3] Output: [3,2,1] Example 2 Input: root = [] Output: [] Example 3 Input: root = [1] Output: [1] Constraints - `The number of the nodes in the tree is in the range [0, 100].` - `-100 \u0026lt;= Node.val \u0026lt;= 100` Solution /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: void postorder(TreeNode* root, vector\u0026lt;int\u0026gt;\u0026amp; v){ if(root){ postorder(root-\u0026gt;left,v); postorder(root-\u0026gt;right,v); v.push_back(root-\u0026gt;val); } } vector\u0026lt;int\u0026gt; postorderTraversal(TreeNode* root) { vector\u0026lt;int\u0026gt;v; postorder(root,v); return v; } }; Complexity Analysis | Algorithm | Time Complexity | Space Complexity | | ------------------- | --------------- | ---------------- | | Postorder Traversal | O(N) | O(N) | Explanation 1. Intuition - We need to recursive visit the left and right child of the root node and then visit the root node. 2. Implementation - Initialize a vector `v` to store the postorder traversal of the binary tree. - Write a recursive function `postorder` that takes the root node and the vector `v` as arguments. - If the root node is not null, then recursively call the `postorder` function for the left child of the root node and then for the right child of the root node. - After visiting the left and right child, push the value of the root node into the vector `v`. - Finally, return the vector `v` containing the postorder traversal of the binary tree. ","date":"August 26, 2024","permalink":"/blog/posts/extraques/problem-145-binary-tree-postorder-traversal/","summary":"Problem Statement Link - Problem 145 Question Given the root of a binary tree, return the postorder traversal of its nodes\u0026rsquo; values.","title":"Problem 145 Binary Tree Postorder Traversal","type":"posts"},{"content":" Problem Statement Link - Problem 590 Question Given the root of an n-ary tree, return the postorder traversal of its nodes\u0026rsquo; values.\nNary-Tree input serialization is represented in their level order traversal. Each group of children is separated by the null value (See examples)\nExample 1 Input: root = [1,null,3,2,4,null,5,6] Output: [5,6,3,2,4,1] Example 2 Input: root = [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14] Output: [2,6,14,11,7,3,12,8,4,13,9,10,5,1] Constraints - `The number of nodes in the tree is in the range [0, 10^4].` - `0 \u0026lt;= Node.val \u0026lt;= 10^4` - `The height of the n-ary tree is less than or equal to 1000`. NOTE Reminder:\nPREorder: ROOT|Left|Right INorder: Left|ROOT|Right POSTorder: Left|Right|ROOT In case of an N-ary Tree, POSTorder is: Child1|Child2|\u0026hellip;|ChildN|ROOT Solution /* // Definition for a Node. class Node { public: int val; vector\u0026lt;Node*\u0026gt; children; Node() {} Node(int _val) { val = _val; } Node(int _val, vector\u0026lt;Node*\u0026gt; _children) { val = _val; children = _children; } }; */ class Solution { public: void traverse(Node* root, vector\u0026lt;int\u0026gt;\u0026amp; v){ if(!root) return; for(auto it:root-\u0026gt;children) traverse(it,v); v.push_back(root-\u0026gt;val); } vector\u0026lt;int\u0026gt; postorder(Node* root) { vector\u0026lt;int\u0026gt; ans; traverse(root,ans); return ans; } }; Complexity Analysis | Algorithm | Time Complexity | Space Complexity | | ------------------- | --------------- | ---------------- | | Postorder Traversal | O(N) | O(N) | Explanation 1. Intuition - Idea is to visit all the children of a node first and then visit the node itself. - So iterate over the children and call the function recursively. - Finally, push the value of the node into the vector. 2. Implementation - Intialize a vector `ans` to store the postorder traversal. - Call the `traverse` function with the root and the vector. - Return `ans`. - In `traverse` function: - If the root is NULL, return. - Iterate over the children of the root and call the `traverse` function recursively. - Push the value of the root into the vector. ","date":"August 26, 2024","permalink":"/blog/leetcode-potd/problem-590-n-ary-tree-postorder-traversal/","summary":"Problem Statement Link - Problem 590 Question Given the root of an n-ary tree, return the postorder traversal of its nodes\u0026rsquo; values.","title":"Problem 590 N Ary Tree Postorder Traversal","type":"leetcode-potd"},{"content":" Problem Statement Link - Problem 3265 Question You are given an array nums consisting of positive integers.\nWe call two integers x and y in this problem almost equal if both integers can become equal after performing the following operation at most once:\nChoose either x or y and swap any two digits within the chosen number. Return the number of indices i and j in nums where i \u0026lt; j such that nums[i] and nums[j] are almost equal.\nNote that it is allowed for an integer to have leading zeros after performing an operation.\nExample 1 Input: nums = [3,12,30,17,21] Output: 2 Explanation: The almost equal pairs of elements are: 3 and 30. By swapping 3 and 0 in 30, you get 3. 12 and 21. By swapping 1 and 2 in 12, you get 21. Example 2 Input: nums = [1,1,1,1,1] Output: 10 Explanation: Every two elements in the array are almost equal. Example 3 Input: nums = [123,231] Output: 0 Explanation: We cannot swap any two digits of 123 or 231 to reach the other. Constraints - `2 \u0026lt;= nums.length \u0026lt;= 100` - `1 \u0026lt;= nums[i] \u0026lt;= 10^6` Solution class Solution { public: bool helper(int a, int b) { string sa = to_string(a); string sb = to_string(b); int maxLen = max(sa.length(), sb.length()); sa = string(maxLen - sa.length(), \u0026#39;0\u0026#39;) + sa; sb = string(maxLen - sb.length(), \u0026#39;0\u0026#39;) + sb; if (sa == sb) return true; int diffCount = 0; int firstDiff = -1, secondDiff = -1; for (int i = 0; i \u0026lt; maxLen; i++) { if (sa[i] != sb[i]) { diffCount++; if (diffCount == 1) firstDiff = i; else if (diffCount == 2) secondDiff = i; else return false; } } return diffCount == 2 \u0026amp;\u0026amp; sa[firstDiff] == sb[secondDiff] \u0026amp;\u0026amp; sa[secondDiff] == sb[firstDiff]; } int countPairs(vector\u0026lt;int\u0026gt;\u0026amp; nums) { int count = 0; int n = nums.size(); for (int i = 0; i \u0026lt; n - 1; i++) { for (int j = i + 1; j \u0026lt; n; j++) { if (helper(nums[i], nums[j])) { count++; } } } return count; } }; Complexity Analysis | Algorithm | Time Complexity | Space Complexity | | --------- | --------------- | ---------------- | | Main loop | O(n^2) | O(1) | | Helper | O(maxLen) | O(1) | Explanation 1. Intuition - We need to take two numbers (along with preceeding zeros) and check if they are almost equal. - A number can be almost equal to another number if we can swap any two digits of the number to make it equal to the other number. - If more than two digits are different, then we cannot make them equal. - And we can swap only once. - So, we need to check if we can swap any two digits of the number to make it equal to the other number. - If we can, then we increment the count. - Its better to handle the numbers as strings, as we can easily swap the digits. - We can compare the lengths of the strings and add the preceeding zeros to the smaller string. - Then parse the strings and check how many different digits are there. - If there are more than two different digits, then we cannot make them equal. - If there are exactly two different digits, then check if they can be swapped to make the numbers equal. 2. Implementation - Define a `helper` function to check if two numbers are almost equal. - Input: two integers `a` and `b`. - Convert the integers to strings `sa` and `sb`. - Find the maximum length of the strings. - Add the preceeding zeros to the smaller string. - If the strings are equal, return `true`. - Initialize the `diffCount` to `0`. - Initialize the `firstDiff` and `secondDiff` to `-1`. This will store the indices of the different digits. - Iterate over the strings: - If the digits are different: - Increment the `diffCount`. - If the `diffCount` is `1`, store the index in `firstDiff`. - If the `diffCount` is `2`, store the index in `secondDiff`. - If the `diffCount` is more than `2`, return `false`. - Return `true` if the `diffCount` is `2` and if `sa[firstDiff] == sb[secondDiff] and sa[secondDiff] == sb[firstDiff]`. - Define a `countPairs` function to count the almost equal pairs. - Input: a vector of integers `nums`. - Initialize the `count` to `0`. - Initialize the `n` to the size of the `nums`. - Iterate over the `nums`: - Iterate over the `nums` starting from the next element: - If the `helper` function returns `true`, increment the `count`. - Return the `count`. There is a follow-up problem to this problem. Problem 3267 .\n","date":"August 25, 2024","permalink":"/blog/posts/leetcode-contest/problem-3265-count-almost-equal-pairs-i/","summary":"Problem Statement Link - Problem 3265 Question You are given an array nums consisting of positive integers.","title":"Problem 3265 Count Almost Equal Pairs I","type":"posts"},{"content":" Problem Statement Link - Problem 3264 Question You are given an integer array nums, an integer k, and an integer multiplier.\nYou need to perform k operations on nums. In each operation:\nFind the minimum value x in nums. If there are multiple occurrences of the minimum value, select the one that appears first. Replace the selected minimum value x with x * multiplier. Return an integer array denoting the final state of nums after performing all k operations.\nExample 1 Input: nums = [1,2], k = 3, multiplier = 4 Output: [16,8] Explanation: | Operation | Result | | ----------------- | ------- | | After operation 1 | [4, 2] | | After operation 2 | [4, 8] | | After operation 3 | [16, 8] | Example 2 Input: nums = [2,1,3,5,6], k = 5, multiplier = 2 Output: [8,4,6,5,6] | Operation | Array | | ----------------- | --------------- | | After operation 1 | [2, 2, 3, 5, 6] | | After operation 2 | [4, 2, 3, 5, 6] | | After operation 3 | [4, 4, 3, 5, 6] | | After operation 4 | [4, 4, 6, 5, 6] | | After operation 5 | [8, 4, 6, 5, 6] | Constraints - `1 \u0026lt;= nums.length \u0026lt;= 100` - `1 \u0026lt;= nums[i] \u0026lt;= 100` - `1 \u0026lt;= k \u0026lt;= 10` - `1 \u0026lt;= multiplier \u0026lt;= 5` Solution // Brute Force class Solution { public: vector\u0026lt;int\u0026gt; getFinalState(vector\u0026lt;int\u0026gt;\u0026amp; nums, int k, int multiplier) { for (int i = 0; i \u0026lt; k; i++) { int minIndex = 0; for (int j = 1; j \u0026lt; nums.size(); j++) { if (nums[j] \u0026lt; nums[minIndex]) { minIndex = j; } } nums[minIndex] *= multiplier; } return nums; } }; // Min Heap class Solution { public: vector\u0026lt;int\u0026gt; getFinalState(vector\u0026lt;int\u0026gt;\u0026amp; nums, int k, int multiplier) { int n = nums.size(); priority_queue\u0026lt;pair\u0026lt;int, int\u0026gt;, vector\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt;, greater\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt;\u0026gt; pq; for (int i = 0; i \u0026lt; n; ++i) { pq.push({nums[i], i}); } while (k \u0026gt; 0) { auto [val, idx] = pq.top(); pq.pop(); val = (val * multiplier); pq.push({val, idx}); k--; } vector\u0026lt;int\u0026gt; result(n); while (!pq.empty()) { auto [val, idx] = pq.top(); pq.pop(); result[idx] = val; } return result; } }; Complexity Analysis | Algorithm | Time Complexity | Space Complexity | | --------- | --------------- | ---------------- | | Brute | O(kn) | O(1) | | Min Heap | O(nlogn) | O(n) | Explanation 1. Intuition - In brute force we need to find the minimum element in the array then multiply it with the multiplier. - First traverse the entire array to find the index of the minimum element. - Then multiply the element at that index with the multiplier. - In the min heap approach, we can use a min heap to store elements and their indices. - We can pop the top element from the heap and multiply it with the multiplier. - Then push the new element back into the heap. - Repeat this process for k times. - Finally, we can construct the final array from the heap. 2. Implementation - For the brute force approach - Iterate over the array for k times. - Find the index of the minimum element in the array. - Multiply the element at that index with the multiplier. - Return the final array. - For the min heap approach - Initialize a min heap `pq` of type `pair\u0026lt;int, int\u0026gt;, vector\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt;, greater\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt;`. - Iterate over the array and push the elements along with their indices to the heap. - Iterate from `0` to `k`: - Get the top element from the heap and store it in `val` and `idx`. - Multiply the `val` with the multiplier. - Push the new element back into the heap. - Initialize a vector `result` of size `n`. - Iterate over the heap and store the elements in the `result`. - Return the `result`. There is a follow up question for this problem, Problem 3266 .\n","date":"August 25, 2024","permalink":"/blog/posts/leetcode-contest/problem-3264-final-array-state-after-k-multiplication-operations-i/","summary":"Problem Statement Link - Problem 3264 Question You are given an integer array nums, an integer k, and an integer multiplier.","title":"Problem 3264 Final Array State After K Multiplication Operations I","type":"posts"},{"content":" Problem Statement Link - Problem 264 Question An ugly number is a positive integer whose prime factors are limited to 2, 3, and 5.\nGiven an integer n, return the nth ugly number.\nExample 1 Input: n = 10 Output: 12 Explanation: [1, 2, 3, 4, 5, 6, 8, 9, 10, 12] is the sequence of the first 10 ugly numbers. Example 2 Input: n = 1 Output: 1 Explanation: 1 has no prime factors, therefore all of its prime factors are limited to 2, 3, and 5. Constraints - `1 \u0026lt;= n \u0026lt;= 1690` Solution class Solution { public: int nthUglyNumber(int n) { vector\u0026lt;int\u0026gt; primes = {2, 3, 5}; priority_queue\u0026lt;long, vector\u0026lt;long\u0026gt;, greater\u0026lt;long\u0026gt;\u0026gt; uglyHeap; unordered_set\u0026lt;long\u0026gt; visited; uglyHeap.push(1); visited.insert(1); long curr; for (int i = 0; i \u0026lt; n; ++i) { curr = uglyHeap.top(); uglyHeap.pop(); for (int prime : primes) { long new_ugly = curr * prime; if (visited.find(new_ugly) == visited.end()) { uglyHeap.push(new_ugly); visited.insert(new_ugly); } } } return (int)curr; } }; Complexity Analysis | Algorithm | Time Complexity | Space Complexity | | --------- | --------------- | ---------------- | | Min Heap | O(nlogn) | O(n) | Explanation 1. Intuition - There is a crude approach to solve this by generating the ugly numbers, till we reach the `n`th ugly number. - Since the given constraints say that each number\u0026#39;s prime factors are limited to `2`, `3`, and `5`, we can generate the ugly numbers by multiplying the previous ugly number with `2`, `3`, and `5`. - Each time we need to find the minimum ugly number then generate the next set of ugly numbers. - So lets have a min heap to store the ugly numbers. - To keep track of ugly numbers already generated, we can use a set. this prevents us from generating the same ugly number multiple times. - We can start with the first ugly number `1` and push it to the heap. - Then we can generate the next ugly numbers by multiplying the current ugly number with `2`, `3`, and `5`. - Push the new ugly numbers to the heap and keep track of them in the set. - We can repeat this process till we reach the `n`th ugly number. 2. Implementation - Initialize a vector of primes `{2, 3, 5}`. - Initialize a min heap `uglyHeap` of type `long` and a set `visited` of type `long`. - Push the first ugly number `1` to the heap and insert it into the set. - Initialize a variable `curr` to store the current ugly number. - Iterate from `0` to `n`: - Get the top element from the heap and store it in `curr`. - Pop the top element from the heap. - Iterate over the primes: - Multiply the current ugly number with the prime and store it in `new_ugly`. - If the new ugly number is not present in the set: - Push the new ugly number to the heap. - Insert the new ugly number into the set. - Return the current ugly number. There is also a dynamic programming approach to solve this problem.\nDP Solution class Solution { public: int nthUglyNumber(int n) { vector\u0026lt;int\u0026gt; primes = {2, 3, 5}; // Initialize the primes array vector\u0026lt;int\u0026gt; indices = {0, 0, 0}; // Initialize indices for multiples of 2, 3, 5 vector\u0026lt;int\u0026gt; uglyArr(1, 1); // Initialize the ugly number array with 1 for (int i = 1; i \u0026lt; n; ++i) { // Calculate the next possible ugly numbers vector\u0026lt;int\u0026gt; next_uglies = { uglyArr[indices[0]] * primes[0], uglyArr[indices[1]] * primes[1], uglyArr[indices[2]] * primes[2] }; int min_value = *min_element(next_uglies.begin(), next_uglies.end()); // Find the smallest value uglyArr.push_back(min_value); // Append the smallest value to uglyArr // Update indices for primes that generated the current min_value for (int j = 0; j \u0026lt; 3; ++j) { if (next_uglies[j] == min_value) { ++indices[j]; } } } return uglyArr[n - 1]; } }; Explanation The above code generates the nth ugly number using dynamic programming.\n- We initialize the primes array with `2`, `3`, and `5`. - We also initialize the indices array with `0`, `0`, and `0` to keep track of the multiples of `2`, `3`, and `5`. - Indicies array will keep track of the next ugly number to be generated for each prime. - We initialize the ugly number array with `1`. - We iterate from `1` to `n`: - Calculate the next possible ugly numbers by multiplying the current ugly numbers with the primes. - Find the smallest value from the next possible ugly numbers. - Append the smallest value to the ugly number array. - Update the indices for the primes that generated the current smallest value. - Return the `n`th ugly number. ","date":"August 24, 2024","permalink":"/blog/leetcode-potd/problem-264-ugly-number-ii/","summary":"Problem Statement Link - Problem 264 Question An ugly number is a positive integer whose prime factors are limited to 2, 3, and 5.","title":"Problem 264 Ugly Number II","type":"leetcode-potd"},{"content":" Problem Statement Link - Problem 592 Question Given a string expression representing an expression of fraction addition and subtraction, return the calculation result in string format.\nThe final result should be an irreducible fraction. If your final result is an integer, change it to the format of a fraction that has a denominator 1. So in this case, 2 should be converted to 2/1.\nIrreducible fraction Example 1 Input: expression = \u0026#34;-1/2+1/2\u0026#34; Output: \u0026#34;0/1\u0026#34; Example 2 Input: expression = \u0026#34;-1/2+1/2+1/3\u0026#34; Output: \u0026#34;1/3\u0026#34; Example 3 Input: expression = \u0026#34;1/3-1/2\u0026#34; Output: \u0026#34;-1/6\u0026#34; Constraints - The input string only contains `\u0026#39;0\u0026#39;` to `\u0026#39;9\u0026#39;`, `\u0026#39;/\u0026#39;`, `\u0026#39;+\u0026#39;` and `\u0026#39;-\u0026#39;`. So does the output. - Each fraction (input and output) has the format `±numerator/denominator`. If the first input fraction or the output is positive, then `\u0026#39;+\u0026#39;` will be omitted. - The input only contains valid irreducible fractions, where the numerator and denominator of each fraction will always be in the range `[1, 10]`. If the denominator is `1`, it means this fraction is actually an integer in a fraction format defined above. - The number of given fractions will be in the range `[1, 10]`. - The numerator and denominator of the final result are guaranteed to be valid and in the range of 32-bit int. Solution class Solution { public: string fractionAddition(string exp) { int numer = 0, denom = 1; int idx = 0; int size = exp.size(); while(idx\u0026lt;size){ int sign = 1; if(exp[idx] == \u0026#39;+\u0026#39; || exp[idx] == \u0026#39;-\u0026#39;){ if(exp[idx]==\u0026#39;-\u0026#39;) sign = -1; idx++; } int num = 0; while(idx\u0026lt;size \u0026amp;\u0026amp; isdigit(exp[idx])){ num = num*10 + (exp[idx]-\u0026#39;0\u0026#39;); idx++; } num*=sign; idx++; int den = 0; while(idx\u0026lt;size \u0026amp;\u0026amp; isdigit(exp[idx])){ den = den*10 + (exp[idx]-\u0026#39;0\u0026#39;); idx++; } numer = numer*den + num*denom; denom = denom*den; int GCD = gcd(abs(numer),denom); numer /= GCD; denom /= GCD; } return to_string(numer)+\u0026#39;/\u0026#39;+to_string(denom); } }; Complexity Analysis | Algorithm | Time Complexity | Space Complexity | | --------- | --------------- | ---------------- | | Traversal | O(n) | O(1) | Explanation 1. Intuition - We will use the normal logic of adding fractions. - Two fractions can be added by taking the LCM of the denominators and then adding the numerators. - that is `a/b + c/d = (a*d + b*c)/(b*d)` - We can make the fraction irreducible by dividing the numerator and denominator by their GCD. - We will keep on adding the fractions and then at the end we will return the final fraction. 2. Implementation - Initialize `numer` and `denom` to `0` and `1` respectively. - Initialize `idx` to `0` and `size` to the size of the input string. - While `idx` is less than `size` do : - Initialize `sign` to `1`. - If the character at `idx` is `\u0026#39;+\u0026#39;` or `\u0026#39;-\u0026#39;` then do the following: - If the character is `\u0026#39;-\u0026#39;` then set `sign` to `-1`. - Increment `idx`. - Initialize `num` to `0`. This is the numerator of the fraction. - While `idx` is less than `size` and the character at `idx` is a digit do the following: - Multiply `num` by `10` and add the digit at `idx` to `num`. - Increment `idx`. - Multiply `num` by `sign`. - Increment `idx`. - Initialize `den` to `0`. This is the denominator of the fraction. - While `idx` is less than `size` and the character at `idx` is a digit do the following: - Multiply `den` by `10` and add the digit at `idx` to `den`. - Increment `idx`. - Update `numer` and `denom` using the formula: - `numer = numer * den + num * denom`. - `denom = denom * den`. - Calculate the GCD of `abs(numer)` and `denom`. - Divide `numer` and `denom` by the GCD. - Return the final fraction as a string. ","date":"August 23, 2024","permalink":"/blog/leetcode-potd/problem-592-fraction-addition-and-subtraction/","summary":"Problem Statement Link - Problem 592 Question Given a string expression representing an expression of fraction addition and subtraction, return the calculation result in string format.","title":"Problem 592 Fraction Addition and Subtraction","type":"leetcode-potd"},{"content":" Problem Statement Link - Problem 476 Question The complement of an integer is the integer you get when you flip all the 0\u0026rsquo;s to 1\u0026rsquo;s and all the 1\u0026rsquo;s to 0\u0026rsquo;s in its binary representation.\nFor example, The integer 5 is \u0026quot;101\u0026quot; in binary and its complement is \u0026quot;010\u0026quot; which is the integer 2. Given an integer num, return its complement.\nExample 1 Input: num = 5 Output: 2 Explanation: The binary representation of 5 is 101 (no leading zero bits), and its complement is 010. So you need to output 2. Example 2 Input: num = 1 Output: 0 Explanation: The binary representation of 1 is 1 (no leading zero bits), and its complement is 0. So you need to output 0. Constraints - `1 \u0026lt;= num \u0026lt; 2^31` Solution class Solution { public: int findComplement(int num) { int ans = num; int bitcnt = 0; while(num\u0026gt;0){ num = num\u0026gt;\u0026gt;1; bitcnt++; } //cout\u0026lt;\u0026lt;bitcnt\u0026lt;\u0026lt;endl; //ans = ans^((1LL\u0026lt;\u0026lt;bitcnt)-1); // to avoid Integer overflow we use 1LL ( long long 1 ) so that huge numbers can be handled when bit shifted. ans = ans^(int)(pow(2,bitcnt)-1); return ans; } }; Complexity Analysis | Algorithm | Time Complexity | Space Complexity | | ---------------- | --------------- | ---------------- | | Bit manipulation | O(log2(n)) | O(1) | Explanation 1. Intuition - To get the complement of a given number we first take its binary representation. - Then we need to flip all the bits of the number. - This can be achieved by doing the following 1. Find the number of bits in the number. 2. XOR it with all 1\u0026#39;s of the same number of bits. 3. This will generate the complement of given number - This is due the fact of XOR operation - 0^0 = 0 - 0^1 = 1 - 1^0 = 1 - 1^1 = 0 - num ^ ~num = set bits of bitcount of num Hence `num ^ set bits of bitcount of num = ~num` - Number of set bits of count `n` can be generated by `2^n - 1` - Example if num = 5 In binary 5 = 101 bitcount = 3 then number of set bits of 3 = 2^3 - 1 = 8 - 1 = 7 = 111 101 ^ 111 = 010 010 = 2 Hence the complement is 2 2. Implementation - Initialize a variable `ans` with the value of `num`. - Initialize a variable `bitcnt` with the value of 0. - While `num` is greater than 0, do the following: - Right shift `num` by 1. - Increment `bitcnt` by 1. - Calculate the complement of `num` using the following formula: - `ans = ans ^ (int)(pow(2, bitcnt) - 1)`. - Return `ans`. ","date":"August 22, 2024","permalink":"/blog/leetcode-potd/problem-476-number-complement/","summary":"Problem Statement Link - Problem 476 Question The complement of an integer is the integer you get when you flip all the 0\u0026rsquo;s to 1\u0026rsquo;s and all the 1\u0026rsquo;s to 0\u0026rsquo;s in its binary representation.","title":"Problem 476 Number Complement","type":"leetcode-potd"},{"content":" Problem Statement Link - Problem 3238 Question You are given an integer n representing the number of players in a game and a 2D array pick where pick[i] = [xi, yi] represents that the player xi picked a ball of color yi.\nPlayer i wins the game if they pick strictly more than i balls of the same color. In other words,\nPlayer 0 wins if they pick any ball. Player 1 wins if they pick at least two balls of the same color. Player i wins if they pick at least i + 1 balls of the same color. Return the number of players who win the game. Note that multiple players can win the game. Example 1 Input: n = 4, pick = [[0,0],[1,0],[1,0],[2,1],[2,1],[2,0]] Output: 2 Explanation: Player 0 and player 1 win the game, while players 2 and 3 do not win. Example 2 Input: n = 5, pick = [[1,1],[1,2],[1,3],[1,4]] Output: 0 Explanation: No player wins the game. Example 3 Input: n = 5, pick = [[1,1],[2,4],[2,4],[2,4]] Output: 1 Explanation: Player 2 wins the game by picking 3 balls with color 4. Constraints - `2 \u0026lt;= n \u0026lt;= 10` - `1 \u0026lt;= pick.length \u0026lt;= 100` - `pick[i].length == 2` - `0 \u0026lt;= xi \u0026lt;= n - 1` - `0 \u0026lt;= yi \u0026lt;= 10` Solution class Solution { public: int winningPlayerCount(int n, vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; pick) { vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;cnt(n,vector\u0026lt;int\u0026gt;(11,0)); for(auto \u0026amp;it:pick){ cnt[it[0]][it[1]]++; } int ans = 0; for(int i=0;i\u0026lt;n;i++){ for(int j=0;j\u0026lt;11;j++){ //cout\u0026lt;\u0026lt;cnt[i][j]\u0026lt;\u0026lt;\u0026#34; \u0026#34;; if(cnt[i][j]\u0026gt;i){ ans++; break; } } //cout\u0026lt;\u0026lt;endl; } return ans; } }; Complexity Analysis | Algorithm | Time Complexity | Space Complexity | | --------- | --------------- | ---------------- | | Traversal | O(10n) | O(10n) | Explanation 1. Intuition - We need to keep track of two things 1. How many balls are picked up by player `xi`. 2. How many balls of color `yi` are picked up . - This can be modelled as a 2D array `cnt` where `cnt[i][j]` represents the number of balls of color `j` picked up by player `i`. - Iterate over the `pick` array and update the `cnt` array. - Iterate over the `cnt` array and check if the player has picked up more than `i` balls of the same color. - If yes, increment the answer. - Return the answer. 2. Implementation - Initialize a 2D array `cnt` of size `n x 11` with all elements as `0`. - Iterate over the `pick` array and update the `cnt` array. - Initialize a variable `ans` to `0`. - For each player `i` from `0` to `n-1`, - For each color `j` from `0` to `10`, - If the player has picked up more than `i` balls of the same color, - Increment the answer. - Break the inner loop. // to avoid double counting. - Return the answer. ","date":"August 21, 2024","permalink":"/blog/posts/extraques/problem-3238-find-the-number-of-winning-players/","summary":"Problem Statement Link - Problem 3238 Question You are given an integer n representing the number of players in a game and a 2D array pick where pick[i] = [xi, yi] represents that the player xi picked a ball of color yi.","title":"Problem 3238 Find the Number of Winning Players","type":"posts"},{"content":" Process Vs Thread [Popular Interview Question] A process is an independent unit of execution with its own memory space, while a thread is a lightweight unit of execution that shares memory space with other threads within the same process.\nProcess A process is an independent, self-contained unit of execution that has its own memory space, including the code segment, data segment, heap, and stack.\nAddress Space: Each process operates in its own virtual address space, meaning it has its own separate memory layout and cannot directly access the memory of another process without inter-process communication (IPC).\nResource Allocation: Processes are heavyweight entities as they require a significant amount of overhead to create, manage, and destroy. Each process has its own set of resources like file descriptors, memory pages, and other system resources.\nIsolation: Processes are isolated from each other. This isolation is enforced by the operating system, which prevents one process from corrupting another process’s memory or resources.\nContext Switching: The switch between processes, known as context switching, involves saving and loading the state of the process, including its CPU registers, memory map, and other resources, which makes context switching between processes relatively expensive.\nThread A thread, also known as a lightweight process (LWP), is the smallest execution unit within a process. A single process can have multiple threads, all of which share the same memory space but execute independently.\nShared Memory: Threads within the same process share the same address space, which includes the code segment, data segment, and heap. However, each thread has its stack and registers.\nResource Sharing: Threads are more lightweight than processes because they share most of their resources with other threads within the same process. This includes open files, signal handlers, and memory.\nEfficiency: Since threads within the same process share memory and resources, context switching between threads is faster and more efficient compared to processes. The overhead is lower as there’s no need to switch the memory map or reallocate resources.\nCommunication: Threads can communicate with each other more efficiently through shared memory because they reside in the same address space. However, this also means that threads can potentially corrupt each other’s memory if not managed properly.\nKey Differences Isolation:\nProcesses are isolated, while threads share the same memory space within a process. Resource Usage: Processes are heavyweight and require more resources to manage, whereas threads are lightweight and share most resources. Context Switching:\nSwitching between processes is more costly than switching between threads due to the need to manage separate memory spaces and resources. ","date":"August 20, 2024","permalink":"/blog/core-subjects/process-vs-threads/","summary":"Process Vs Thread [Popular Interview Question] A process is an independent unit of execution with its own memory space, while a thread is a lightweight unit of execution that shares memory space with other threads within the same process.","title":"Process vs Threads","type":"core-subjects"},{"content":" Problem Statement Link - Problem 650 Question There is only one character 'A' on the screen of a notepad. You can perform one of two operations on this notepad for each step:\nCopy All: You can copy all the characters present on the screen (a partial copy is not allowed). Paste: You can paste the characters which are copied last time. Given an integer n, return the minimum number of operations to get the character 'A' exactly n times on the screen.\nExample 1 Input: n = 3 Output: 3 Explanation: Initially, we have one character \u0026#39;A\u0026#39;. In step 1, we use Copy All operation. In step 2, we use Paste operation to get \u0026#39;AA\u0026#39;. In step 3, we use Paste operation to get \u0026#39;AAA\u0026#39;. Example 2 Input: n = 1 Output: 0 Constraints - `1 \u0026lt;= n \u0026lt;= 1000` Solution // Recusrive solution class Solution { private: int targetLength; int findMinSteps(int currentLength, int clipboardLength) { if (currentLength == targetLength) return 0; if (currentLength \u0026gt; targetLength) return INT_MAX / 2; int copyAndPaste = 2 + findMinSteps(currentLength * 2, currentLength); int pasteOnly = 1 + findMinSteps(currentLength + clipboardLength, clipboardLength); return min(copyAndPaste, pasteOnly); } public: int minSteps(int n) { if (n == 1) return 0; targetLength = n; return 1 + findMinSteps(1, 1); } }; // Using memoization class Solution { private: int targetLength; vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; cache; int calculateMinOps(int currentLength, int clipboardLength) { if (currentLength == targetLength) return 0; if (currentLength \u0026gt; targetLength) return INT_MAX / 2; if (cache[currentLength][clipboardLength] != -1) { return cache[currentLength][clipboardLength]; } int pasteOption = 1 + calculateMinOps(currentLength + clipboardLength, clipboardLength); int copyPasteOption = 2 + calculateMinOps(currentLength * 2, currentLength); int result = min(pasteOption, copyPasteOption); cache[currentLength][clipboardLength] = result; return result; } public: int minSteps(int n) { if (n == 1) return 0; targetLength = n; cache = vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;(n + 1, vector\u0026lt;int\u0026gt;(n / 2 + 1, -1)); return 1 + calculateMinOps(1, 1); } }; // Using factorization class Solution { public: int minSteps(int n) { if (n == 1) return 0; int sqrtN = sqrt(n); int total_operations = 0; for (int factor = 2; factor \u0026lt;= sqrtN; factor++) { while (n % factor == 0) { total_operations += factor; n /= factor; } } if (n \u0026gt; 1) { total_operations += n; } return total_operations; } }; Complexity Analysis | Algorithm | Time Complexity | Space Complexity | | ------------- | --------------- | ---------------- | | Memoization | O(n^2) | O(n^2) | | Factorization | O(sqrt(n)) | O(1) | Explanation 1. Intuition - This is for dynamic programming - In this method, we can build a recursive function as follows - Let `f(x,y)` be the minimum number of operations to get the character \u0026#39;A\u0026#39; exactly `x` times on the screen with `y` characters in the clipboard. - We can copy all the characters present on the screen and paste them to get `2x` characters on the screen and `x` characters in the clipboard. This operation takes `2` steps. - Or we can paste the characters which are copied last time to get `x+y` characters on the screen and `y` characters in the clipboard. This operation takes `1` step. - The base case will be when `x` is equal to the target length, we return `0`. - If not base case then we need to return the minimum of `2 + f(2*x,x)` and `1 + f(x+y,y)`. - Using the above recursive function we can design a DP solution. - use a 2D array to store the minimum operations for each `x` and `y`. - `dp[x][y]` will denote the minimum number of operations to get the character \u0026#39;A\u0026#39; exactly `x` times on the screen with `y` characters in the clipboard. - This is for factorization method - By observation we can say the following things 1. If n is prime then the minimum number of operations will be n. We can build `n` by copying once and pasting `n-1` times. 2. If `n` is a power of a prime number `p`, then the minimum number of operations will be `p`. This is because we can first build `p` by copying once and pasting `p-1` times. Then we can build `n` by copying `p` and pasting `n/p-1` times. 3. If `n` is not a power of a prime number, then we can factorize `n` into prime numbers. The minimum number of operations will be the sum of the prime factors. This is because we can build `n` by copying the prime factors and pasting the prime factors-1 times. - We can iterate from `2` to `sqrt(n)` and check if `n` is divisible by `i`. While `n` is divisible by `i`, we can add `i` to the total operations and divide `n` by `i`. - This will not consider non prime factors of `n`. Because if `i` is not a prime factor of `n`, then `n/i` will be a prime factor of `n`. - Finally, we can return the total operations. 2. Implementation - For memoization, we can use a 2D array to store the minimum operations for each `x` and `y`. - Declare the `targetLength` and `cache` as variables. - Write a recursive function `calculateMinOps` to calculate the minimum operations. - In the recursive function, we can check if the current length is equal to the target length. - If the current length is greater than the target length, we can return `INT_MAX / 2`. - If the current length is equal to the target length, we can return `0`. - If the value of `cache[currentLength][clipboardLength]` is not `-1`, we can return the value. - Otherwise, we can calculate the minimum operations for the two options. - `pasteOption` = 1 + `calculateMinOps(currentLength + clipboardLength, clipboardLength)` - `copyPasteOption` = 2 + `calculateMinOps(currentLength * 2, currentLength)` - `cache[currentLength][clipboardLength]` will be updated with the minimum of the two options. - Finally, we can return the minimum of the two options. - Initialize the variable `total_operations` to `0`. - Iterate from `2` to `sqrt(n)` and check if `n` is divisible by `i`. - while `n` is divisible by `i`, add `i` to the `total_operations` and divide `n` by `i`. - If `n` is greater than `1`, add `n` to the `total_operations`. - This will handle the case where `n` is itself a prime number. - Finally, return the `total_operations`. ","date":"August 19, 2024","permalink":"/blog/leetcode-potd/problem-650-2-keys-keyboard/","summary":"Problem Statement Link - Problem 650 Question There is only one character 'A' on the screen of a notepad.","title":"Problem 650 2 Keys Keyboard","type":"leetcode-potd"},{"content":" Problem Statement Link - Problem 3259 Question You are given two integer arrays energyDrinkA and energyDrinkB of the same length n by a futuristic sports scientist. These arrays represent the energy boosts per hour provided by two different energy drinks, A and B, respectively.\nYou want to maximize your total energy boost by drinking one energy drink per hour. However, if you want to switch from consuming one energy drink to the other, you need to wait for one hour to cleanse your system (meaning you won\u0026rsquo;t get any energy boost in that hour).\nReturn the maximum total energy boost you can gain in the next n hours.\nNote that you can start consuming either of the two energy drinks.\nExample 1 Input: energyDrinkA = [1,3,1], energyDrinkB = [3,1,1] Output: 5 Explanation: To gain an energy boost of 5, drink only the energy drink A (or only B). Example 2 Input: energyDrinkA = [4,1,1], energyDrinkB = [1,1,3] Output: 7 Explanation: To gain an energy boost of 7: Drink the energy drink A for the first hour. Switch to the energy drink B and we lose the energy boost of the second hour. Gain the energy boost of the drink B in the third hour. Constraints - `n == energyDrinkA.length == energyDrinkB.length` - `3 \u0026lt;= n \u0026lt;= 10^5` - `1 \u0026lt;= energyDrinkA[i], energyDrinkB[i] \u0026lt;= 10^5` Solution // Memoization class Solution { public: long long helper(vector\u0026lt;int\u0026gt;\u0026amp; a, vector\u0026lt;int\u0026gt;\u0026amp; b, int i, int k, vector\u0026lt;vector\u0026lt;long long\u0026gt;\u0026gt;\u0026amp;dp){ if(i == a.size()){ return 0; } if(dp[k][i] != -1) return dp[k][i]; long long take = 0, nottake = 0; if(k == 1){ take = a[i] + helper(a,b,i+1,k,dp); nottake = helper(a,b,i+1,2,dp); } else if(k == 2){ take = b[i] + helper(a,b,i+1,k,dp); nottake = helper(a,b,i+1,1,dp); } return dp[k][i] = max(take,nottake); } long long maxEnergyBoost(vector\u0026lt;int\u0026gt;\u0026amp; a, vector\u0026lt;int\u0026gt;\u0026amp; b) { vector\u0026lt;vector\u0026lt;long long\u0026gt;\u0026gt;dp(3 , vector\u0026lt;long long\u0026gt;(a.size() , -1)); return max(helper(a,b,0,1,dp) , helper(a,b,0,2,dp)); } }; // Tabulation class Solution { public: long long maxEnergyBoost(vector\u0026lt;int\u0026gt;\u0026amp; A, vector\u0026lt;int\u0026gt;\u0026amp; B) { int n = A.size(); vector\u0026lt;vector\u0026lt;long long\u0026gt;\u0026gt; dp(n + 5, vector\u0026lt;long long\u0026gt;(2, 0)); for(int i = n - 1; i \u0026gt;= 0; i--){ dp[i][0] = max(B[i] + dp[i + 1][0], dp[i + 1][1]); dp[i][1] = max(A[i] + dp[i + 1][1], dp[i + 1][0]); } return max(dp[0][0], dp[0][1]); } }; // Optimized Tabulation class Solution { public: long long maxEnergyBoost(std::vector\u0026lt;int\u0026gt;\u0026amp; energyDrinkA, std::vector\u0026lt;int\u0026gt;\u0026amp; energyDrinkB) { int n = energyDrinkA.size(); long long dpA = energyDrinkA[0], dpB = energyDrinkB[0]; for (int i = 1; i \u0026lt; n; ++i) { long long newDpA = max(dpA + energyDrinkA[i], dpB); long long newDpB = max(dpB + energyDrinkB[i], dpA); dpA = newDpA; dpB = newDpB; } return max(dpA, dpB); } }; Complexity Analysis | Algorithm | Time Complexity | Space Complexity | | -------------------- | --------------- | ---------------- | | Memoization | O(n) | O(n) | | Tabulation | O(n) | O(n) | | Optimized Tabulation | O(n) | O(1) | Explanation 1. Intuition - We can start from either of the two energy drinks. - Since the condition says we need to give an hour gap to switch between drinks, we can keep track of the maximum energy boost we can get from each drink. - We can use dynamic programming to solve this problem. - Two variables `dpA` and `dpB` can be used to keep track of the maximum energy boost we can get from each drink. - Initially `dpA` and `dpB` will be the energy boost from the first hour of each drink. - From the 2nd hour, the maximum boost we can get is - Option 1 - Drink the same drink as the previous hour. - Option 2 - Switch to the other drink. - Now find the maximum of the two options. - This will be new dpA and dpB. - We can update `dpA` and `dpB` with the new values. - Finally, we can return the maximum of `dpA` and `dpB`. 2. Implementation - Intialize two variables `dpA` and `dpB` to store the maximum energy boost we can get from each drink. - Iterate over the arrays `energyDrinkA` and `energyDrinkB` from the second element. - For `i` from `1` to `n-1` do - Calculate the new values of `dpA` and `dpB` using the formula - `newDpA = max(dpA + energyDrinkA[i], dpB)` - `newDpB = max(dpB + energyDrinkB[i], dpA)` - Update `dpA` and `dpB` with the new values. - Finally, return the maximum of `dpA` and `dpB`. This problem is a variation of the house robber problem. We can solve this problem using dynamic programming. We can use memoization, tabulation, or optimized tabulation to solve this problem. The optimized tabulation approach is the most efficient approach to solve this problem\n","date":"August 19, 2024","permalink":"/blog/posts/leetcode-contest/problem-3259-maximum-energy-boost-from-two-drinks/","summary":"Problem Statement Link - Problem 3259 Question You are given two integer arrays energyDrinkA and energyDrinkB of the same length n by a futuristic sports scientist.","title":"Problem 3259 Maximum Energy Boost From Two Drinks","type":"posts"},{"content":" Problem Statement Link - Problem 3258 Question You are given a binary string s and an integer k.\nA binary string satisfies the k-constraint if either of the following conditions holds:\nThe number of 0\u0026rsquo;s in the string is at most k. The number of 1\u0026rsquo;s in the string is at most k. Return an integer denoting the number of substrings of s that satisfy the k-constraint.\nExample 1 Input: s = \u0026#34;10101\u0026#34;, k = 1 Output: 12 Explanation: Every substring of `s` except the substrings `\u0026#34;1010\u0026#34;`, `\u0026#34;10101\u0026#34;` and `\u0026#34;0101\u0026#34;` satisfies the k-constraint. Example 2 Input: s = \u0026#34;1010101\u0026#34;, k = 2 Output: 25 Explanation: Every substring of `s` except the substrings with a length greater than 5 satisfies the k-constraint. Example 3 Input: s = \u0026#34;11111\u0026#34;, k = 1 Output: 15 Explanation: All substrings of `s` satisfy the k-constraint. Constraints - `1 \u0026lt;= s.length \u0026lt;= 50` - `1 \u0026lt;= k \u0026lt;= s.length` - `s[i]` is either `\u0026#39;0\u0026#39;` or `\u0026#39;1\u0026#39;`. Solution class Solution { public: int countKConstraintSubstrings(string s, int k) { int n = s.length(); int count = 0; for (int i = 0; i \u0026lt; n; i++) { int zeros = 0, ones = 0; for (int j = i; j \u0026lt; n; j++) { if (s[j] == \u0026#39;0\u0026#39;) zeros++; else ones++; if (zeros \u0026lt;= k || ones \u0026lt;= k) { count++; } else { break; } } } return count; } }; Complexity Analysis | Algorithm | Time Complexity | Space Complexity | | ----------- | --------------- | ---------------- | | Brute force | O(n^2) | O(1) | Explanation 1. Intuition - Since constraints are small we can check all possible substrings. - For each substring, we can check if it satisfies the k-constraint. - If it satisfies the k-constraint, we increment the count. - At the end of the loop, we return the count. 2. Implementation - Intialize a variable `count` to store the number of substrings that satisfy the k-constraint. - Iterate over the string `s` using two nested loops. - For `i` from `0` to `n-1` do - Intialize two variables `zeros` and `ones` to store the number of `0`\u0026#39;s and `1`\u0026#39;s in the substring. - For `j` from `i` to `n-1` do - If `s[j]` is `0` increment `zeros` by `1`. - Else increment `ones` by `1`. - If `zeros` is less than or equal to `k` or `ones` is less than or equal to `k` increment `count` by `1`. - Else break the loop. - Return the `count`. ","date":"August 18, 2024","permalink":"/blog/posts/leetcode-contest/problem-3258-count-substrings-that-satisfy-k-constraint-i/","summary":"Problem Statement Link - Problem 3258 Question You are given a binary string s and an integer k.","title":"Problem 3258 Count Substrings That Satisfy K Constraint I","type":"posts"},{"content":" Problem Statement Link - Problem 54 Question Given an m x n matrix, return all elements of the matrix in spiral order.\nExample 1 Input: matrix = [[1,2,3],[4,5,6],[7,8,9]] Output: [1,2,3,6,9,8,7,4,5] Example 2 Input: matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]] Output: [1,2,3,4,8,12,11,10,9,5,6,7] Constraints - `m == matrix.length` - `n == matrix[i].length` - `1 \u0026lt;= m, n \u0026lt;= 10` - `-100 \u0026lt;= matrix[i][j] \u0026lt;= 100` Solution class Solution { public: vector\u0026lt;int\u0026gt; spiralOrder(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; matrix) { int rows = matrix.size(); int cols = matrix[0].size(); int row = 0, col = -1; int direc = 1; vector\u0026lt;int\u0026gt;ans; while(rows\u0026gt;0 \u0026amp;\u0026amp; cols\u0026gt;0){ for(int i = 0;i\u0026lt;cols;i++){ col+=direc; ans.push_back(matrix[row][col]); } rows--; for(int i = 0;i\u0026lt;rows;i++){ row+=direc; ans.push_back(matrix[row][col]); } cols--; direc*=-1; } return ans; } }; Complexity Analysis | Algorithm | Time Complexity | Space Complexity | | ---------------- | --------------- | ---------------- | | Matrix Traversal | O(mn) | O(1) | Explanation 1. Intuition - To print in spiral order first we should move right, then down, then left and then up. - We will keep track of the number of rows and columns left to traverse. - We will keep track of the direction we are moving in. - We will keep track of the current row and column. - We will keep adding the elements to the answer vector. - We will keep updating the rows and columns left to traverse. - We will keep updating the direction we are moving in. - The idea is start from the first row and keep moving right till the end of the row. - Then move down till the end of the column. - Then move left till the start of the row. - Then move up till the start of the column. - Keep doing this till we have traversed all the elements. 2. Implementation - Initialize the number of `rows = matrix.size()` and `cols = matrix[0].size()`. - Initialize the current `row = 0` and `col = -1`. They will keep track of the current position. - The `col` is initialized to `-1` because we will increment it first. - Initialize the direction `direc = 1`. It will keep track of the direction we are moving in. - `direc = 1` means we are moving right. `direc = -1` means we are moving left. - Initialize the answer vector `ans`. - While we have rows and columns left to traverse. - Traverse the row from left to right. - Increment the `col` by `direc`. - Add the element at the current position to the answer vector. - Decrement the number of rows left to traverse. - Traverse the column from top to bottom. - Increment the `row` by `direc`. - Add the element at the current position to the answer vector. - Decrement the number of columns left to traverse. - Change the direction by multiplying it by `-1`. - Return the answer vector. The direction is changed by multiplying it by -1 because we need to change the direction from right to left and from left to right. The direction is changed only after traversing the row and the column. This is because we need to traverse the row and the column in the same direction.\n","date":"August 17, 2024","permalink":"/blog/posts/extraques/problem-54-sprial-matrix/","summary":"Problem Statement Link - Problem 54 Question Given an m x n matrix, return all elements of the matrix in spiral order.","title":"Problem 54 Sprial Matrix","type":"posts"},{"content":" Problem Statement Link - Problem 624 Question You are given m arrays, where each array is sorted in ascending order.\nYou can pick up two integers from two different arrays (each array picks one) and calculate the distance. We define the distance between two integers a and b to be their absolute difference |a - b|.\nReturn the maximum distance.\nNote Even though the dont mention in the problem statement, the integers a and b CANT be from the same array. Also the arrays can have different lengths and are not arranged in any particular order. But every array is sorted in ascending order in itself.\nExample 1 Input: arrays = [[1,2,3],[4,5],[1,2,3]] Output: 4 Explanation: One way to reach the maximum distance 4 is to pick 1 in the first or third array and pick 5 in the second array. Example 2 Input: arrays = [[1],[1]] Output: 0 Example 3 Edge case Input: arrays = [[1,4],[0,5]] Output: 4 Constraints - `m == arrays.length` - `2 \u0026lt;= m \u0026lt;= 10^5` - `1 \u0026lt;= arrays[i].length \u0026lt;= 500` - -10^4 \u0026lt;= arrays[i][j] \u0026lt;= 10^4` - `arrays[i]` is sorted in ascending order. - There will be at most `10^5` integers in all the arrays. Solution class Solution { public: int maxDistance(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; arrays) { int small = arrays[0].front(); int big = arrays[0].back(); int maxDist = 0; for (int i = 1; i \u0026lt; arrays.size(); ++i) { maxDist = max(maxDist, abs(arrays[i].back() - small)); maxDist = max(maxDist, abs(big - arrays[i].front())); small = min(small, arrays[i].front()); big = max(big, arrays[i].back()); } return maxDist; } }; Complexity Analysis | Algorithm | Time Complexity | Space Complexity | | ------------------ | --------------- | ---------------- | | Greedy single pass | O(n) | O(1) | Explanation 1. Intuition - Since the arrays are sorted, we need to only check the first and last element of each array. - Since we need to pick elements from different arrays, we need to keep track of the smallest and biggest element we have seen so far. - Always calculate the distance between the current array\u0026#39;s first element and the biggest element we have seen so far and the distance between the current array\u0026#39;s last element and the smallest element we have seen so far. - Store the maximum distance seen so far. - Update the smallest and biggest element we have seen so far. - even though the arrays are not sorted in any particular order, we can still find the maximum distance by keeping track of the smallest and biggest element we have seen so far. 2. Implementation - Initialize integers `small` and `big` to store the smallest and biggest element of the first array. - Initialize an integer `maxDist` to store the maximum distance seen so far. - Iterate over the arrays from 2nd array to the last array. - Calculate the distance between the current array\u0026#39;s last element and `small` and update `maxDist`. - Calculate the distance between the current array\u0026#39;s first element and `big` and update `maxDist`. - Update `small` to store the minimum of `small` and the current array\u0026#39;s first element. - Update `big` to store the maximum of `big` and the current array\u0026#39;s last element. - Return `maxDist`. On simple glance it would look like we are picking the smallest and biggest element from the same array, but we are not. We are picking the smallest and biggest element from different arrays. this is because the smallest and biggest element we have seen so far are updated only when we find a new smallest or biggest element in the next array. The mathematical proof is as follows\nProof of Correctness for Greedy Approach Assumptions Each array is sorted in non-decreasing order. We are given multiple arrays A1, A2, \u0026hellip;, An. We need to find the maximum distance between any two elements such that each element comes from a different array. Proof Base Case: For the first array (A1), S is initialized to its first element, and L to its last element. This ensures that the initial distance calculation considers the full range of possible values within the first array.\nInductive Step: Assume that after processing the first k arrays, S and L hold the smallest and largest elements among those processed, and D_max holds the maximum distance found so far.\nWhen processing the (k+1)-th array (Ak+1):\nCalculate the potential distances:\nD1 = abs(Ak+1[0] - L) D2 = abs(S - Ak+1[n-1]) Immediately update S and L if necessary:\nIf Ak+1[0] \u0026lt; S, then S = Ak+1[0]. If Ak+1[n-1] \u0026gt; L, then L = Ak+1[n-1]. At this point, D1 and D2 are already calculated based on the old values of S and L. We do not recalculate them after updating S and L; instead, we directly compare them against D_max to decide whether to update D_max.\nConclusion: By the end of the iteration, S and L will represent the smallest and largest elements from different arrays. The global maximum distance will be the maximum of all D1 and D2 values calculated during the iteration.\nThus, the greedy approach ensures that we always consider the most extreme values from different arrays, guaranteeing the maximum possible distance.\n","date":"August 16, 2024","permalink":"/blog/leetcode-potd/problem-624-maximum-distance-in-arrays/","summary":"Problem Statement Link - Problem 624 Question You are given m arrays, where each array is sorted in ascending order.","title":"Problem 624 Maximum Distance in Arrays","type":"leetcode-potd"},{"content":" Problem Statement Link - Problem 3216 Question Given a string s containing only digits, return the lexicographically smallest string that can be obtained after swapping adjacent digits in s with the same parity at most once.\nDigits have the same parity if both are odd or both are even. For example, 5 and 9, as well as 2 and 4, have the same parity, while 6 and 9 do not.\nLexicographically Smallest String: A string a is lexicographically smaller than a string b if in the first position where a and b differ, string a has a letter that appears earlier in the alphabet than the corresponding letter in b. If the first min(a.length, b.length) characters do not differ, then the shorter string is the lexicographically smaller one.\nExample 1 Input: s = \u0026#34;45320\u0026#34; Output: \u0026#34;43520\u0026#34; Explanation: s[1] == \u0026#39;5\u0026#39; and s[2] == \u0026#39;3\u0026#39; both have the same parity, and swapping them results in the lexicographically smallest string. Example 2 Input: s = \u0026#34;001\u0026#34; Output: \u0026#34;001\u0026#34; Explanation: There is no need to perform a swap because s is already the lexicographically smallest. Constraints - `2 \u0026lt;= s.length \u0026lt;= 100` - `s consists only of digits.` Solution class Solution { public: string getSmallestString(string s) { int n = s.length(); for (int i = 0; i \u0026lt; n - 1; ++i) { if ((s[i] - \u0026#39;0\u0026#39;) % 2 == (s[i + 1] - \u0026#39;0\u0026#39;) % 2) { if (s[i] \u0026gt; s[i + 1]) { swap(s[i], s[i + 1]); break; } } } return s; } }; Complexity Analysis | Algorithm | Time Complexity | Space Complexity | | --------------------- | --------------- | ---------------- | | Check parity and Swap | O(N) | O(1) | Explanation 1. Intuition - Iterate over the string and check if the current digit and the next digit have the same parity. - If they have the same parity, then check if the current digit is greater than the next digit. - If the current digit is greater than the next digit, then swap the digits and break the loop. 2. Implementation - Initialize a variable `n` to store the length of the string. - Iterate over the string from index 0 to n-1. - Check if the current digit and the next digit have the same parity. - If they have the same parity, then check if the current digit is greater than the next digit. - If the current digit is greater than the next digit, then swap the digits and break the loop. - Return the modified string. ","date":"August 15, 2024","permalink":"/blog/posts/leetcode-contest/problem-3216-lexographically-smallest-string-after-a-swap/","summary":"Problem Statement Link - Problem 3216 Question Given a string s containing only digits, return the lexicographically smallest string that can be obtained after swapping adjacent digits in s with the same parity at most once.","title":"Problem 3216 Lexographically Smallest String After a Swap","type":"posts"},{"content":" Problem Statement Link - Problem 860 Question At a lemonade stand, each lemonade costs $5. Customers are standing in a queue to buy from you and order one at a time (in the order specified by bills). Each customer will only buy one lemonade and pay with either a $5, $10, or $20 bill. You must provide the correct change to each customer so that the net transaction is that the customer pays $5.\nNote that you do not have any change in hand at first.\nGiven an integer array bills where bills[i] is the bill the ith customer pays, return true if you can provide every customer with the correct change, or false otherwise.\nExample 1 Input: bills = [5,5,5,10,20] Output: true Explanation: From the first 3 customers, we collect three $5 bills in order. From the fourth customer, we collect a $10 bill and give back a $5. From the fifth customer, we give a $10 bill and a $5 bill. Since all customers got correct change, we output true. Example 2 Input: bills = [5,5,10,10,20] Output: false Explanation: From the first two customers in order, we collect two $5 bills. For the next two customers in order, we collect a $10 bill and give back a $5 bill. For the last customer, we can not give the change of $15 back because we only have two $10 bills. Since not every customer received the correct change, the answer is false. Constraints - `1 \u0026lt;= bills.length \u0026lt;= 10^5` - `bills[i] is either 5, 10, or 20.` Solution class Solution { public: bool lemonadeChange(vector\u0026lt;int\u0026gt;\u0026amp; bills) { std::ios::sync_with_stdio(false); int five = 0, ten = 0; for(int \u0026amp;it:bills){ if(it == 5){ five++; } else if(it == 10){ if(five\u0026gt;0){ ten++; five--; } else{ return false; } } else{ if(ten\u0026gt;0 \u0026amp;\u0026amp; five\u0026gt;0){ ten--; five--; } else if(five\u0026gt;2){ five-=3; } else{ return false; } } //cout\u0026lt;\u0026lt;five\u0026lt;\u0026lt;\u0026#34; \u0026#34;\u0026lt;\u0026lt;ten\u0026lt;\u0026lt;endl; } return true; } }; Complexity Analysis | Algorithm | Time Complexity | Space Complexity | | --------- | --------------- | ---------------- | | Greedy | O(N) | O(1) | Explanation 1. Intuition - We need to keep track of the way the change is given. - In real life, we always try to give the change by using higher denominations first. - We can use the same approach here. - We can keep track of the number of 5\u0026#39;s and 10\u0026#39;s we have. - If 20 is given, we can give 10+5 or 5+5+5. - If 10 is given, we can give 5. - If 5 is given, we can keep it. - If we can\u0026#39;t give the change, we return false. - If we can give the change to all customers, we return true. 2. Implementation - Initialize `five` and `ten` to 0. - Iterate over the bills. - If the bill is 5, increment `five`. - If the bill is 10, check if we have 5\u0026#39;s. - If we have 5\u0026#39;s, increment `ten` and decrement `five`. - If we don\u0026#39;t have 5\u0026#39;s, return false. - If the bill is 20, check if we have 10\u0026#39;s and 5\u0026#39;s. - If we have 10\u0026#39;s and 5\u0026#39;s, decrement `ten` and `five`. - If we have 5\u0026#39;s, decrement `five` by 3. - If we don\u0026#39;t have 10\u0026#39;s and 5\u0026#39;s, return false. - Return true. ","date":"August 15, 2024","permalink":"/blog/leetcode-potd/problem-860-lemonade-change/","summary":"Problem Statement Link - Problem 860 Question At a lemonade stand, each lemonade costs $5.","title":"Problem 860 Lemonade Change","type":"leetcode-potd"},{"content":" Problem Statement Link - Problem 719 Question The distance of a pair of integers a and b is defined as the absolute difference between a and b.\nGiven an integer array nums and an integer k, return the kth smallest distance among all the pairs nums[i] and nums[j] where 0 \u0026lt;= i \u0026lt; j \u0026lt; nums.length.\nExample 1 Input: nums = [1,3,1], k = 1 Output: 0 Explanation: Here are all the pairs: (1,3) -\u0026gt; 2 (1,1) -\u0026gt; 0 (3,1) -\u0026gt; 2 Then the 1st smallest distance pair is (1,1), and its distance is 0. Example 2 Input: nums = [1,1,1], k = 2 Output: 0 Example 3 Input: nums = [1,6,1], k = 3 Output: 5 Constraints - `n == nums.length` - `2 \u0026lt;= n \u0026lt;= 10^4` - `0 \u0026lt;= nums[i] \u0026lt;= 10^6` - `1 \u0026lt;= k \u0026lt;= n * (n - 1) / 2` Solution // Brute Force class Solution { public: int smallestDistancePair(vector\u0026lt;int\u0026gt;\u0026amp; nums, int k) { std::ios::sync_with_stdio(false); priority_queue\u0026lt;int,vector\u0026lt;int\u0026gt;,greater\u0026lt;int\u0026gt;\u0026gt;pq; for(int i=0;i\u0026lt;nums.size();i++){ for(int j= i+1; j\u0026lt;nums.size();j++){ pq.push(abs(nums[i]-nums[j])); } } for(int i = 1; i\u0026lt;k; i++) pq.pop(); return pq.top(); } }; Complexity Analysis | Algorithm | Time Complexity | Space Complexity | | --------- | --------------- | ---------------- | | Pair | O(N^2) | O(1) | | Priority | O(NlogN) | O(N) | Better Solution // Binary Search class Solution { public: static int cntPairs(int x, vector\u0026lt;int\u0026gt;\u0026amp; nums){ const int n=nums.size(); int cnt=0; for(int l=0, r=1; r\u0026lt;n; r++){ while(r\u0026gt;l \u0026amp;\u0026amp; nums[r]-nums[l]\u0026gt;x) l++; cnt+=r-l; } return cnt; } static int smallestDistancePair(vector\u0026lt;int\u0026gt;\u0026amp; nums, int k) { sort(nums.begin(), nums.end()); int l=0, r=nums.back()-nums.front(), m; while(l\u0026lt;r){ m=(r+l)/2; if (cntPairs(m, nums)\u0026lt;k) l=m+1; else r=m; } return l; } }; auto init = []() { ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); return \u0026#39;c\u0026#39;; }(); Complexity Analysis | Algorithm | Time Complexity | Space Complexity | | --------- | --------------- | ---------------- | | Binary | O(NlogN) | O(1) | | Count | O(N) | O(1) | Explanation 1. Intuition - First approach is quite straight forward - Lets discuss the Binary Search approach - Since we need to find the kth smallest distance between the pairs We need to estimate how many pairs can have the distance less than or equal to `k`. - We know that the maximum distance between the pairs is the difference between the maximum and minimum element in the array. - So the boundaries of the binary search are `0` and the `maximum difference`. - We calculate the mid of the boundaries and check how many pairs have the distance less than or equal to the mid. - If the number of pairs is less than `k`, we move the left boundary to mid+1. - If the number of pairs is greater than or equal to `k`, we move the right boundary to mid. - We return the left boundary as the answer. 2. Implementation - Intialize `countPairs` function to calculate the number of pairs with distance less than or equal to `x`. - Given the sorted array and the distance `x`, initialize the count to `0`. - Iterate over the array with two pointers `l` from 0 and `r` from 1. - If the difference between the elements at `r` and `l` is greater than `x`, increment the left pointer `l`. - Add the difference between `r` and `l` to the count. - Increment the right pointer `r`. - Return the count. - Initialize the `smallestDistancePair` function to find the kth smallest distance. - Sort the array to get the maximum and minimum elements. - Initialize the left boundary `l` to `0` and the right boundary `r` to the difference between the maximum and minimum elements. - Iterate until the left boundary is less than the right boundary. - Calculate the mid of the boundaries. - If the number of pairs with distance less than or equal to the mid is less than `k`, move the left boundary to mid+1. - Otherwise, move the right boundary to mid. - Return the left boundary as the answer. ","date":"August 14, 2024","permalink":"/blog/leetcode-potd/problem-719-find-k-th-smallest-pair-distance/","summary":"Problem Statement Link - Problem 719 Question The distance of a pair of integers a and b is defined as the absolute difference between a and b.","title":"Problem 719 Find K Th Smallest Pair Distance","type":"leetcode-potd"},{"content":" Problem Statement Link - Problem 40 Question Given a collection of candidate numbers (candidates) and a target number (target), find all unique combinations in candidates where the candidate numbers sum to target.\nEach number in candidates may only be used once in the combination.\nNote: The solution set must not contain duplicate combinations.\nExample 1 Input: candidates = [10,1,2,7,6,1,5], target = 8 Output: [ [1,1,6], [1,2,5], [1,7], [2,6] ] Example 2 Input: candidates = [2,5,2,1,2], target = 5 Output: [ [1,2,2], [5] ] Constraints - `1 \u0026lt;= candidates.length \u0026lt;= 100` - `1 \u0026lt;= candidates[i] \u0026lt;= 50` - `1 \u0026lt;= target \u0026lt;= 30` Solution /class Solution { public: vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; combinationSum2(vector\u0026lt;int\u0026gt;\u0026amp; candidates, int target) { sort(candidates.begin(), candidates.end()); vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; result; vector\u0026lt;int\u0026gt; current; backtrack(candidates, target, 0, current, result); return result; } private: void backtrack(vector\u0026lt;int\u0026gt;\u0026amp; candidates, int target, int start, vector\u0026lt;int\u0026gt;\u0026amp; current, vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; result) { if (target == 0) { result.push_back(current); return; } for (int i = start; i \u0026lt; candidates.size(); i++) { if (i \u0026gt; start \u0026amp;\u0026amp; candidates[i] == candidates[i - 1]) continue; if (candidates[i] \u0026gt; target) break; current.push_back(candidates[i]); backtrack(candidates, target - candidates[i], i + 1, current, result); current.pop_back(); } } }; Complexity Analysis | Algorithm | Time Complexity | Space Complexity | | --------- | --------------- | ---------------- | | Backtrack | O(2^N) | O(N) | Explanation 1. Intuition - To generate all combinations, we can use backtracking. - But we need to avoid duplicates. Hence we sort the array and skip the duplicates. - `Backtrack` function is called recursively to generate all possible combinations. - In backtracking, we add the current element to the `current` vector and call the backtrack function recursively. - If it reaches the target, we add the current vector to the result. - If the current element is greater than the target, we break the loop. - If the current element is a duplicate, we skip it. - We pop the last element from the current vector after the recursive call. 2. Implementation - Sort the array to avoid duplicates. - Initialize the `result` vector to store the final result. - Initialize the `current` vector to store the current combination. - Call the `backtrack` function with the `candidates`, `target`, `start`, `current`, and `result`. - In the `backtrack` function, if the target is 0, add the current vector to the result. - Iterate over the candidates array from the `start` index. - If the current element is a duplicate, skip it. - If the current element is greater than the target, break the loop. - Add the current element to the current vector and call the backtrack function recursively. - Pop the last element from the current vector after the recursive call. ","date":"August 13, 2024","permalink":"/blog/leetcode-potd/problem-40-combination-sum-ii/","summary":"Problem Statement Link - Problem 40 Question Given a collection of candidate numbers (candidates) and a target number (target), find all unique combinations in candidates where the candidate numbers sum to target.","title":"Problem 40 Combination Sum II","type":"leetcode-potd"},{"content":" Problem Statement Link - Problem 703 Question Design a class to find the kth largest element in a stream. Note that it is the kth largest element in the sorted order, not the kth distinct element.\nImplement KthLargest class:\nKthLargest(int k, int[] nums) Initializes the object with the integer k and the stream of integers nums. int add(int val) Appends the integer val to the stream and returns the element representing the kth largest element in the stream. Example 1 Input [\u0026#34;KthLargest\u0026#34;, \u0026#34;add\u0026#34;, \u0026#34;add\u0026#34;, \u0026#34;add\u0026#34;, \u0026#34;add\u0026#34;, \u0026#34;add\u0026#34;] [[3, [4, 5, 8, 2]], [3], [5], [10], [9], [4]] Output [null, 4, 5, 5, 8, 8] Explanation KthLargest kthLargest = new KthLargest(3, [4, 5, 8, 2]); kthLargest.add(3); // return 4 kthLargest.add(5); // return 5 kthLargest.add(10); // return 5 kthLargest.add(9); // return 8 kthLargest.add(4); // return 8 Constraints - `1 \u0026lt;= k \u0026lt;= 10^4` - `0 \u0026lt;= nums.length \u0026lt;= 10^4` - `-10^4 \u0026lt;= nums[i] \u0026lt;= 10^4` - `-10^4 \u0026lt;= val \u0026lt;= 10^4` - At most `10^4` calls will be made to `add`. - It is guaranteed that there will be at least `k` elements in the array when you search for the `kth` element. Solution class KthLargest { public: priority_queue\u0026lt;int, vector\u0026lt;int\u0026gt;, greater\u0026lt;int\u0026gt;\u0026gt; pq; int len; KthLargest(int k, vector\u0026lt;int\u0026gt; nums) { len=k; for(auto val:nums) { pq.push(val); if(pq.size()\u0026gt;k) pq.pop(); } } int add(int val) { pq.push(val); if(pq.size()\u0026gt;len) pq.pop(); return pq.top(); } }; /** * Your KthLargest object will be instantiated and called as such: * KthLargest* obj = new KthLargest(k, nums); * int param_1 = obj-\u0026gt;add(val); */ Complexity Analysis | Algorithm | Time Complexity | Space Complexity | | --------- | --------------- | ---------------- | | Heaping | O(nlogk) | O(k) | Explanation 1. Intuition - We need to keep track of first `k` largest elements in the stream. - Hence we can use a min heap to store the `k` largest elements. - Since we are storing only `k` largest elements, when the size of the heap exceeds `k`, we can pop the smallest element. - When the size exceeds `k` we need to pop because they are `k+1th`, `k+2th` elements etc. 2. Implementation - Initialize a priority queue `pq` with a min heap. - Initialize a variable `len` to store the value of `k`. - In the constructor, iterate over the `nums` and push the elements into the heap. - If the size of the heap exceeds `k`, pop the smallest element. - In the `add` function, push the element into the heap. - If the size of the heap exceeds `k`, pop the smallest element. - Return the top element of the heap. ","date":"August 12, 2024","permalink":"/blog/leetcode-potd/problem-703-kth-largest-element-in-a-stream/","summary":"Problem Statement Link - Problem 703 Question Design a class to find the kth largest element in a stream.","title":"Problem 703 Kth Largest Element in a Stream","type":"leetcode-potd"},{"content":" Problem Statement Link - Problem 3016 Question You are given a string word containing lowercase English letters.\nTelephone keypads have keys mapped with distinct collections of lowercase English letters, which can be used to form words by pushing them. For example, the key 2 is mapped with [\u0026quot;a\u0026quot;,\u0026quot;b\u0026quot;,\u0026quot;c\u0026quot;], we need to push the key one time to type \u0026quot;a\u0026quot;, two times to type \u0026quot;b\u0026quot;, and three times to type \u0026quot;c\u0026quot; .\nIt is allowed to remap the keys numbered 2 to 9 to distinct collections of letters. The keys can be remapped to any amount of letters, but each letter must be mapped to exactly one key. You need to find the minimum number of times the keys will be pushed to type the string word.\nReturn the minimum number of pushes needed to type word after remapping the keys.\nAn example mapping of letters to keys on a telephone keypad is given below. Note that 1, *, #, and 0 do not map to any letters.\nExample 1 Input: word = \u0026#34;abcde\u0026#34; Output: 5 Explanation: The remapped keypad given in the image provides the minimum cost. \u0026#34;a\u0026#34; -\u0026gt; one push on key 2 \u0026#34;b\u0026#34; -\u0026gt; one push on key 3 \u0026#34;c\u0026#34; -\u0026gt; one push on key 4 \u0026#34;d\u0026#34; -\u0026gt; one push on key 5 \u0026#34;e\u0026#34; -\u0026gt; one push on key 6 Total cost is 1 + 1 + 1 + 1 + 1 = 5. It can be shown that no other mapping can provide a lower cost. Example 2 Input: word = \u0026#34;xyzxyzxyzxyz\u0026#34; Output: 12 Explanation: The remapped keypad given in the image provides the minimum cost. \u0026#34;x\u0026#34; -\u0026gt; one push on key 2 \u0026#34;y\u0026#34; -\u0026gt; one push on key 3 \u0026#34;z\u0026#34; -\u0026gt; one push on key 4 Total cost is 1 * 4 + 1 * 4 + 1 * 4 = 12 It can be shown that no other mapping can provide a lower cost. Note that the key 9 is not mapped to any letter it is not necessary to map letters to every key, but to map all the letters. Example 3 Input: word = \u0026#34;aabbccddeeffgghhiiiiii\u0026#34; Output: 24 Explanation: The remapped keypad given in the image provides the minimum cost. \u0026#34;a\u0026#34; -\u0026gt; one push on key 2 \u0026#34;b\u0026#34; -\u0026gt; one push on key 3 \u0026#34;c\u0026#34; -\u0026gt; one push on key 4 \u0026#34;d\u0026#34; -\u0026gt; one push on key 5 \u0026#34;e\u0026#34; -\u0026gt; one push on key 6 \u0026#34;f\u0026#34; -\u0026gt; one push on key 7 \u0026#34;g\u0026#34; -\u0026gt; one push on key 8 \u0026#34;h\u0026#34; -\u0026gt; two pushes on key 9 \u0026#34;i\u0026#34; -\u0026gt; one push on key 9 Total cost is 1 * 2 + 1 * 2 + 1 * 2 + 1 * 2 + 1 * 2 + 1 * 2 + 1 * 2 + 2 * 2 + 6 * 1 = 24. It can be shown that no other mapping can provide a lower cost. Constraints - `1 \u0026lt;= word.length \u0026lt;= 10^5` - `word` consists of lowercase English letters. Solution class Solution { public: int minimumPushes(string word) { vector\u0026lt;int\u0026gt; v(26); for (char\u0026amp; c : word) v[c - \u0026#39;a\u0026#39;]++; sort(v.begin(), v.end(), greater\u0026lt;int\u0026gt;()); int a = 0; for (int i = 0; i \u0026lt; 26; ++i) a += v[i] * (i / 8 + 1); return a; } }; Complexity Analysis | Algorithm | Time Complexity | Space Complexity | | --------- | --------------- | ---------------- | | Sorting | O(26log26) | O(26) | | Counting | O(n) | O(26) | Explanation 1. Intuition - The minimum number of pushes to type a word will occur when the most frequent letter is mapped to the key with the least number of pushes. - Hence we need to keep track of the frequency of each letter and sort them in descending order. - Then we can iterate over the sorted array and calculate the minimum number of pushes required to type the word. 2. Implementation - Initialize a vector `v` of size `26` to keep track of the frequency of each letter. - Iterate over the word and increment the frequency of each letter. - Sort the vector in descending order. - Initialize a variable `a` to keep track of the minimum number of pushes required. - Iterate over the sorted vector and calculate the minimum number of pushes required to type the word - `a += v[i] * (i / 8 + 1)` - here `i / 8 + 1` calculates the number of pushes required to type the letter. - Return the minimum number of pushes required. ","date":"August 6, 2024","permalink":"/blog/leetcode-potd/problem-3016-minimum-number-of-pushes-to-type-word-ii/","summary":"Problem Statement Link - Problem 3016 Question You are given a string word containing lowercase English letters.","title":"Problem 3016 Minimum Number of Pushes to Type Word II","type":"leetcode-potd"},{"content":" Problem Statement Link - Problem 2053 Question A distinct string is a string that is present only once in an array.\nGiven an array of strings arr, and an integer k, return the kth distinct string present in arr. If there are fewer than k distinct strings, return an empty string \u0026quot;\u0026quot;.\nNote that the strings are considered in the order in which they appear in the array.\nExample 1 Input: arr = [\u0026#34;d\u0026#34;,\u0026#34;b\u0026#34;,\u0026#34;c\u0026#34;,\u0026#34;b\u0026#34;,\u0026#34;c\u0026#34;,\u0026#34;a\u0026#34;], k = 2 Output: \u0026#34;a\u0026#34; Explanation: The only distinct strings in arr are \u0026#34;d\u0026#34; and \u0026#34;a\u0026#34;. \u0026#34;d\u0026#34; appears 1st, so it is the 1st distinct string. \u0026#34;a\u0026#34; appears 2nd, so it is the 2nd distinct string. Since k == 2, \u0026#34;a\u0026#34; is returned. Example 2 Input: arr = [\u0026#34;aaa\u0026#34;,\u0026#34;aa\u0026#34;,\u0026#34;a\u0026#34;], k = 1 Output: \u0026#34;aaa\u0026#34; Explanation: All strings in arr are distinct, so the 1st string \u0026#34;aaa\u0026#34; is returned. Example 3 Input: arr = [\u0026#34;a\u0026#34;,\u0026#34;b\u0026#34;,\u0026#34;a\u0026#34;], k = 3 Output: \u0026#34;\u0026#34; Explanation: The only distinct string is \u0026#34;b\u0026#34;. Since there are fewer than 3 distinct strings, we return an empty string \u0026#34;\u0026#34;. Constraints - `1 \u0026lt;= k \u0026lt;= arr.length \u0026lt;= 1000` - `1 \u0026lt;= arr[i].length \u0026lt;= 5` - `arr[i]` consists of lowercase English letters. Solution class Solution { public: string kthDistinct(vector\u0026lt;string\u0026gt;\u0026amp; arr, int k) { std::ios::sync_with_stdio(false); unordered_map\u0026lt;string,int\u0026gt;freq; for(auto\u0026amp; it:arr){ freq[it]++; } for(auto\u0026amp; s : arr) { if(freq[s] == 1 \u0026amp;\u0026amp; --k == 0) return s; } return \u0026#34;\u0026#34;; } }; Complexity Analysis | Algorithm | Time Complexity | Space Complexity | | --------- | --------------- | ---------------- | | Hashmap | O(N) | O(N) | Explanation 1. Intuition - this problem requires us to keep track of the frequency of each string in the array. - Frequency of distinct string is `1`. - Then we can iterate over the array and check if the frequency of the string is `1` and value of `k` is `0` then return the string. - If we reach the end of the array and still not found the `kth` distinct string then return an empty string. 2. Implementation - Create a hashmap to store the frequency of each string. - Iterate over the array and store the frequency of each string. - Iterate over the array and check if the frequency of the string is `1` and value of `k` is `0` then return the string. - Has to decrement the value of k when we find the distinct string. - If we reach the end of the array and still not found the `kth` distinct string then return an empty string. ","date":"August 5, 2024","permalink":"/blog/leetcode-potd/problem-2053-kth-distinct-string-in-an-array/","summary":"Problem Statement Link - Problem 2053 Question A distinct string is a string that is present only once in an array.","title":"Problem 2053 Kth Distinct String in an Array","type":"leetcode-potd"},{"content":" Problem Statement Link - Problem 1508 Question You are given the array nums consisting of n positive integers. You computed the sum of all non-empty continuous subarrays from the array and then sorted them in non-decreasing order, creating a new array of n * (n + 1) / 2 numbers.\nReturn the sum of the numbers from index left to index right (indexed from 1), inclusive, in the new array. Since the answer can be a huge number return it modulo 10^9 + 7.\nExample 1 Input: nums = [1,2,3,4], n = 4, left = 1, right = 5 Output: 13 Explanation: All subarray sums are 1, 3, 6, 10, 2, 5, 9, 3, 7, 4. After sorting them in non-decreasing order we have the new array [1, 2, 3, 3, 4, 5, 6, 7, 9, 10]. The sum of the numbers from index le = 1 to ri = 5 is 1 + 2 + 3 + 3 + 4 = 13. Example 2 Input: nums = [1,2,3,4], n = 4, left = 3, right = 4 Output: 6 Explanation: The given array is the same as example 1. We have the new array [1, 2, 3, 3, 4, 5, 6, 7, 9, 10]. The sum of the numbers from index le = 3 to ri = 4 is 3 + 3 = 6. Example 3 Input: nums = [1,2,3,4], n = 4, left = 1, right = 10 Output: 50 Constraints - `n == nums.length` - `1 \u0026lt;= nums.length \u0026lt;= 1000` - `1 \u0026lt;= nums[i] \u0026lt;= 100` - `1 \u0026lt;= left \u0026lt;= right \u0026lt;= n * (n + 1) / 2` Solution class Solution { public: int rangeSum(vector\u0026lt;int\u0026gt;\u0026amp; nums, int n, int left, int right) { vector\u0026lt;int\u0026gt;prefixSum(n); prefixSum[0]=nums[0]; int mod = 1e9+7; for(int i = 1; i\u0026lt;n;i++){ prefixSum[i] = prefixSum[i-1]+nums[i]; } //for (auto it : prefixSum) // cout\u0026lt;\u0026lt;it\u0026lt;\u0026lt;\u0026#34; \u0026#34;; //cout\u0026lt;\u0026lt;endl; vector\u0026lt;int\u0026gt;subSum; for(int i=0;i\u0026lt;n;i++){ subSum.push_back(prefixSum[i]); for(int j =i+1;j\u0026lt;n;j++){ subSum.push_back(prefixSum[j]-prefixSum[i]); } } sort(subSum.begin(),subSum.end()); //for (auto it : subSum) //cout\u0026lt;\u0026lt;it\u0026lt;\u0026lt;\u0026#34; \u0026#34;; int sum = 0; for(int i = left-1;i\u0026lt;right;i++){ sum = (sum+subSum[i])%mod; } return sum; } }; Complexity Analysis | Algorithm | Time Complexity | Space Complexity | | ------------------------- | --------------- | ---------------- | | Subarray sum with sorting | O(n^2logn) | O(n^2) | Explanation 1. Intuition - We can generate the subarray sum using the prefix sum technique. - Then sort the subarray sum and return the sum of the subarray sum from left to right. - To generate subarray sum from index i to index j, we can use `prefixSum[j]-prefixSum[i]`. 2. Implementation - Initialize a vector `prefixSum` to store the prefix sum of the given array. - Iterate over the array and store the prefix sum in the `prefixSum` array. - Initialize a vector `subSum` to store the subarray sum. - For each element in `prefixSum`, iterate over the array and calculate the subarray sum from index i to index j. - Subarray sum from i to j = `prefixSum[j]-prefixSum[i]`. - Sort the `subSum` array. - Initialize a variable `sum` to store the sum of the subarray sum from left to right. - Iterate over the `subSum` array from left to right and calculate the sum. - Each addition should be modulo `1e9+7`. - This is to handle the overflow. - return the sum. ","date":"August 4, 2024","permalink":"/blog/leetcode-potd/problem-1508-range-sum-of-sorted-subarray-sums/","summary":"Problem Statement Link - Problem 1508 Question You are given the array nums consisting of n positive integers.","title":"Problem 1508 Range Sum of Sorted Subarray Sums","type":"leetcode-potd"},{"content":" Ringcentral Interview Experience for SDE-1 (Oncampus) Eligibility Criteria 8.5+ CGPA Ciruit Branches No backlogs Batch of 2025 Qualification Round This was an online test conducted on HackerRank. The test was of 90 minutes and had 2 sections:\nSection 1: MCQs This section had 5 MCQs. Got questions from Huffman encoding, Hamming code, Time complexity analysis. There was a positive score for correct answers and no negative marking for wrong answers. Section 2: Coding This section had 2 coding questions: It was Leetcode hard-medium level questions. The set which I got had one graph based question and one Tree based question. My Friends got questions from DP and graphs.\nI was able to solve one question completely and the other question partially.\nYou can find link to similar questions here . This was very similar to the leetcode question 1334. I have a detailed solution for the given question here - Problem 1334 .\nShortlisting A total of 28 students were selected from online test into the inperson interviews.\nInterviews The interviews were scheduled the very next day. There were 2 rounds of interviews. We were asked to attend in formals along with hardcopy of resume.\n1st round was purely technical while 2nd round was techno-managerial.\nRound 1 Here the interviewer was kind and asked me to introduce myself.\nHe then asked me to write code on paper for interface for a stack in any language of my choice.\nHe then asked me to write code for push, pop, peek and isEmpty functions.\nI was able to write code for that. He then asked me to implement a getMin function which returns the minimum element in the stack in O(1) time.\nThis was a question present in Striver SDE Sheet. I had done this question before so I was able to solve it.\nWhile doing this he asked me to explain the time complexity of the functions I wrote, how polymorphism works in the present code.\nYou can find solution to that question over here - Link He then asked me about cacheing and different algorithms used there. As I answered them, he asked me to implement LFU Cache.\nHe gave me some hints and I was able to write the code for that.\nThe next set of questions were from Operating Systems and Computernetworks. He asked me how Interprocess Communication works in OS and how routing and subnetting works in Computer Networks.\nThere were also questions about deadlocks and reader-writer problems.\nI answered them and illustrated the usage of semaphores and mutex in solving them.\nI got shortlisted for the next round.\nNumber of students shortlisted for the next round - 13\nRound 2 This round was more of resume based round. Interviewer asked me to introduce myself. Then asked me about my projects and internships. I explained thoroughly about the projects. He then asked me questions on various error codes in HTTP and asked me to explain how SSL and TLS works. I was able to explain both of them to a good level. He then asked two puzzles. The first puzzle is about optimization of number races to find winning horses among 25 horses. The problem link is here - Link The second puzzle was to find the number of fishes to remove to change the percentage of fishes in a tank. This was a fairly easy ratio puzzle. I was able to solve both. Then I asked him about the company culture and the work environment. He explained it to me. I also asked about what are the learning opportunities in the company. He was excited to answer that. I cleared this round.\nVerdict 5 students were selected for the SDE-1 role. I was one of them. ( Yay :) )\nTips Be prepared in fundamentals of Computer Science\nOperating systems, Computer Networks, DBMS Do good number of DSA problems Be very confident. I was able to clear both rounds because I was very comfortable to speak with them.\nYou will think you aren’t prepared, but you already are! Just gain some confidence, it is very vital.\nDon’t hesitate to ask doubts to the interviewer, the more you interect, the more your chances are to get selected.\nKeep speaking out your thought process, the interviewer will provide you hints and encourage you to get to the answer.\nBe strng with your resume, stick to the every single ord mentioned in it.\nAlways say YES if the interviewer asked you if you had any questions for him. (Do company research beforehand for this. Atleast read the JD.)\n","date":"August 4, 2024","permalink":"/blog/posts/interviews/ringcentral-campus-recruitment-2024/","summary":"Ringcentral Interview Experience for SDE-1 (Oncampus) Eligibility Criteria 8.","title":"Ringcentral Campus Recruitment 2024","type":"posts"},{"content":" Problem Statement Link - Problem 787 Question There are n cities connected by some number of flights. You are given an array flights where flights[i] = [fromi, toi, pricei] indicates that there is a flight from city fromi to city toi with cost pricei.\nYou are also given three integers src, dst, and k, return the cheapest price from src to dst with at most k stops. If there is no such route, return -1.\nExample 1 Input: n = 4, flights = [[0,1,100],[1,2,100],[2,0,100],[1,3,600],[2,3,200]], src = 0, dst = 3, k = 1 Output: 700 Explanation: The graph is shown above. The optimal path with at most 1 stop from city 0 to 3 is marked in red and has cost 100 + 600 = 700. Note that the path through cities [0,1,2,3] is cheaper but is invalid because it uses 2 stops. Example 2 Input: n = 3, flights = [[0,1,100],[1,2,100],[0,2,500]], src = 0, dst = 2, k = 1 Output: 200 Explanation: The graph is shown above. The optimal path with at most 1 stop from city 0 to 2 is marked in red and has cost 100 + 100 = 200. Example 3 Input: n = 3, flights = [[0,1,100],[1,2,100],[0,2,500]], src = 0, dst = 2, k = 0 Output: 500 Explanation: The graph is shown above. The optimal path with no stops from city 0 to 2 is marked in red and has cost 500. Constraints - `1 \u0026lt;= n \u0026lt;= 100` - `0 \u0026lt;= flights.length \u0026lt;= (n * (n - 1) / 2)` - `flights[i].length == 3` - `0 \u0026lt;= fromi, toi \u0026lt; n` - `fromi != toi` - `1 \u0026lt;= pricei \u0026lt;= 10^4` - There will not be any multiple flights between two cities. - `0 \u0026lt;= src, dst, k \u0026lt; n` - `src != dst` Solution class Solution { public: int dijkstras(int src, vector\u0026lt;vector\u0026lt;pair\u0026lt;int,int\u0026gt;\u0026gt;\u0026gt;\u0026amp;adj, int target, int k,int n){ vector\u0026lt;int\u0026gt;dist(n+1,INT_MAX); vector\u0026lt;int\u0026gt;stops(n+1,INT_MAX); dist[src]=0; stops[src]=0; priority_queue\u0026lt;vector\u0026lt;int\u0026gt;,vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;,greater\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026gt;pq; pq.push({0,src,0}); while(!pq.empty()){ auto vec = pq.top(); pq.pop(); if(target == vec[1]) return vec[0]; if(vec[2]==k+1) continue; for(auto it:adj[vec[1]]){ if(vec[0]+it.second\u0026lt;dist[it.first] || vec[2]+1\u0026lt;stops[it.first]){ dist[it.first] = it.second + vec[0]; stops[it.first] = vec[2]+1; pq.push({dist[it.first],it.first,stops[it.first]}); } } } return -1; } int findCheapestPrice(int n, vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; flights, int src, int dst, int k) { vector\u0026lt;vector\u0026lt;pair\u0026lt;int,int\u0026gt;\u0026gt;\u0026gt;adj(n+1); for(auto it: flights){ adj[it[0]].push_back({it[1],it[2]}); } return dijkstras(src,adj,dst,k,n); } }; Complexity Analysis | Algorithm | Time Complexity | Space Complexity | | --------- | --------------- | ---------------- | | Dijsktras | O(nlogn) | O(n) | Explanation 1. Intuition - We can use the Dijkstra algorithm to solve this problem with a slight modification. - The modification needs to handle the number of stops. - We can keep track of the number of stops we have made so far. - If the number of stops exceeds the given number of stops, we can skip that path. - We can use a priority queue to store the distance, node, and the number of stops. - If the target node is reached, we can return the distance. - If the number of stops exceeds the given number of stops, we can skip that path. - Then for each node adjacent to the current node, we can update the distance and the number of stops. - Finally, we can return -1 if the target node is not reached. 2. Implementation - Initialize a function `dijkstras` that takes the source node, adjacency list, target node, number of stops, and the total number of nodes. - Initialize a vector `dist` to store the distance of each node from the source node. - Let all the distances be INT_MAX. - Initialize a vector `stops` to store the number of stops made so far. - Let all the stops be INT_MAX. - Set `dist[src]` to 0 and `stops[src]` to 0. - Initialize a priority queue `pq` to store the `{distance, node, stops}`. - Push the source node into the priority queue. - While the priority queue is not empty, pop the top element. - If the target node is reached, return the distance. - If the number of stops exceeds the given number of stops, skip that path. - For each adjacent node of the current node, update the distance and the number of stops. - Finally, return -1 if the target node is not reached. ","date":"August 1, 2024","permalink":"/blog/posts/extraques/problem-787-cheapest-flights-within-k-stops/","summary":"Problem Statement Link - Problem 787 Question There are n cities connected by some number of flights.","title":"Problem 787 Cheapest Flights Within K Stops","type":"posts"},{"content":" Problem Statement Link - Problem 743 Question You are given a network of n nodes, labeled from 1 to n. You are also given times, a list of travel times as directed edges times[i] = (ui, vi, wi), where ui is the source node, vi is the target node, and wi is the time it takes for a signal to travel from source to target.\nWe will send a signal from a given node k. Return the minimum time it takes for all the n nodes to receive the signal. If it is impossible for all the n nodes to receive the signal, return -1.\nExample 1 Input: times = [[2,1,1],[2,3,1],[3,4,1]], n = 4, k = 2 Output: 2 Example 2 Input: times = [[1,2,1]], n = 2, k = 1 Output: 1 Example 3 Input: times = [[1,2,1]], n = 2, k = 2 Output: -1 Constraints - `1 \u0026lt;= k \u0026lt;= n \u0026lt;= 100` - `1 \u0026lt;= times.length \u0026lt;= 6000` - `times[i].length == 3` - `1 \u0026lt;= ui, vi \u0026lt;= n` - `ui != vi` - `0 \u0026lt;= wi \u0026lt;= 100` - All the pairs `(ui, vi)` are unique. (i.e., no multiple edges.) Solution class Solution { public: vector\u0026lt;int\u0026gt; dijkstras(int src,vector\u0026lt;vector\u0026lt;pair\u0026lt;int,int\u0026gt;\u0026gt;\u0026gt;\u0026amp;adj,int V){ vector\u0026lt;int\u0026gt;dist(V+1,INT_MAX); dist[src] = 0; priority_queue\u0026lt;pair\u0026lt;int,int\u0026gt;,vector\u0026lt;pair\u0026lt;int,int\u0026gt;\u0026gt;, greater\u0026lt;pair\u0026lt;int,int\u0026gt;\u0026gt;\u0026gt;pq; pq.push({0,src}); while(!pq.empty()){ int node = pq.top().second; int wt = pq.top().first; pq.pop(); for(auto it:adj[node]){ if(wt + it.second \u0026lt; dist[it.first]){ dist[it.first] = wt + it.second; pq.push({dist[it.first], it.first}); } } } return dist; } int networkDelayTime(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; times, int n, int k) { vector\u0026lt;vector\u0026lt;pair\u0026lt;int,int\u0026gt;\u0026gt;\u0026gt;adj(n+1); for(int i = 0; i\u0026lt;times.size();i++){ auto u = times[i]; adj[u[0]].push_back({u[1],u[2]}); } vector\u0026lt;int\u0026gt;dist = dijkstras(k,adj,n); dist[0] = INT_MIN; // becuz numbered from 1 to n int maxi = INT_MIN; for(auto it:dist){ maxi = max(maxi,it); } if(maxi==INT_MAX) return -1; else return maxi; } }; Complexity Analysis | Algorithm | Time Complexity | Space Complexity | | --------- | --------------- | ---------------- | | Dijsktra | O(ElogV) | O(V+E) | Explanation 1. Intuition - Here we are given a graph with n nodes and times as directed edges. - We need to find the minimum time it takes for all the n nodes to receive the signal. - We can solve this problem using Dijkstra\u0026#39;s algorithm. - We can create an adjacency list to store the graph. - We can create a vector to store the distance of each node from the source node. - We can use a priority queue to store the nodes in increasing order of distance. - We can start from the source node and update the distance of each node from the source node. - Finally, we can return the maximum distance of any node from the source node. - If the maximum distance is INT_MAX, then we can return -1. - Otherwise, we can return the maximum distance. 2. Implementation - We can create a function `dijkstras` to implement Dijkstra\u0026#39;s algorithm. - We can initialize a vector `dist` to store the distance of each node from the source node. - initialize `dist` with INT_MAX. - Initialize `dist[src]` with 0. - Create a priority queue `pq` to store the nodes in increasing order of distance. - Push the source node into the priority queue. - While the priority queue is not empty, we can pop the top node from the priority queue. - For each adjacent node of the top node, we can update the distance of the adjacent node from the source node. - If the updated distance is less than the current distance, we can update the distance and push the adjacent node into the priority queue. - Finally, we can return the distance vector. - In the main function, we can create an adjacency list to store the graph. - We can iterate over the times array and add the edges to the adjacency list. - We can call the `dijkstras` function with the source node and the adjacency list. - We can find the maximum distance of any node from the source node. - If the maximum distance is INT_MAX, then we can return -1. - Otherwise, we can return the maximum distance. ","date":"August 1, 2024","permalink":"/blog/posts/extraques/problem-743-network-delay-time/","summary":"Problem Statement Link - Problem 743 Question You are given a network of n nodes, labeled from 1 to n.","title":"Problem 743 Network Delay Time","type":"posts"},{"content":" Problem Statement Link - Problem 2678 Question You are given a 0-indexed array of strings details. Each element of details provides information about a given passenger compressed into a string of length 15. The system is such that:\nThe first ten characters consist of the phone number of passengers. The next character denotes the gender of the person. The following two characters are used to indicate the age of the person. The last two characters determine the seat allotted to that person. Return the number of passengers who are strictly more than 60 years old.\nExample 1 Input: details = [\u0026#34;7868190130M7522\u0026#34;,\u0026#34;5303914400F9211\u0026#34;,\u0026#34;9273338290F4010\u0026#34;] Output: 2 Explanation: The passengers at indices 0, 1, and 2 have ages 75, 92, and 40. Thus, there are 2 people who are over 60 years old. Example 2 Input: details = [\u0026#34;1313579440F2036\u0026#34;,\u0026#34;2921522980M5644\u0026#34;] Output: 0 Explanation: None of the passengers are older than 60. Constraints - `1 \u0026lt;= details.length \u0026lt;= 100` - `details[i].length == 15` - `details[i] consists of digits from \u0026#39;0\u0026#39; to \u0026#39;9\u0026#39;.` - `details[i][10] is either \u0026#39;M\u0026#39; or \u0026#39;F\u0026#39; or \u0026#39;O\u0026#39;.` - The phone numbers and seat numbers of the passengers are distinct. Solution class Solution { public: int countSeniors(vector\u0026lt;string\u0026gt;\u0026amp; details) { int count=0; int age; for(string \u0026amp;it:details){ age = (it[11]-\u0026#39;0\u0026#39;)*10+(it[12]-\u0026#39;0\u0026#39;); if(age\u0026gt;60) count++; } return count; } }; Complexity Analysis | Algorithm | Time Complexity | Space Complexity | | --------- | --------------- | ---------------- | | Traversal | O(n) | O(1) | Explanation 1. Intuition - We just need to iterate over the array and for each string check if the age is greater than 60. - If it is, we increment the count. - Finally, we return the count. 2. Implementation - We initialize a variable `count` to store the number of senior citizens. - We iterate over the array. - For each string, we extract the age from the string. - We check if the age is greater than 60. - If it is, we increment the count. - Finally, we return the count. ","date":"August 1, 2024","permalink":"/blog/leetcode-potd/problem-2678-number-of-senior-citizens/","summary":"Problem Statement Link - Problem 2678 Question You are given a 0-indexed array of strings details.","title":"Problem 2678 Number of Senior Citizens","type":"leetcode-potd"},{"content":" Problem Statement Link - Problem 55 Question You are given an integer array nums. You are initially positioned at the array\u0026rsquo;s first index, and each element in the array represents your maximum jump length at that position.\nReturn true if you can reach the last index, or false otherwise.\nExample 1 Input: nums = [2,3,1,1,4] Output: true Explanation: Jump 1 step from index 0 to 1, then 3 steps to the last index. Example 2 Input: nums = [3,2,1,0,4] Output: false Explanation: You will always arrive at index 3 no matter what. Its maximum jump length is 0, which makes it impossible to reach the last index. Constraints - `1 \u0026lt;= nums.length \u0026lt;= 10^4` - `0 \u0026lt;= nums[i] \u0026lt;= 10^5` Solution class Solution { public: bool canJump(vector\u0026lt;int\u0026gt;\u0026amp; nums) { std::ios::sync_with_stdio(false); int numsSize = nums.size(); if (numsSize ==1) return true; int i,jump,flag=0; for(i=0;i\u0026lt;numsSize;i++) { flag = max(nums[i] + i ,flag ); if(flag \u0026lt;i+1) break; } return flag \u0026gt;= numsSize-1; } }; Complexity Analysis | Algorithm | Time Complexity | Space Complexity | | --------- | --------------- | ---------------- | | Greedy | O(n) | O(1) | Explanation 1. Intuition - Seeing the constraints, we can solve this problem using a greedy approach. - What we can do is, we can keep track of the maximum index we can reach from the current index. - Starting from the 0th index, we can update the maximum index we can reach from the current index. - If the maximum index we can reach from the current index is less than the next index to the current index, then we can break the loop. - If the maximum index we can reach from the current index is greater than or equal to the last index, then we can return true. - Otherwise, we can return false. 2. Implementation - We can initialize the variable `flag` to 0. - `flag` will store the maximum index we can reach from the current index. - We can iterate over the array. - For every index, calculate `flag = max(nums[i] + i, flag)`. - If `flag` is less than `i+1`, then we can break the loop. - If `flag` is greater than or equal to the last index, then we can return true. - Otherwise, we can return false. ","date":"July 30, 2024","permalink":"/blog/posts/extraques/problem-55-jump-game/","summary":"Problem Statement Link - Problem 55 Question You are given an integer array nums.","title":"Problem 55 Jump Game","type":"posts"},{"content":" Problem Statement Link - Problem 62 Question There is a robot on an m x n grid. The robot is initially located at the top-left corner (i.e., grid[0][0]). The robot tries to move to the bottom-right corner (i.e., grid[m - 1][n - 1]). The robot can only move either down or right at any point in time.\nGiven the two integers m and n, return the number of possible unique paths that the robot can take to reach the bottom-right corner.\nThe test cases are generated so that the answer will be less than or equal to 2 * 10^9.\nExample 1 Input: m = 3, n = 7 Output: 28 Example 2 Input: m = 3, n = 2 Output: 3 Explanation: From the top-left corner, there are a total of 3 ways to reach the bottom-right corner: 1. Right -\u0026gt; Down -\u0026gt; Down 2. Down -\u0026gt; Down -\u0026gt; Right 3. Down -\u0026gt; Right -\u0026gt; Down Constraints - `1 \u0026lt;= m, n \u0026lt;= 100` Solution class Solution { public: int uniquePaths(int m, int n) { vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; dp(m, vector\u0026lt;int\u0026gt;(n, 0)); for (int i = 0; i \u0026lt; m; i++) { for (int j = 0; j \u0026lt; n; j++) { if (i == 0 || j == 0) { dp[i][j] = 1; } else { dp[i][j] = dp[i - 1][j] + dp[i][j - 1]; } } } return dp[m - 1][n - 1]; } }; Complexity Analysis | Algorithm | Time Complexity | Space Complexity | | --------- | --------------- | ---------------- | | DP | O(mn) | O(mn) | Explanation 1. Intuition - We can reach every box in the top row in only one way i.e only from left side. - Similarly, we can reach every box in the leftmost column in only one way i.e only from the top side. - For every other box, we can reach it from the top or left side. - So, the number of ways to reach a box is the sum of the number of ways to reach the box above it and the number of ways to reach the box to the left of it. - this is a classic DP problem. - We can create a 2D array to store the number of ways to reach every box. - We can fill the top row and leftmost column with 1. - For every other box, we can fill it with the sum of the number of ways to reach the box above it and the number of ways to reach the box to the left of it. - The number of ways to reach the bottom-right corner will be stored in the last box of the 2D array. 2. Implementation - Initialize a 2D array `dp` of size `m` x `n` with all elements as 0. - Fill the top row and leftmost column with 1. - For every pair `(i,j)` where `i` is not 0 and `j` is not 0, `dp[i][j] = dp[i-1][j] + dp[i][j-1]` - Return `dp[m-1][n-1]`. ","date":"July 29, 2024","permalink":"/blog/posts/extraques/problem-62-unique-paths/","summary":"Problem Statement Link - Problem 62 Question There is a robot on an m x n grid.","title":"Problem 62 Unique Paths","type":"posts"},{"content":" Problem Statement Link - Problem 230 Question Given the root of a binary search tree, and an integer k, return the kth smallest value (1-indexed) of all the values of the nodes in the tree.\nExample 1 Input: root = [3,1,4,null,2], k = 1 Output: 1 Example 2 Input: root = [5,3,6,2,4,null,null,1], k = 3 Output: 3 Constraints - The number of nodes in the tree is `n`. - `1 \u0026lt;= k \u0026lt;= n \u0026lt;= 10^4` - `0 \u0026lt;= Node.val \u0026lt;= 10^4` Solution /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: void solve(TreeNode* root, int \u0026amp;cnt, int \u0026amp;ans, int k){ if(root == nullptr) return; //left, root, right solve(root-\u0026gt;left, cnt, ans, k); cnt++; if(cnt == k){ ans = root-\u0026gt;val; return; } solve(root-\u0026gt;right, cnt, ans, k); } int kthSmallest(TreeNode* root, int k) { std::ios::sync_with_stdio(false); int cnt = 0; int ans; solve(root, cnt, ans, k); return ans; } }; Complexity Analysis | Algorithm | Time Complexity | Space Complexity | | ----------------- | --------------- | ---------------- | | Inorder Traversal | O(n) | O(1) | Explanation 1. Intuition - Inorder traversal of a BST gives the elements in sorted order. - We can use this property to find the kth smallest element. - We can do an inorder traversal and keep track of the count of elements visited. - When the count becomes equal to k, we can return the element. - We can use a recursive function to do this. - We can do a left, root, right traversal. 2. Implementation - Define a recursive function `solve` which takes the root, count, answer, and k as arguments. - if the `root` is `nullptr` then return. - Call `solve` recursively for the left subtree. - Increment the `count` by 1. - If the `count` becomes equal to `k` then set the `answer` to the `root-\u0026gt;val` and return. - Call `solve` recursively for the right subtree. ","date":"July 29, 2024","permalink":"/blog/posts/extraques/problem-230-kth-smallest-element-in-a-bst/","summary":"Problem Statement Link - Problem 230 Question Given the root of a binary search tree, and an integer k, return the kth smallest value (1-indexed) of all the values of the nodes in the tree.","title":"Problem 230 Kth Smallest Element in a BST","type":"posts"},{"content":" Problem Statement Link - Problem 153 Question Suppose an array of length n sorted in ascending order is rotated between 1 and n times. For example, the array nums = [0,1,2,4,5,6,7] might become:\n[4,5,6,7,0,1,2] if it was rotated 4 times. [0,1,2,4,5,6,7] if it was rotated 7 times. Notice that rotating an array [a[0], a[1], a[2], ..., a[n-1]] 1 time results in the array [a[n-1], a[0], a[1], a[2], ..., a[n-2]].\nGiven the sorted rotated array nums of unique elements, return the minimum element of this array.\nYou must write an algorithm that runs in O(log n) time.\nExample 1 Input: nums = [3,4,5,1,2] Output: 1 Explanation: The original array was [1,2,3,4,5] rotated 3 times. Example 2 Input: nums = [4,5,6,7,0,1,2] Output: 0 Explanation: The original array was [0,1,2,4,5,6,7] and it was rotated 4 times. Example 3 Input: nums = [11,13,15,17] Output: 11 Explanation: The original array was [11,13,15,17] and it was rotated 4 times. Constraints - `n == nums.length` - `1 \u0026lt;= n \u0026lt;= 5000` - `-5000 \u0026lt;= nums[i] \u0026lt;= 5000` - All the integers of `nums` are unique. - `nums` is sorted and rotated between `1` and `n` times. Solution class Solution { public: int findMin(vector\u0026lt;int\u0026gt;\u0026amp; nums) { int l = 0, r = nums.size()-1; int mid; while(l\u0026lt;r){ mid = l+(r-l)/2; if(nums[mid]\u0026lt;nums[r]) r=mid; else l =mid+1; } return nums[l]; } }; Complexity Analysis | Algorithm | Time Complexity | Space Complexity | | ------------- | --------------- | ---------------- | | Binary Search | O(log n) | O(1) | Explanation 1. Intuition - Since the question wants a solution in O(log n) time, we can use binary search. - how can we use binary search in a rotated sorted array? - We can use the property of the rotated sorted array. - If we divide the array into two parts, one part will always be sorted. - We can use this property to find the minimum element. - If the mid element is less than the right element, then the right part is sorted. - If the mid element is greater than the right element, then the left part is sorted. - We should always move towards the unsorted part. - Because minimum will be always next to the maximum element. - We can use this property to find the minimum element. 2. Implementation - Initialize `l` to 0 and `r` to `nums.size()-1`. - Initialize `mid` to 0. - Run a while loop until `l` is less than `r`. - Calculate `mid` as `l+(r-l)/2`. - If `nums[mid]\u0026lt;nums[r]` then move `r` to `mid`. - Else move `l` to `mid+1`. - Return `nums[l]`. This is a variation of binary search. We are using the property of the rotated sorted array to find the minimum element. We are moving towards the unsorted part of the array to find the minimum element. This will give us the minimum element in O(log n) time.\n","date":"July 29, 2024","permalink":"/blog/posts/extraques/problem-153-find-minimum-in-rotated-sorted-arrat/","summary":"Problem Statement Link - Problem 153 Question Suppose an array of length n sorted in ascending order is rotated between 1 and n times.","title":"Problem 153 Find Minimum in Rotated Sorted Arrat","type":"posts"},{"content":" Problem Statement Link - Problem 371 Question Given two integers a and b, return the sum of the two integers without using the operators + and -.\nExample 1 Input: a = 1, b = 2 Output: 3 Example 2 Input: a = 2, b = 3 Output: 5 Constraints - `-1000 \u0026lt;= a, b \u0026lt;= 1000` Solution class Solution { public: int getSum(int a, int b) { if(b==0) return a; else return getSum(a^b,(a\u0026amp;b)\u0026lt;\u0026lt;1); } }; Complexity Analysis | Algorithm | Time Complexity | Space Complexity | | ---------------- | --------------- | ---------------- | | Bit Manipulation | O(1) | O(1) | Explanation 1. Intuition - How can we add two numbers in binary form? - To add two bits we can use XOR operation. - This will handle the case where there is no carry being generated - Example: 2+1 - 2 -\u0026gt; 10 - 1 -\u0026gt; 01 - 2^1 -\u0026gt; 11 - To handle the carry we can use AND operation. - Example: 3+2 - 3-\u0026gt; 011 - 2-\u0026gt; 010 - 3^2 = 001 here carry goes missing hence we need to use and operator and shift it by 1 - (3\u0026amp;2)\u0026lt;\u0026lt;1 = 100 - so 3+2 = (3\u0026amp;2)\u0026lt;\u0026lt;1 ^ 3^2 = 100 ^ 001 = 101 = 5 We need to do this until there is no carry left. 2. Implementation - If `b` is 0 then return `a` - Else return the sum of `a^b` and `(a\u0026amp;b)\u0026lt;\u0026lt;1` Iterative Approach class Solution { public int getSum(int a, int b) { int ans=0; int carry=0; while(b!=0){ ans = a^b; carry = (a\u0026amp;b)\u0026lt;\u0026lt;1; a=ans; b=carry; } return a; } } ","date":"July 29, 2024","permalink":"/blog/posts/extraques/problem-371-sum-of-two-integers/","summary":"Problem Statement Link - Problem 371 Question Given two integers a and b, return the sum of the two integers without using the operators + and -.","title":"Problem 371 Sum of Two Integers","type":"posts"},{"content":" Problem Statement Link - Problem 3217 Question You are given an array of integers nums and the head of a linked list. Return the head of the modified linked list after removing all nodes from the linked list that have a value that exists in nums.\nExample 1 Input: nums = [1,2,3], head = [1,2,3,4,5] Output: [4,5] Example 2 Input: nums = [1], head = [1,2,1,2,1,2] Output: [2,2,2] Example 3 Input: nums = [5], head = [1,2,3,4] Output: [1,2,3,4] Constraints - `1 \u0026lt;= nums.length \u0026lt;= 10^5` - `1 \u0026lt;= nums[i] \u0026lt;= 10^5` - All elements in `nums` are unique. - `The number of nodes in the given list is in the range [1, 10^5]`. - `1 \u0026lt;= Node.val \u0026lt;= 10^5` - The input is generated such that there is at least one node in the linked list that has a value not present in `nums`. Solution /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ class Solution { public: ListNode* modifiedList(vector\u0026lt;int\u0026gt;\u0026amp; nums, ListNode* head) { unordered_set\u0026lt;int\u0026gt; s(nums.begin(),nums.end()); ListNode * ans=head; while(ans!=nullptr \u0026amp;\u0026amp; s.find(ans-\u0026gt;val)!=s.end()){ ans=ans-\u0026gt;next; } head=ans; while(head!=nullptr \u0026amp;\u0026amp; head-\u0026gt;next!=nullptr){ if(s.find(head-\u0026gt;next-\u0026gt;val)!=s.end()){ head-\u0026gt;next=head-\u0026gt;next-\u0026gt;next; } else{ head=head-\u0026gt;next; } } return ans; } }; Complexity Analysis | Algorithm | Time Complexity | Space Complexity | | ----------------- | --------------- | ---------------- | | Pointer Traversal | O(n) | O(n) | Explanation 1. Intuition - Use a hash set to store the elements of the array. - This will be used for lookup. - Initialize a pointer to the head of the linked list. - Traverse the linked list and remove the nodes which are present in the hash set. 2. Implementation - Initialize a hash set `s` with the elements of the array. - Initialize a pointer `ans` to the head of the linked list. - While `ans` is not null and the value of `ans` is present in the hash set, move `ans` to the next node. - Update the head of the linked list to `ans`. - While the head of the linked list is not null and the next node of the head is not null: - If the value of the next node of the head is present in the hash set, `head-\u0026gt;next` will point to the next node of the next node. - Else move the head to the next node. - Return the head of the linked list. ","date":"July 29, 2024","permalink":"/blog/posts/leetcode-contest/problem-3217-delete-nodes-from-linked-list-present-in-array/","summary":"Problem Statement Link - Problem 3217 Question You are given an array of integers nums and the head of a linked list.","title":"Problem 3217 Delete Nodes From Linked List Present in Array","type":"posts"},{"content":" Problem Statement Link - Problem 3233 Question You are given 2 positive integers l and r. For any number x, all positive divisors of x except x are called the proper divisors of x.\nA number is called special if it has exactly 2 proper divisors. For example:\nThe number 4 is special because it has proper divisors 1 and 2. The number 6 is not special because it has proper divisors 1, 2, and 3. Return the count of numbers in the range [l, r] that are not special. Example 1 Input: l = 5, r = 7 Output: 3 Explanation: There are no special numbers in the range [5, 7]. Example 2 Input: l = 4, r = 16 Output: 11 Explanation: The special numbers in the range [4, 16] are 4 and 9. Constraints - `1 \u0026lt;= l \u0026lt;= r \u0026lt;= 10^9` note From observation we can understand that all the special numbers are the squares of prime numbers, so the maximum prime number which can satisfy the condition is sqrt(r) and we can find all the prime numbers upto sqrt(r) and then we can find the square of those prime numbers and check if they are in the range [l, r] and count them.\nSolution class Solution { public: int nonSpecialCount(int l, int r) { int limit = sqrt(r) + 1; vector\u0026lt;bool\u0026gt; isPrime(limit + 1, true); isPrime[0] = isPrime[1] = false; for (int i = 2; i * i \u0026lt;= limit; ++i) { if (isPrime[i]) { for (int j = i * i; j \u0026lt;= limit; j += i) { isPrime[j] = false; } } } vector\u0026lt;int\u0026gt; primes; for (int i = 2; i \u0026lt;= limit; ++i) { if (isPrime[i]) { primes.push_back(i); } } int splCnt = 0; for (int prime : primes) { long long square = (long long)prime * prime; if (square \u0026gt;= l \u0026amp;\u0026amp; square \u0026lt;= r) { splCnt++; } } return r-l+1- splCnt; } }; Complexity Analysis | Algorithm | Time Complexity | Space Complexity | | --------------------- | ------------------------- | ---------------- | | Sieve of Eratosthenes | O(sqrt(r)loglog(sqrt(r))) | O(sqrt(r)) | | Counting | O(sqrt(r)) | O(sqrt(r)) | Explanation 1. Intuition - From observation we can understand that all the special numbers are the squares of prime numbers, so the maximum prime number which can satisfy the condition is sqrt(r) then we can find all the prime numbers upto sqrt(r) and then we can find the square of those prime numbers then check if they are in the range [l, r] and count them. 2. Implementation - We will first find all the prime numbers upto sqrt(r) using the Sieve of Eratosthenes algorithm. - Then we will find the square of all the prime numbers and check if they are in the range [l, r] and count them. - Then return `r-l+1- splCnt` which will give us the count of numbers which are not special. ","date":"July 29, 2024","permalink":"/blog/posts/leetcode-contest/problem-3233-find-the-count-of-numbers-which-are-not-special/","summary":"Problem Statement Link - Problem 3233 Question You are given 2 positive integers l and r.","title":"Problem 3233 Find the Count of Numbers Which Are Not Special","type":"posts"},{"content":" Problem Statement Link - Problem 3232 Question You are given an array of positive integers nums.\nAlice and Bob are playing a game. In the game, Alice can choose either all single-digit numbers or all double-digit numbers from nums, and the rest of the numbers are given to Bob. Alice wins if the sum of her numbers is strictly greater than the sum of Bob\u0026rsquo;s numbers.\nReturn true if Alice can win this game, otherwise, return false.\nExample 1 Input: nums = [1,2,3,4,10] Output: false Explanation: Alice cannot win by choosing either single-digit or double-digit numbers. Example 2 Input: nums = [1,2,3,4,5,14] Output: true Explanation: Alice can win by choosing single-digit numbers which have a sum equal to 15. Example 3 Input: nums = [5,5,5,25] Output: true Explanation: Alice can win by choosing double-digit numbers which have a sum equal to 25. Constraints - `1 \u0026lt;= nums.length \u0026lt;= 100` - `1 \u0026lt;= nums[i] \u0026lt;= 99` Solution class Solution { public: bool canAliceWin(vector\u0026lt;int\u0026gt;\u0026amp; nums) { //sort(nums.begin(),nums.end()); int ones=0,tens=0; for(int it:nums){ if(it\u0026lt;=9) ones+=it; else tens+=it; } if(ones==tens) return false; return true; } }; Complexity Analysis | Algorithm | Time Complexity | Space Complexity | | --------- | --------------- | ---------------- | | Traversal | O(n) | O(1) | Explanation 1. Intuition - By observation we can say that 1. If the sum of all single digit numbers exceed the sum of all double digit numbers then Alice will choose the set of single digit numbers. 2. If the sum of all double digit numbers exceed the sum of all single digit numbers then Alice will choose the set of double digit numbers. - The only case when Alice cannot win is when the sum of all single digit numbers is equal to the sum of all double digit numbers. 2. Implementation - We will iterate over the array and count the sum of all single digit numbers and double digit numbers. - If the sum of all single digit numbers is equal to the sum of all double digit numbers then return false. - Else return true. ","date":"July 29, 2024","permalink":"/blog/posts/leetcode-contest/problem-3232-find-if-digit-game-can-be-won/","summary":"Problem Statement Link - Problem 3232 Question You are given an array of positive integers nums.","title":"Problem 3232 Find if Digit Game Can Be Won","type":"posts"},{"content":" Problem Statement Link - Problem 1395 Question There are n soldiers standing in a line. Each soldier is assigned a unique rating value.\nYou have to form a team of 3 soldiers amongst them under the following rules:\nChoose 3 soldiers with index (i, j, k) with rating (rating[i], rating[j], rating[k]). A team is valid if: (rating[i] \u0026lt; rating[j] \u0026lt; rating[k]) or (rating[i] \u0026gt; rating[j] \u0026gt; rating[k]) where (0 \u0026lt;= i \u0026lt; j \u0026lt; k \u0026lt; n). Return the number of teams you can form given the conditions. (soldiers can be part of multiple teams).\nNote They want us to count the number of 3-membered sub sequences which satisfiy the rating requirement.\nExample 1 Input: rating = [2,5,3,4,1] Output: 3 Explanation: We can form three teams given the conditions. (2,3,4), (5,4,1), (5,3,1). Example 2 Input: rating = [2,1,3] Output: 0 Explanation: We can\u0026#39;t form any team given the conditions. Example 3 Input: rating = [1,2,3,4] Output: 4 Constraints - `n == rating.length` - `3 \u0026lt;= n \u0026lt;= 1000` - `1 \u0026lt;= rating[i] \u0026lt;= 10^5` - All the integers in `rating` are unique. Solution // Optimal Code class Solution { public: int numTeams(vector\u0026lt;int\u0026gt;\u0026amp; rating) { int count=0,size = rating.size(); for(int mid = 0; mid\u0026lt;size; mid++){ int leftSmall = 0; int rightBig = 0; int leftBig,rightSmall; for(int l=mid-1;l\u0026gt;=0;l--){ if(rating[l]\u0026lt;rating[mid]) leftSmall++; } for(int r =mid+1;r\u0026lt;size;r++){ if(rating[mid]\u0026lt;rating[r]) rightBig++; } leftBig = mid-leftSmall; rightSmall = size-1-mid-rightBig; count+= (leftSmall*rightBig) + (leftBig*rightSmall); } return count; } }; Complexity Analysis | Algorithm | Time Complexity | Space Complexity | | ------------------- | --------------- | ---------------- | | Dynamic programming | O(n^2) | O(1) | Explanation 1. Intuition - We consider each soldier as a middle memeber of the sub sequence. - Then count the number of soldiers who have less rating than middle member towards the left side. - Count the number of soldiers who have higher rating than the middle memeber towards the right side. - Total possible subsequences of form (`rating[i]\u0026lt;rating[j]\u0026lt;rating[k]`) will be (lowrated left members X high rated right members.) - Similarly derive the number of high rated members on left side by `middle - lower left` - Derive low rated right members by `size-1-middle - higher left`. - multiply them to get subsequences of form (`rating[i]\u0026gt;rating[j]\u0026gt;rating[k]`) - Do this for every member and we will get total count. 2. Implementation - Initialize the `count` to 0. - Store the size of the `rating` array at `size`. - Iterate over the `rating` array. - For each member consider it as middle member. - Initialize `leftSmall` and `rightBig` to 0. - Iterate over the left side of the middle member. - If the rating of the member is less than the middle member increment `leftSmall`. - Iterate over the right side of the middle member. - If the rating of the member is greater than the middle member increment `rightBig`. - Calculate the `leftBig` and `rightSmall` members. - Increment the `count` by the product of `leftSmall` and `rightBig` and `leftBig` and `rightSmall`. - Return the `count`. Unoptimised code First intuition was to use brute force\nclass Solution { public: int numTeams(vector\u0026lt;int\u0026gt;\u0026amp; rating) { int count=0,size = rating.size(); for(int i=0;i\u0026lt;size-2;i++){ for(int j=i+1;j\u0026lt;size-1;j++){ for(int k=j+1;k\u0026lt;size;k++){ if(rating[i]\u0026lt;rating[j] \u0026amp;\u0026amp; rating[j]\u0026lt;rating[k]) count++; if(rating[i]\u0026gt;rating[j] \u0026amp;\u0026amp; rating[j]\u0026gt;rating[k]) count++; } } } return count; } }; Time Complexity Space Complexity O(n^3) O(1) Then there is a better approach to solve this problem using dynamic programming.\nMemoization technique\nAlgorithm\nInitialize n as the size of the rating array. teams to store the number of teams. Two arrays increasingCache and decreasingCache of size n*4 to serve as cache. Loop over the rating. For each index startIndex: Call countIncreasingTeams and countDecreasingTeams with startIndex. Add the result to teams. Return teams. Helper method countIncreasingTeams: Inputs : rating,currentIndex,teamSize and cache increasingCache. Initialize n as the length of the rating array. If teamSize is 3, return 1. If currentIndex is greater than or equal to n, return 0. If the value at increasingCache[currentIndex][teamSize] is not -1, return the value. Initialize a variable validTeams to 0. Loop from currentIndex+1 to end of array. For each index nextIndex: If rating[nextIndex] \u0026gt; rating[currentIndex], increment validTeams by countIncreasingTeams with nextIndex and teamSize+1. Store validTeams in increasingCache[currentIndex][teamSize]. Helper method countDecreasingTeams: Similar to countIncreasingTeams but with the condition rating[nextIndex] \u0026lt; rating[currentIndex]. class Solution { public: int numTeams(vector\u0026lt;int\u0026gt;\u0026amp; rating) { int n = rating.size(); int teams = 0; vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; increasingCache(n, vector\u0026lt;int\u0026gt;(4, -1)); vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; decreasingCache(n, vector\u0026lt;int\u0026gt;(4, -1)); // Calculate total teams by considering each soldier as a starting point for (int startIndex = 0; startIndex \u0026lt; n; startIndex++) { teams += countIncreasingTeams(rating, startIndex, 1, increasingCache) + countDecreasingTeams(rating, startIndex, 1, decreasingCache); } return teams; } private: int countIncreasingTeams(const vector\u0026lt;int\u0026gt;\u0026amp; rating, int currentIndex, int teamSize, vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; increasingCache) { int n = rating.size(); // Base case: reached end of array if (currentIndex == n) return 0; // Base case: found a valid team of size 3 if (teamSize == 3) return 1; // Return cached result if available if (increasingCache[currentIndex][teamSize] != -1) { return increasingCache[currentIndex][teamSize]; } int validTeams = 0; // Recursively count teams with increasing ratings for (int nextIndex = currentIndex + 1; nextIndex \u0026lt; n; nextIndex++) { if (rating[nextIndex] \u0026gt; rating[currentIndex]) { validTeams += countIncreasingTeams( rating, nextIndex, teamSize + 1, increasingCache); } } // Cache and return the result return increasingCache[currentIndex][teamSize] = validTeams; } int countDecreasingTeams(const vector\u0026lt;int\u0026gt;\u0026amp; rating, int currentIndex, int teamSize, vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; decreasingCache) { int n = rating.size(); // Base case: reached end of array if (currentIndex == n) return 0; // Base case: found a valid team of size 3 if (teamSize == 3) return 1; // Return cached result if available if (decreasingCache[currentIndex][teamSize] != -1) { return decreasingCache[currentIndex][teamSize]; } int validTeams = 0; // Recursively count teams with decreasing ratings for (int nextIndex = currentIndex + 1; nextIndex \u0026lt; n; nextIndex++) { if (rating[nextIndex] \u0026lt; rating[currentIndex]) { validTeams += countDecreasingTeams( rating, nextIndex, teamSize + 1, decreasingCache); } } // Cache and return the result return decreasingCache[currentIndex][teamSize] = validTeams; } }; Time Complexity Space Complexity O(n^2) O(n) + O(n) Tabulation technique\nclass Solution { public: int numTeams(vector\u0026lt;int\u0026gt;\u0026amp; rating) { int n = rating.size(); int teams = 0; // Tables for increasing and decreasing sequences vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; increasingTeams(n, vector\u0026lt;int\u0026gt;(4, 0)); vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; decreasingTeams(n, vector\u0026lt;int\u0026gt;(4, 0)); // Fill the base cases. (Each soldier is a sequence of length 1) for (int i = 0; i \u0026lt; n; i++) { increasingTeams[i][1] = 1; decreasingTeams[i][1] = 1; } // Fill the tables for (int count = 2; count \u0026lt;= 3; count++) { for (int i = 0; i \u0026lt; n; i++) { for (int j = i + 1; j \u0026lt; n; j++) { if (rating[j] \u0026gt; rating[i]) { increasingTeams[j][count] += increasingTeams[i][count - 1]; } if (rating[j] \u0026lt; rating[i]) { decreasingTeams[j][count] += decreasingTeams[i][count - 1]; } } } } // Sum up the results (All sequences of length 3) for (int i = 0; i \u0026lt; n; i++) { teams += increasingTeams[i][3] + decreasingTeams[i][3]; } return teams; } }; Time Complexity Space Complexity O(n^2) O(n) + O(n) there is a better approach to solve this problem using Fenwick Tree. Can be read at Link ","date":"July 29, 2024","permalink":"/blog/leetcode-potd/problem-1395-count-number-of-teams/","summary":"Problem Statement Link - Problem 1395 Question There are n soldiers standing in a line.","title":"Problem 1395 Count Number of Teams","type":"leetcode-potd"},{"content":" Problem Statement Link - Problem 103 Question Given the root of a binary tree, return the zigzag level order traversal of its nodes\u0026rsquo; values. (i.e., from left to right, then right to left for the next level and alternate between).\nExample 1 Input: root = [3,9,20,null,null,15,7] Output: [[3],[20,9],[15,7]] Example 2 Input: root = [1] Output: [[1]] Example 3 Input: root = [] Output: [] Constraints - The number of nodes in the tree is in the range `[0, 2000]`. - `-100 \u0026lt;= Node.val \u0026lt;= 100` Solution /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; zigzagLevelOrder(TreeNode* root) { if(root==nullptr) return {}; vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;ans; queue\u0026lt;TreeNode*\u0026gt;q; q.push(root); bool flag = true; while(!q.empty()){ int size = q.size(); vector\u0026lt;int\u0026gt;v; for(int i =0 ;i\u0026lt;size;i++){ TreeNode* t = q.front(); q.pop(); if(t-\u0026gt;left) q.push(t-\u0026gt;left); if(t-\u0026gt;right) q.push(t-\u0026gt;right); if(flag){ v.push_back(t-\u0026gt;val); } else{ v.insert(v.begin(),t-\u0026gt;val); } } ans.push_back(v); flag =!flag; } return ans; } }; Complexity Analysis | Algorithm | Time Complexity | Space Complexity | | --------------- | --------------- | ---------------- | | BFS level order | O(n) | O(n) | Explanation 1. Intuition - The logic is follows. - We will do just BFS, but maintain a flag to check if we need to reverse the order of the elements in the vector. 2. Implementation - If the root is `nullptr` return empty vector. - Create a vector of vector of int `ans`. - Create a queue of TreeNode\\* `q`. - Push the root into the queue. - Create a flag `flag` to check if we need to reverse the order of the elements in the vector. - Until the queue is not empty - Get the size of the queue. - Create a vector of int `v`. - Loop through the size of the queue - Get the front element of the queue. - Pop the front element of the queue. - If the left of the front element is not `nullptr` push it into the queue. - If the right of the front element is not `nullptr` push it into the queue. - If the flag is true push the value of the front element into the vector. - Else insert the value of the front element at the beginning of the vector. - Push the vector into the `ans`. - Reverse the flag. - Return the `ans`. ","date":"July 29, 2024","permalink":"/blog/posts/extraques/problem-103-binary-tree-zigzag-level-order-traversal/","summary":"Problem Statement Link - Problem 103 Question Given the root of a binary tree, return the zigzag level order traversal of its nodes\u0026rsquo; values.","title":"Problem 103 Binary Tree Zigzag Level Order Traversal","type":"posts"},{"content":" Problem Statement Link - Problem 82 Question Given the head of a sorted linked list, delete all nodes that have duplicate numbers, leaving only distinct numbers from the original list. Return the linked list sorted as well.\nExample 1 Input: head = [1,2,3,3,4,4,5] Output: [1,2,5] Example 2 Input: head = [1,1,1,2,3] Output: [2,3] Constraints - `The number of nodes in the list is in the range [0, 300].` - `-100 \u0026lt;= Node.val \u0026lt;= 100` - The list is guaranteed to be sorted in ascending order. Solution /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ class Solution { public: ListNode* deleteDuplicates(ListNode* head) { if(head == nullptr || head-\u0026gt;next ==nullptr) return head; ListNode* dummy = new ListNode(-1); dummy-\u0026gt;next = head; ListNode* prev = dummy; ListNode* curr = head; while(curr != nullptr \u0026amp;\u0026amp; curr-\u0026gt;next!=nullptr){ if(curr-\u0026gt;val != curr-\u0026gt;next-\u0026gt;val){ prev = curr; curr=curr-\u0026gt;next; } else{ while(curr!=nullptr \u0026amp;\u0026amp; prev-\u0026gt;next-\u0026gt;val == curr-\u0026gt;val){ curr = curr-\u0026gt;next; } prev-\u0026gt;next = curr; } } return dummy-\u0026gt;next; } }; Complexity Analysis | Algorithm | Time Complexity | Space Complexity | | ------------ | --------------- | ---------------- | | Two Pointers | O(n) | O(1) | Explanation 1. Intuition - The logic is follows. - Add a dummy node behind the head. - `prev` points to dummy. - `curr` points to dummy-\u0026gt;next or head. - until the `curr` and `curr-\u0026gt;next` is not `nullptr` - if value of curr is not equal to the value of next of curr - increment prev to curr - increment curr to next of curr; - else while value of next of prev is equal to value of curr - increment curr - set prev to curr - return dummy-\u0026gt;next; 2. Implementation - Initialize a `dummy` node behind the `head`. - `dummy-\u0026gt;next` points to `head`. - `prev` points to `dummy`. - `curr` points to `head`. - until the `curr` and `curr-\u0026gt;next` is not `nullptr` - if value of curr is not equal to the value of next of curr - increment prev to curr - increment curr to next of curr; - else while value of next of prev is equal to value of curr - increment curr - set prev to curr - return dummy-\u0026gt;next; ","date":"July 28, 2024","permalink":"/blog/posts/extraques/problem-82-remove-duplicates-from-sorted-list-ii/","summary":"Problem Statement Link - Problem 82 Question Given the head of a sorted linked list, delete all nodes that have duplicate numbers, leaving only distinct numbers from the original list.","title":"Problem 82 Remove Duplicates From Sorted List II","type":"posts"},{"content":" Problem Statement Link - Problem 299 Question You are playing the Bulls and Cows game with your friend.\nYou write down a secret number and ask your friend to guess what the number is. When your friend makes a guess, you provide a hint with the following info:\nThe number of \u0026ldquo;bulls\u0026rdquo;, which are digits in the guess that are in the correct position. The number of \u0026ldquo;cows\u0026rdquo;, which are digits in the guess that are in your secret number but are located in the wrong position. Specifically, the non-bull digits in the guess that could be rearranged such that they become bulls. Given the secret number secret and your friend\u0026rsquo;s guess guess, return the hint for your friend\u0026rsquo;s guess.\nThe hint should be formatted as \u0026quot;xAyB\u0026quot;, where x is the number of bulls and y is the number of cows. Note that both secret and guess may contain duplicate digits.\nExample 1 Input: secret = \u0026#34;1807\u0026#34;, guess = \u0026#34;7810\u0026#34; Output: \u0026#34;1A3B\u0026#34; Explanation: Bulls are connected with a \u0026#39;|\u0026#39; and cows are underlined: \u0026#34;1807\u0026#34; | \u0026#34;7810\u0026#34; Example 2 Input: secret = \u0026#34;1123\u0026#34;, guess = \u0026#34;0111\u0026#34; Output: \u0026#34;1A1B\u0026#34; Explanation: Bulls are connected with a \u0026#39;|\u0026#39; and cows are underlined: \u0026#34;1123\u0026#34; \u0026#34;1123\u0026#34; | or | \u0026#34;0111\u0026#34; \u0026#34;0111\u0026#34; Note that only one of the two unmatched 1s is counted as a cow since the non-bull digits can only be rearranged to allow one 1 to be a bull. Constraints - `1 \u0026lt;= secret.length, guess.length \u0026lt;= 1000` - `secret.length == guess.length` - `secret` and `guess` consist of digits only. Solution class Solution { public: string getHint(string secret, string guess) { vector\u0026lt;int\u0026gt; s(10, 0); vector\u0026lt;int\u0026gt; g(10, 0); int bull = 0, cow = 0; for (int i = 0; i \u0026lt; secret.size(); i++) { if (secret[i] == guess[i]) { bull++; } else { s[secret[i] - \u0026#39;0\u0026#39;]++; g[guess[i] - \u0026#39;0\u0026#39;]++; } } for (int i = 0; i \u0026lt; 10; i++) { cow += min(s[i], g[i]); } return to_string(bull) + \u0026#39;A\u0026#39; + to_string(cow) + \u0026#39;B\u0026#39;; } }; Complexity Analysis | Algorithm | Time Complexity | Space Complexity | | --------- | --------------- | ---------------- | | Traversal | O(n) | O(n) | Explanation 1. Intuition - We can count the frequencies of digits in `secret` and `guess`. - After that bulls will be the count of matching characters in given string. - Cows will be the sum of minimum of frequencies of each digit in `secret` and `guess`. - Sum of minimums works because - if the frequency of a digit `k` is less in guess then it means, `k` digits are present but in wrong places. - if the frequency of a digit `k` is less in secert it means only `k` digits are present but are in wrong places. - return in `xAyB` format. 2. Implementation - Initialize two vectors `s` and `g` to count the frequencies of digits. - Iterate over the strings - if the characters are matching then increment the `bull` count. - else increment the frequencies of digits in `s` and `g`. - Iterate over the frequencies of digits and calculate the `cow` count. - cow will be the sum of minimum of frequencies of digits in `s` and `g`. - return the `xAyB` format. ","date":"July 28, 2024","permalink":"/blog/posts/extraques/problem-299-bulls-and-cows/","summary":"Problem Statement Link - Problem 299 Question You are playing the Bulls and Cows game with your friend.","title":"Problem 299 Bulls and Cows","type":"posts"},{"content":" Problem Statement Link - Problem 284 Question Design an iterator that supports the peek operation on an existing iterator in addition to the hasNext and the next operations.\nImplement the PeekingIterator class:\nPeekingIterator(Iterator\u0026lt;int\u0026gt; nums) Initializes the object with the given integer iterator iterator. int next() Returns the next element in the array and moves the pointer to the next element. boolean hasNext() Returns true if there are still elements in the array. int peek() Returns the next element in the array without moving the pointer. Note: Each language may have a different implementation of the constructor and Iterator, but they all support the int next() and boolean hasNext() functions.\nExample 1 Input [\u0026#34;PeekingIterator\u0026#34;, \u0026#34;next\u0026#34;, \u0026#34;peek\u0026#34;, \u0026#34;next\u0026#34;, \u0026#34;next\u0026#34;, \u0026#34;hasNext\u0026#34;] [[[1, 2, 3]], [], [], [], [], []] Output [null, 1, 2, 2, 3, false] Explanation PeekingIterator peekingIterator = new PeekingIterator([1, 2, 3]); // [1,2,3] peekingIterator.next(); // return 1, the pointer moves to the next element [1,2,3]. peekingIterator.peek(); // return 2, the pointer does not move [1,2,3]. peekingIterator.next(); // return 2, the pointer moves to the next element [1,2,3] peekingIterator.next(); // return 3, the pointer moves to the next element [1,2,3] peekingIterator.hasNext(); // return False Constraints - `1 \u0026lt;= nums.length \u0026lt;= 1000` - `1 \u0026lt;= nums[i] \u0026lt;= 1000` - All the calls to `next` and `peek` are valid. - At most 1000 calls will be made to `next`, `hasNext`, and `peek`. Solution /* * Below is the interface for Iterator, which is already defined for you. * **DO NOT** modify the interface for Iterator. * * class Iterator { *\tstruct Data; * Data* data; * public: *\tIterator(const vector\u0026lt;int\u0026gt;\u0026amp; nums); * Iterator(const Iterator\u0026amp; iter); * * // Returns the next element in the iteration. *\tint next(); * *\t// Returns true if the iteration has more elements. *\tbool hasNext() const; *\t}; */ class PeekingIterator : public Iterator { public: int currNext=-1; bool currHasNext=false; PeekingIterator(const vector\u0026lt;int\u0026gt;\u0026amp; nums) : Iterator(nums) { // Initialize any member here. // **DO NOT** save a copy of nums and manipulate it directly. // You should only use the Iterator interface methods. currHasNext = Iterator::hasNext(); if(currHasNext){ currNext = Iterator::next(); } } // Returns the next element in the iteration without advancing the iterator. int peek() { return currNext; } // hasNext() and next() should behave the same as in the Iterator interface. // Override them if needed. int next() { int result = currNext; currHasNext = Iterator::hasNext(); if(currHasNext){ currNext = Iterator::next(); } return result; } bool hasNext() const { return currHasNext; } }; Complexity Analysis | Algorithm | Time Complexity | Space Complexity | | --------- | --------------- | ---------------- | | Peek | O(1) | O(1) | Explanation 1. Intuition - the given class `iterator` has the following functions: - `int next()` - `boolean hasNext()` - `int next()` will return the next element and increments the iterator. - `boolean hasNext()` will return a boolean value if there is an element present next - We need to implement a `peek` function that will return the next element without incrementing the iterator. - Hence we need to cache the next element and the boolean value if there is an element present next. - We will use the `currNext` and `currHasNext` variables to store the next element and the boolean value if there is an element present next. - We will initialize the `currNext` and `currHasNext` variables in the constructor. - In the constructor, we will check if there is an element present next and store the next element in the `currNext` variable. - In the `peek` function, we will return the `currNext` variable. - In the `next` function, we will return the `currNext` variable and update the `currNext` and `currHasNext` variables. - In the `hasNext` function, we will return the `currHasNext` variable. 2. Implementation - We will create a class `PeekingIterator` that will inherit the `Iterator` class. - We will create two variables `currNext` and `currHasNext` to store the next element and the boolean value if there is an element present next. - In the constructor, we will initialize the `currNext` and `currHasNext` variables. - In the `peek` function, we will return the `currNext` variable. - In the `next` function - We will store the `currNext` variable in the `result` variable. - if there is an element present next, we will update the `currNext` and `currHasNext` variables. - return `result` - In the `hasNext` function return the `currHasNext` variable. ","date":"July 27, 2024","permalink":"/blog/posts/extraques/problem-284-peeking-iterator/","summary":"Problem Statement Link - Problem 284 Question Design an iterator that supports the peek operation on an existing iterator in addition to the hasNext and the next operations.","title":"Problem 284 Peeking Iterator","type":"posts"},{"content":" Problem Statement Link - Problem Question You are given two 0-indexed strings source and target, both of length n and consisting of lowercase English letters. You are also given two 0-indexed character arrays original and changed, and an integer array cost, where cost[i] represents the cost of changing the character original[i] to the character changed[i].\nYou start with the string source. In one operation, you can pick a character x from the string and change it to the character y at a cost of z if there exists any index j such that cost[j] == z, original[j] == x, and changed[j] == y.\nReturn the minimum cost to convert the string source to the string target using any number of operations. If it is impossible to convert source to target, return -1.\nNote that there may exist indices i, j such that original[j] == original[i] and changed[j] == changed[i].\nNote One of the edge case is when the there are different weights for the same character in the original and changed array. In that case, we need to consider the minimum cost.\nThis is crucial when using the Floyd-Warshall algorithm.\nExample 1 Input: source = \u0026#34;abcd\u0026#34;, target = \u0026#34;acbe\u0026#34;, original = [\u0026#34;a\u0026#34;,\u0026#34;b\u0026#34;,\u0026#34;c\u0026#34;,\u0026#34;c\u0026#34;,\u0026#34;e\u0026#34;,\u0026#34;d\u0026#34;], changed = [\u0026#34;b\u0026#34;,\u0026#34;c\u0026#34;,\u0026#34;b\u0026#34;,\u0026#34;e\u0026#34;,\u0026#34;b\u0026#34;,\u0026#34;e\u0026#34;], cost = [2,5,5,1,2,20] Output: 28 Explanation: To convert the string \u0026#34;abcd\u0026#34; to string \u0026#34;acbe\u0026#34;: - Change value at index 1 from \u0026#39;b\u0026#39; to \u0026#39;c\u0026#39; at a cost of 5. - Change value at index 2 from \u0026#39;c\u0026#39; to \u0026#39;e\u0026#39; at a cost of 1. - Change value at index 2 from \u0026#39;e\u0026#39; to \u0026#39;b\u0026#39; at a cost of 2. - Change value at index 3 from \u0026#39;d\u0026#39; to \u0026#39;e\u0026#39; at a cost of 20. The total cost incurred is 5 + 1 + 2 + 20 = 28. It can be shown that this is the minimum possible cost. Example 2 Input: source = \u0026#34;aaaa\u0026#34;, target = \u0026#34;bbbb\u0026#34;, original = [\u0026#34;a\u0026#34;,\u0026#34;c\u0026#34;], changed = [\u0026#34;c\u0026#34;,\u0026#34;b\u0026#34;], cost = [1,2] Output: 12 Explanation: To change the character \u0026#39;a\u0026#39; to \u0026#39;b\u0026#39; change the character \u0026#39;a\u0026#39; to \u0026#39;c\u0026#39; at a cost of 1, followed by changing the character \u0026#39;c\u0026#39; to \u0026#39;b\u0026#39; at a cost of 2, for a total cost of 1 + 2 = 3. To change all occurrences of \u0026#39;a\u0026#39; to \u0026#39;b\u0026#39;, a total cost of 3 * 4 = 12 is incurred. Example 3 Input: source = \u0026#34;abcd\u0026#34;, target = \u0026#34;abce\u0026#34;, original = [\u0026#34;a\u0026#34;], changed = [\u0026#34;e\u0026#34;], cost = [10000] Output: -1 Explanation: It is impossible to convert source to target because the value at index 3 cannot be changed from \u0026#39;d\u0026#39; to \u0026#39;e\u0026#39;. Constraints - `1 \u0026lt;= source.length == target.length \u0026lt;= 10^5` - `source`, `target` consist of lowercase English letters. - `1 \u0026lt;= cost.length == original.length == changed.length \u0026lt;= 2000` - `original[i]`, `changed[i]` are lowercase English letters. - `1 \u0026lt;= cost[i] \u0026lt;= 10^6` - `original[i] != changed[i]` Solution class Solution { public: vector\u0026lt;vector\u0026lt;long long\u0026gt;\u0026gt; floydWarshal(vector\u0026lt;char\u0026gt;\u0026amp; original,vector\u0026lt;char\u0026gt;\u0026amp; changed, vector\u0026lt;int\u0026gt;\u0026amp; cost){ vector\u0026lt;vector\u0026lt;long long\u0026gt;\u0026gt;minCost(26,vector\u0026lt;long long\u0026gt;(26,INT_MAX)); int s,t; for(int i = 0; i\u0026lt;original.size(); i++){ s = original[i]-\u0026#39;a\u0026#39;; t = changed[i]-\u0026#39;a\u0026#39;; minCost[s][t]=min(minCost[s][t],(long long)cost[i]); // This is needed because there may be repeated edges with different weights } for(int k =0;k\u0026lt;26;k++){ for(int i=0;i\u0026lt;26;i++){ for(int j= 0; j\u0026lt;26;j++){ if(minCost[i][j]\u0026gt;minCost[i][k]+minCost[k][j]){ minCost[i][j] = minCost[i][k]+minCost[k][j]; } } } } return minCost; } long long minimumCost(string source, string target, vector\u0026lt;char\u0026gt;\u0026amp; original, vector\u0026lt;char\u0026gt;\u0026amp; changed, vector\u0026lt;int\u0026gt;\u0026amp; cost) { vector\u0026lt;vector\u0026lt;long long\u0026gt;\u0026gt;minCost = floydWarshal(original,changed,cost); long long totCost = 0; int s,t; for(int i =0;i\u0026lt;source.size();i++){ if(source[i]!=target[i]){ s = source[i]-\u0026#39;a\u0026#39;; t = target[i]-\u0026#39;a\u0026#39;; if(minCost[s][t]==INT_MAX) return -1; totCost+=minCost[s][t]; } } return totCost; } }; Complexity Analysis | Algorithm | Time Complexity | Space Complexity | | ------------- | --------------- | ---------------- | | Floyd-Warshal | O(26^3) | O(26^2) | Explanation 1. Intuition - Since we need to check if we can derive one character from another, we can model this problem as a graph where the nodes are the characters and the edges are the cost of changing one character to another. - The cost to convert character `a` to character `b` is the minimum path from `a` to `b` in the graph. - It need not to be the immediate connection between `a` and `b`. - Since we have 26 characters, we have 26x26 matrix to store the cost of changing one character to another. - Hence we can use the Floyd-Warshall algorithm to find the minimum cost to convert the string. - First build cost matrix using the original and changed array. - Then use the Floyd-Warshall algorithm to find the minimum cost to convert the string. - Then for each character in source and target 1. if they are not equal, find the cost to convert the character from source to target. 2. If the cost is INT_MAX, return -1. 3. Else add the cost to the total cost. - Return the total cost. 2. Implementation - Define the `floydWarshal` function which takes the original, changed and cost array as input - Initialize the cost matrix with INT_MAX - for each edge `minCost[s][t] = min(minCost[s][t],cost[i])` - This is because there may be repeated edges with different weights - Use the Floyd-Warshall algorithm to find the minimum cost to convert the string - Return the cost matrix - Once the cost matrix is obtained, iterate through each character in source and target - If the characters are not equal - Find the cost to convert the character from source to target - If the cost is INT_MAX, return -1 - Else add the cost to the total cost - Return the total cost The intuition to convert this word problem to a graph problem is crucial. This is a common pattern in graph problems where we need to find the minimum cost to convert one thing to another.\n","date":"July 27, 2024","permalink":"/blog/leetcode-potd/problem-2976-minimum-cost-to-convert-string-i/","summary":"Problem Statement Link - Problem Question You are given two 0-indexed strings source and target, both of length n and consisting of lowercase English letters.","title":"Problem 2976 Minimum Cost to Convert String I","type":"leetcode-potd"},{"content":" Problem Statement Link - Problem 1334 Question There are n cities numbered from 0 to n-1. Given the array edges where edges[i] = [fromi, toi, weighti] represents a bidirectional and weighted edge between cities fromi and toi, and given the integer distanceThreshold.\nReturn the city with the smallest number of cities that are reachable through some path and whose distance is at most distanceThreshold, If there are multiple such cities, return the city with the greatest number.\nNotice that the distance of a path connecting cities i and j is equal to the sum of the edges\u0026rsquo; weights along that path.\nExample 1 flowchart LR A((0))-- 3 ---B((1)) B--1---C((2)) B--4---D((3)) C--1---D Input: n = 4, edges = [[0,1,3],[1,2,1],[1,3,4],[2,3,1]], distanceThreshold = 4 Output: 3 Explanation: The figure above describes the graph. The neighboring cities at a distanceThreshold = 4 for each city are: City 0 -\u0026gt; [City 1, City 2] City 1 -\u0026gt; [City 0, City 2, City 3] City 2 -\u0026gt; [City 0, City 1, City 3] City 3 -\u0026gt; [City 1, City 2] Cities 0 and 3 have 2 neighboring cities at a distanceThreshold = 4, but we have to return city 3 since it has the greatest number. Example 2 flowchart LR A((0))-- 2 ---B((1)) A--8---E((4)) B--3---C((2)) B--2---E C--1---D((3)) D--1---E Input: n = 5, edges = [[0,1,2],[0,4,8],[1,2,3],[1,4,2],[2,3,1],[3,4,1]], distanceThreshold = 2 Output: 0 Explanation: The figure above describes the graph. The neighboring cities at a distanceThreshold = 2 for each city are: City 0 -\u0026gt; [City 1] City 1 -\u0026gt; [City 0, City 4] City 2 -\u0026gt; [City 3, City 4] City 3 -\u0026gt; [City 2, City 4] City 4 -\u0026gt; [City 1, City 2, City 3] The city 0 has 1 neighboring city at a distanceThreshold = 2. Constraints - `2 \u0026lt;= n \u0026lt;= 100` - `1 \u0026lt;= edges.length \u0026lt;= n * (n - 1) / 2` - `edges[i].length == 3` - `0 \u0026lt;= fromi \u0026lt; toi \u0026lt; n` - `1 \u0026lt;= weighti, distanceThreshold \u0026lt;= 10^4` - All pairs `(fromi, toi)` are distinct. Solution class Solution { public: vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; floydWarshal(int V,vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp;edges){ int Lim = 1e9; vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; dist(V,vector\u0026lt;int\u0026gt;(V,Lim)); for(int i = 0; i\u0026lt;V; i++){ dist[i][i] = 0; for(const auto\u0026amp; edge:edges){ dist[edge[0]][edge[1]] = edge[2]; dist[edge[1]][edge[0]] = edge[2]; } } for(int k = 0; k \u0026lt; V; k++){ for(int i = 0; i \u0026lt; V; i++){ for(int j = 0; j \u0026lt; V; j++){ if(dist[i][k] + dist[k][j] \u0026lt; dist[i][j]){ dist[i][j] = dist[i][k] + dist[k][j]; } } } } return dist; } int findTheCity(int n, vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; edges, int distanceThreshold) { std::ios::sync_with_stdio(false); vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; dist = floydWarshal(n,edges); int distCnt = 0,maxCity = INT_MIN,minCnt = INT_MAX; for(int i = 0; i\u0026lt;n;i++){ distCnt = 0; for(int j =0;j\u0026lt;n;j++){ if(dist[i][j]\u0026lt;=distanceThreshold){ distCnt+=1; } } if(distCnt\u0026lt;=minCnt){ minCnt = distCnt; if(maxCity\u0026lt;i){ maxCity = i; } } } return maxCity; } }; Complexity Analysis | Algorithm | Time Complexity | Space Complexity | | -------------- | --------------- | ---------------- | | Flowd Warshall | O(V^3) | O(V^2) | Explanation 1. Intuition - We can use floyd warshall algorithm to find all pair shortest paths - Then we can iterate through each node and count number of neighbours with distance less than or equal to the distance threshold. - If the count is less than the count seen so far - update the count to new count - if the current city number is bigger than previous min, update city number 2. Implementation - Initialize the \u0026#39;floydWarshal\u0026#39; function which takes the number of cities and edges as input - Initialize the distance matrix with a large number - Iterate through each edge and update the distance matrix - return the distance matrix - Once the distance matrix is obtained, iterate through each city - Initialize the distance count to 0 - Iterate through each city and check if the distance is less than or equal to the threshold - If yes, increment the distance count - If the distance count is less than or equal to the minimum count - Update the minimum count - If the current city number is greater than the previous minimum city number - Update the city number - Return the city number ","date":"July 26, 2024","permalink":"/blog/leetcode-potd/problem-1334-find-the-city-with-the-smallest-number-of-neighbours-at-a-threshold-distance/","summary":"Problem Statement Link - Problem 1334 Question There are n cities numbered from 0 to n-1.","title":"Problem 1334 Find the City With the Smallest Number of Neighbours at a Threshold Distance","type":"leetcode-potd"},{"content":" Problem Statement Link - Problem 89 Question An n-bit gray code sequence is a sequence of 2^n integers where:\nEvery integer is in the inclusive range [0, 2^n - 1], The first integer is 0, An integer appears no more than once in the sequence, The binary representation of every pair of adjacent integers differs by exactly one bit, and The binary representation of the first and last integers differs by exactly one bit. Given an integer n, return any valid n-bit gray code sequence.\nExample 1 Input: n = 2 Output: [0,1,3,2] Explanation: The binary representation of [0,1,3,2] is [00,01,11,10]. - 00 and 01 differ by one bit - 01 and 11 differ by one bit - 11 and 10 differ by one bit - 10 and 00 differ by one bit [0,2,3,1] is also a valid gray code sequence, whose binary representation is [00,10,11,01]. - 00 and 10 differ by one bit - 10 and 11 differ by one bit - 11 and 01 differ by one bit - 01 and 00 differ by one bit Example 2 Input: n = 1 Output: [0,1] Constraints - `1 \u0026lt;= n \u0026lt;= 16` Solution class Solution { public: vector\u0026lt;int\u0026gt; grayCode(int n) { int size = 1\u0026lt;\u0026lt;n; vector\u0026lt;int\u0026gt;ans(size); for(int i = 0;i\u0026lt;size;i++) ans[i]=(i^(i\u0026gt;\u0026gt;1)); return ans; } }; Complexity Analysis | Algorithm | Time Complexity | Space Complexity | | ---------------- | --------------- | ---------------- | | Bit manipulation | O(2^N) | O(2^N) | Explanation 1. Intuition - We need to generate a gray code sequence of size 2^n. - Since each number needs to be unique by one bit, we can use the XOR operator to generate the sequence. - Given a number i, the gray code sequence is i^(i\u0026gt;\u0026gt;1). - This is because the XOR operator will flip the bits that are different between the two numbers. - hence we will take a number `i` and XOR it with `i\u0026gt;\u0026gt;1` to get the gray code sequence. - This will generate a number that differs by one bit. 2. Implementation - Initialize a vector of size 2^n. - Iterate from `0` to `2^n -1` and calculate the gray code sequence using the formula `i^(i\u0026gt;\u0026gt;1)`. - Return the vector. Example\nn = 3 size = 1\u0026lt;\u0026lt;3 = 8 ans = [0,0,0,0,0,0,0,0] i = 0 ans[0] = 0^(0\u0026gt;\u0026gt;1) = 0^0 = 0 i = 1 ans[1] = 1^(1\u0026gt;\u0026gt;1) = 1^0 = 1 i = 2 ans[2] = 2^(2\u0026gt;\u0026gt;1) = 2^1 = 3 i = 3 ans[3] = 3^(3\u0026gt;\u0026gt;1) = 3^1 = 2 i = 4 ans[4] = 4^(4\u0026gt;\u0026gt;1) = 4^2 = 6 i = 5 ans[5] = 5^(5\u0026gt;\u0026gt;1) = 5^2 = 7 i = 6 ans[6] = 6^(6\u0026gt;\u0026gt;1) = 6^3 = 5 i = 7 ans[7] = 7^(7\u0026gt;\u0026gt;1) = 7^3 = 4 ans = [0,1,3,2,6,7,5,4] ","date":"July 25, 2024","permalink":"/blog/posts/extraques/problem-89-gray-code/","summary":"Problem Statement Link - Problem 89 Question An n-bit gray code sequence is a sequence of 2^n integers where:","title":"Problem 89 Gray Code","type":"posts"},{"content":" Problem Statement Link - Problem 128 Question Given an unsorted array of integers nums, return the length of the longest consecutive elements sequence.\nYou must write an algorithm that runs in O(n) time.\nExample 1 Input: nums = [100,4,200,1,3,2] Output: 4 Explanation: The longest consecutive elements sequence is [1, 2, 3, 4]. Therefore its length is 4. Example 2 Input: nums = [0,3,7,2,5,8,4,6,0,1] Output: 9 Constraints - `0 \u0026lt;= nums.length \u0026lt;= 10^5` - `-10^9 \u0026lt;= nums[i] \u0026lt;= 10^9` Solution class Solution { public: int longestConsecutive(vector\u0026lt;int\u0026gt;\u0026amp; nums) { std::ios::sync_with_stdio(false); unordered_set\u0026lt;int\u0026gt;s(nums.begin(),nums.end()); int ans = 0,len =1; for(int num:nums){ if(s.find(num-1)==s.end()){ len = 1; while(s.find(num+len)!=s.end()){ len++; } ans = max(ans,len); } } return ans; } }; Complexity Analysis | Algorithm | Time Complexity | Space Complexity | | --------- | --------------- | ---------------- | | Hash set | O(N) | O(N) | Explanation 1. Intuition - We can add all the elements of the array to a hash set. - Then we can say that if the previous element of the current element is not present in the hash set, then we can start counting the length of the sequence. - Only elements whose previous element is not present in the hash set can be the starting element of the sequence. - Using this approach, we can find how many consecutive elements are present in the sequence which starts from the current element. - We can keep track of the maximum length of the sequence and return it. 2. Implementation - Initialize `s` a hash set to store all the elements of the array. - Initialize `ans` to 0 and `len` to 1 to store the maximum length of the sequence and the length of the current sequence. - Iterate through the array and do the following - If the previous element of the current element is not present in the hash set, then - Set `len` to 1 - While the next element of the current element is present in the hash set, increment `len` - Set `ans` to the maximum of `ans` and `len` - Return `ans` This solution was found by a random youtube short by neetcode. So huge shoutout to him !\n","date":"July 25, 2024","permalink":"/blog/posts/extraques/problem-128-longest-consecutive-sequence/","summary":"Problem Statement Link - Problem 128 Question Given an unsorted array of integers nums, return the length of the longest consecutive elements sequence.","title":"Problem 128 Longest Consecutive Sequence","type":"posts"},{"content":" Problem Statement Link - Problem 832 Question Given an n x n binary matrix image, flip the image horizontally, then invert it, and return the resulting image.\nTo flip an image horizontally means that each row of the image is reversed.\nFor example, flipping [1,1,0] horizontally results in [0,1,1]. To invert an image means that each 0 is replaced by 1, and each 1 is replaced by 0.\nFor example, inverting [0,1,1] results in [1,0,0].\nExample 1 Input: image = [[1,1,0],[1,0,1],[0,0,0]] Output: [[1,0,0],[0,1,0],[1,1,1]] Explanation: First reverse each row: [[0,1,1],[1,0,1],[0,0,0]]. Then, invert the image: [[1,0,0],[0,1,0],[1,1,1]] Example 2 Input: image = [[1,1,0,0],[1,0,0,1],[0,1,1,1],[1,0,1,0]] Output: [[1,1,0,0],[0,1,1,0],[0,0,0,1],[1,0,1,0]] Explanation: First reverse each row: [[0,0,1,1],[1,0,0,1],[1,1,1,0],[0,1,0,1]]. Then invert the image: [[1,1,0,0],[0,1,1,0],[0,0,0,1],[1,0,1,0]] Constraints - `n == image.length` - `n == image[i].length` - `1 \u0026lt;= n \u0026lt;= 20` - `images[i][j] is either 0 or 1`. Solution class Solution { public: vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; flipAndInvertImage(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; matrix) { int rows = matrix.size(); int cols = matrix[0].size(); vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;v(rows,vector\u0026lt;int\u0026gt;(cols)); for(int i = 0; i\u0026lt;rows; i++){ for(int j = 0; j\u0026lt;cols; j++){ if(matrix[i][j]==1) v[i][cols-1-j] = 0; else v[i][cols-1-j] = 1; } } return v; } }; Complexity Analysis | Algorithm | Time Complexity | Space Complexity | | ---------------- | --------------- | ---------------- | | Matrix Traversal | O(N^2) | O(N^2) | Explanation 1. Intuition - Just simulate what the question is asking. - First reverse the each row and then invert the elements. - But here we are creating a new matrix to store the result. 2. Implementation - Initialize `rows` and `cols` to store the number of rows and columns. - Create a new matrix `v` to store the result. - Traverse through the matrix and do the following - If the element is 1 then set the element at `i`th row and `cols-1-j`th column to 0 - Else set the element at `i`th row and `cols-1-j`th column to 1 - Return the result matrix. ","date":"July 25, 2024","permalink":"/blog/posts/extraques/problem-832-flipping-an-image/","summary":"Problem Statement Link - Problem 832 Question Given an n x n binary matrix image, flip the image horizontally, then invert it, and return the resulting image.","title":"Problem 832 Flipping an Image","type":"posts"},{"content":" Problem Statement Link - Problem 24 Question Given a linked list, swap every two adjacent nodes and return its head. You must solve the problem without modifying the values in the list\u0026rsquo;s nodes (i.e., only nodes themselves may be changed.)\nExample 1 Input: head = [1,2,3,4] Output: [2,1,4,3] Example 2 Input: head = [] Output: [] Example 3 Input: head = [1] Output: [1] Constraints - The number of nodes in the list is in the range `[0, 100]`. - `0 \u0026lt;= Node.val \u0026lt;= 100` Solution /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ class Solution { public: ListNode* swapPairs(ListNode* head) { if(head == nullptr || head-\u0026gt;next == nullptr) return head; ListNode* dummy = new ListNode(0,head); ListNode* prev = dummy; ListNode* curr = head; while(curr!=nullptr \u0026amp;\u0026amp; curr-\u0026gt;next!=nullptr){ prev-\u0026gt;next = curr-\u0026gt;next; curr-\u0026gt;next = prev-\u0026gt;next-\u0026gt;next; prev-\u0026gt;next-\u0026gt;next = curr; prev = curr; curr = curr-\u0026gt;next; } return dummy-\u0026gt;next; } }; Complexity Analysis | Algorithm | Time Complexity | Space Complexity | | ----------- | --------------- | ---------------- | | Two Pointer | O(N) | O(1) | Explanation 1. Intuition - We can add a dummy node at the start of the linked list. - Then iterate through the Linked list and do the following - Set next of prev to next of curr - Set next of curr to next of next of previous - Set next of next of next of prev to curr - move curr to next of curr - This will set the next of `ith` node to `i+2th` node and next of `i+1th` node to `i+3rd` node - Then set the next of `i+2th` node to `i+1th` node - move curr to next of curr 2. Implementation - Create a dummy node and set its next to head - Create two pointers prev and curr and set them to dummy and head respectively - Iterate through the linked list until curr and curr-\u0026gt;next are not null - Set next of prev to next of curr - Set next of curr to next of next of previous - Set next of next of next of prev to curr - move curr to next of curr - return dummy-\u0026gt;next ","date":"July 25, 2024","permalink":"/blog/posts/extraques/problem-24-swap-nodes-in-pairs/","summary":"Problem Statement Link - Problem 24 Question Given a linked list, swap every two adjacent nodes and return its head.","title":"Problem 24 Swap Nodes in Pairs","type":"posts"},{"content":" Problem Statement Link - Problem 912 Question TLDR: Given an integer array nums, sort it in ascending order. using merge sort.\nExample 1 Input: nums = [5,2,3,1] Output: [1,2,3,5] Explanation: After sorting the array, the positions of some numbers are not changed (for example, 2 and 3), while the positions of other numbers are changed (for example, 1 and 5). Example 2 Input: nums = [5,1,1,2,0,0] Output: [0,0,1,1,2,5] Explanation: Note that the values of nums are not necessairly unique. Constraints - `1 \u0026lt;= nums.length \u0026lt;= 5 * 10^4` - `-5 * 10^4 \u0026lt;= nums[i] \u0026lt;= 5 * 10^4` Solution class Solution { public: void merge(vector\u0026lt;int\u0026gt;\u0026amp; arr, int left, int mid, int right){ int n1 = mid - left + 1; int n2 = right - mid; vector\u0026lt;int\u0026gt; L(n1), R(n2); for(int i = 0; i \u0026lt; n1; i++){ L[i] = arr[left + i]; } for(int i = 0; i \u0026lt; n2; i++){ R[i] = arr[mid + 1 + i]; } int i = 0, j = 0, k = left; while(i \u0026lt; n1 \u0026amp;\u0026amp; j \u0026lt; n2){ if(L[i] \u0026lt;= R[j]){ arr[k] = L[i]; i++; } else { arr[k] = R[j]; j++; } k++; } while(i \u0026lt; n1){ arr[k] = L[i]; i++; k++; } while(j \u0026lt; n2){ arr[k] = R[j]; j++; k++; } } void mergeSort(vector\u0026lt;int\u0026gt;\u0026amp; arr, int left, int right){ if(left \u0026lt; right){ int mid = left + (right - left) / 2; mergeSort(arr, left, mid); mergeSort(arr, mid + 1, right); merge(arr, left, mid, right); } } vector\u0026lt;int\u0026gt; sortArray(vector\u0026lt;int\u0026gt;\u0026amp; nums) { std::ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); mergeSort(nums,0,nums.size()-1); return nums; } }; Complexity Analysis | Algorithm | Time Complexity | Space Complexity | | --------- | --------------- | ---------------- | | Mergesort | O(NlogN) | O(N) | Explanation 1. Intuition - Break the array into two halves - Sort the two halves - Merge the two halves 2. Implementation - Create a merge function that merges two sorted arrays - Create a mergeSort function that breaks the array into two halves and sorts them - Call the mergeSort function - Return the sorted array Nothing fancy here, just a simple merge sort implementation.\n","date":"July 25, 2024","permalink":"/blog/leetcode-potd/problem-912-sort-an-array/","summary":"Problem Statement Link - Problem 912 Question TLDR: Given an integer array nums, sort it in ascending order.","title":"Problem 912 Sort an Array","type":"leetcode-potd"},{"content":" Problem Statement Link - Problem 2191 Question You are given a 0-indexed integer array mapping which represents the mapping rule of a shuffled decimal system. mapping[i] = j means digit i should be mapped to digit j in this system.\nThe mapped value of an integer is the new integer obtained by replacing each occurrence of digit i in the integer with mapping[i] for all 0 \u0026lt;= i \u0026lt;= 9.\nYou are also given another integer array nums. Return the array nums sorted in non-decreasing order based on the mapped values of its elements.\nNotes:\nElements with the same mapped values should appear in the same relative order as in the input. The elements of nums should only be sorted based on their mapped values and not be replaced by them. Example 1 Input: mapping = [8,9,4,0,2,1,3,5,7,6], nums = [991,338,38] Output: [338,38,991] Explanation: Map the number 991 as follows: 1. mapping[9] = 6, so all occurrences of the digit 9 will become 6. 2. mapping[1] = 9, so all occurrences of the digit 1 will become 9. Therefore, the mapped value of 991 is 669. 338 maps to 007, or 7 after removing the leading zeros. 38 maps to 07, which is also 7 after removing leading zeros. Since 338 and 38 share the same mapped value, they should remain in the same relative order, so 338 comes before 38. Thus, the sorted array is [338,38,991]. Example 2 Input: mapping = [0,1,2,3,4,5,6,7,8,9], nums = [789,456,123] Output: [123,456,789] Explanation: 789 maps to 789, 456 maps to 456, and 123 maps to 123. Thus, the sorted array is [123,456,789]. Constraints - `mapping.length == 10` - `0 \u0026lt;= mapping[i] \u0026lt;= 9` - `All the values of mapping[i] are unique.` - `1 \u0026lt;= nums.length \u0026lt;= 3 * 10^4` - `0 \u0026lt;= nums[i] \u0026lt; 10^9` Solution class Solution { public: int convert(int temp,vector\u0026lt;int\u0026gt;\u0026amp; mapping){ int change = 0; int ind = 1; while(temp\u0026gt;=0){ change = mapping[temp%10]*ind + change; ind*=10; temp/=10; if(temp == 0) break; } return change; } vector\u0026lt;int\u0026gt; sortJumbled(vector\u0026lt;int\u0026gt;\u0026amp; mapping, vector\u0026lt;int\u0026gt;\u0026amp; nums) { std::ios::sync_with_stdio(false); unordered_map\u0026lt;int,int\u0026gt;rev; for(int i = 0; i\u0026lt;nums.size(); i++){ rev[nums[i]] = i; } auto cmp = [\u0026amp;rev](const pair\u0026lt;int,int\u0026gt;\u0026amp;a, const pair\u0026lt;int,int\u0026gt;\u0026amp;b){ if(a.first == b.first) return rev[a.second]\u0026gt;rev[b.second]; return a.first\u0026gt;b.first; }; priority_queue\u0026lt;pair\u0026lt;int,int\u0026gt;,vector\u0026lt;pair\u0026lt;int,int\u0026gt;\u0026gt;,decltype(cmp)\u0026gt;pq(cmp); int change; for(int i=0; i\u0026lt;nums.size(); i++){ change = convert(nums[i],mapping); pq.push({change,nums[i]}); } int i = 0; while(!pq.empty()){ nums[i++] = pq.top().second; pq.pop(); } return nums; } }; Complexity Analysis | Algorithm | Time Complexity | Space Complexity | | -------------- | --------------- | ---------------- | | Priority Queue | O(NlogN) | O(N) | Explanation 1. Intuition - The idea is as follows - Convert a number to its mapped value - Sort according to the mapped value - If the mapped values are the same, then choose order according to original index. - Return the sorted array of **Original Values** - So we caan store the original index in a hashmap and use a priority queue to sort the mapped values. - We can use a custom comparator to sort the priority queue. - Finally, rebuild the array with the original values. - Return the sorted array. 2. Implementation - Create a function `convert` to convert the number to its mapped value. - Input: a number `temp` to convert and a vector `mapping` to map the digits. - Output: the mapped value of the number. - `change` is the mapped value of the number. - `ind` is the multiplier to get the correct position of the digit. - While the number is greater than 0 - Get the digit at the end of the number. - Multiply the digit with the mapped value and add it to the `change`. - Multiply the `ind` by 10 to get the correct position of the digit. - Divide the number by 10 to get the next digit. - If the number is 0, break the loop. - Return the `change` - Create a hashmap `rev` to store the original index of the number. - Iterate over the numbers and store the original index in the hashmap. - Create a custom comparator `cmp` to sort the priority queue. - If the mapped values are the same, then choose the order according to the original index. - Create a priority queue `pq` with the custom comparator `cmp`. - Iterate over the numbers and convert the number to its mapped value. - Push the mapped value and the original number to the priority queue. - While the priority queue is not empty - Get the top element of the priority queue. - Pop the top element of the priority queue. - Store the original number in the sorted array. - Return the sorted array. Alternate method We can implement the same logic with vectors.\nclass Solution { public: int convert(int temp,vector\u0026lt;int\u0026gt;\u0026amp; mapping){ if(temp == 0) return mapping[0]; int change = 0; int ind = 1; while(temp\u0026gt;0){ change = mapping[temp%10]*ind + change; ind*=10; temp/=10; } return change; } vector\u0026lt;int\u0026gt; sortJumbled(vector\u0026lt;int\u0026gt;\u0026amp; mapping, vector\u0026lt;int\u0026gt;\u0026amp; nums) { int n = nums.size(); vector\u0026lt;array\u0026lt;int,3\u0026gt;\u0026gt;triple(n); // using arrays for faster access; for(int i = 0; i\u0026lt;n; i++){ int num = nums[i]; triple[i] = {convert(num,mapping),i,num}; } sort(triple.begin(),triple.end()); for(int i = 0; i\u0026lt;n; i++){ nums[i] = triple[i][2]; } return nums; } }; We can make it a little optimised by just storing the mapped value and index of original value in the vector. then we have to create a new array of the original values and return it.\nclass Solution { public: int convert(int temp,vector\u0026lt;int\u0026gt;\u0026amp; mapping){ if(temp == 0) return mapping[0]; int change = 0; int ind = 1; while(temp\u0026gt;0){ change = mapping[temp%10]*ind + change; ind*=10; temp/=10; } return change; } vector\u0026lt;int\u0026gt; sortJumbled(vector\u0026lt;int\u0026gt;\u0026amp; mapping, vector\u0026lt;int\u0026gt;\u0026amp; nums) { int n = nums.size(); std::ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); vector\u0026lt;array\u0026lt;int,2\u0026gt;\u0026gt;dbl(n); // using arrays for faster access; for(int i = 0; i\u0026lt;n; i++){ int num = nums[i]; dbl[i] = {convert(num,mapping),i}; } sort(dbl.begin(),dbl.end()); vector\u0026lt;int\u0026gt;ans(n); for(int i = 0; i\u0026lt;n; i++){ ans[i] = nums[dbl[i][1]]; } return ans; } }; ","date":"July 24, 2024","permalink":"/blog/leetcode-potd/problem-2191-sort-the-jumbled-number/","summary":"Problem Statement Link - Problem 2191 Question You are given a 0-indexed integer array mapping which represents the mapping rule of a shuffled decimal system.","title":"Problem 2191 Sort the Jumbled Number","type":"leetcode-potd"},{"content":" Problem Statement Link - Problem 1636 Question Given an array of integers nums, sort the array in increasing order based on the frequency of the values. If multiple values have the same frequency, sort them in decreasing order.\nReturn the sorted array.\nExample 1 Input: nums = [1,1,2,2,2,3] Output: [3,1,1,2,2,2] Explanation: \u0026#39;3\u0026#39; has a frequency of 1, \u0026#39;1\u0026#39; has a frequency of 2, and \u0026#39;2\u0026#39; has a frequency of 3. Example 2 Input: nums = [2,3,1,3,2] Output: [1,3,3,2,2] Explanation: \u0026#39;2\u0026#39; and \u0026#39;3\u0026#39; both have a frequency of 2, so they are sorted in decreasing order. Example 3 Input: nums = [-1,1,-6,4,5,-6,1,4,1] Output: [5,-1,4,4,-6,-6,1,1,1] Constraints - `1 \u0026lt;= nums.length \u0026lt;= 100` - `-100 \u0026lt;= nums[i] \u0026lt;= 100` Solution class Solution { public: vector\u0026lt;int\u0026gt; frequencySort(vector\u0026lt;int\u0026gt;\u0026amp; nums) { unordered_map\u0026lt;int,int\u0026gt;mp; for(int num:nums){ mp[num]++; } auto cmp = [](const pair\u0026lt;int, int\u0026gt;\u0026amp; a, const pair\u0026lt;int, int\u0026gt;\u0026amp; b) { if (a.first == b.first) { return a.second \u0026lt; b.second; } return a.first \u0026gt; b.first; }; priority_queue\u0026lt;pair\u0026lt;int,int\u0026gt;,vector\u0026lt;pair\u0026lt;int,int\u0026gt;\u0026gt;,decltype(cmp)\u0026gt;pq; for(auto it:mp){ pq.push({it.second,it.first}); } int ind = 0; pair\u0026lt;int,int\u0026gt;temp; while(!pq.empty()){ temp =pq.top(); pq.pop(); while(temp.first\u0026gt;0){ nums[ind++]=temp.second; temp.first--; } } return nums; } }; Complexity Analysis | Algorithm | Time Complexity | Space Complexity | | ---------------------------- | --------------- | ---------------- | | Sorting using Priority Queue | O(NlogN) | O(N) | Explanation 1. Intuition - From the question we need to sort the array based on the frequency of the values. - but if frequency is same then we need to sort them in decreasing order. - Hence we need a mapping from value to frequency. - We can use a hashmap to store the frequency of each value. - Then we can use a priority queue to sort the values based on the frequency. - Since we need a min heap we need to have a custom comparator. 2. Implementation - Initialize an unordered map `mp` to store the frequency of each value. - Iterate over the array and store the frequency of each value. - Initialize a custom comparator `cmp` to sort the values based on frequency. - `cmp` will accept two value-frequency pairs - If the frequency of both values is same then return true if the value1 is less than value2. - Else return true if the frequency of value1 is greater than value2. - Initialize a priority queue `pq` with the custom comparator `cmp`. - Iterate over the map and push the value-frequency pair into the priority queue. - Initialize an index `ind` to store the index of the sorted array. - Initialize a temporary pair `temp` to store the value-frequency pair. - Iterate over the priority queue until it is empty. - Pop the top element from the priority queue and store it in `temp`. - Iterate over the frequency of the value and store the value in the sorted array. - Return the sorted array. ","date":"July 23, 2024","permalink":"/blog/leetcode-potd/problem-1636-sort-array-by-increasing-frequency/","summary":"Problem Statement Link - Problem 1636 Question Given an array of integers nums, sort the array in increasing order based on the frequency of the values.","title":"Problem 1636 Sort Array by Increasing Frequency","type":"leetcode-potd"},{"content":" Problem Statement Link - Problem 2418 Question You are given an array of strings names, and an array heights that consists of distinct positive integers. Both arrays are of length n.\nFor each index i, names[i] and heights[i] denote the name and height of the ith person.\nReturn names sorted in descending order by the people\u0026rsquo;s heights.\nExample 1 Input: names = [\u0026#34;Mary\u0026#34;,\u0026#34;John\u0026#34;,\u0026#34;Emma\u0026#34;], heights = [180,165,170] Output: [\u0026#34;Mary\u0026#34;,\u0026#34;Emma\u0026#34;,\u0026#34;John\u0026#34;] Explanation: Mary is the tallest, followed by Emma and John. Example 2 Input: names = [\u0026#34;Alice\u0026#34;,\u0026#34;Bob\u0026#34;,\u0026#34;Bob\u0026#34;], heights = [155,185,150] Output: [\u0026#34;Bob\u0026#34;,\u0026#34;Alice\u0026#34;,\u0026#34;Bob\u0026#34;] Explanation: The first Bob is the tallest, followed by Alice and the second Bob. Constraints - `n == names.length == heights.length` - `1 \u0026lt;= n \u0026lt;= 10^3` - `1 \u0026lt;= names[i].length \u0026lt;= 20` - `1 \u0026lt;= heights[i] \u0026lt;= 10^5` - `names[i] consists of lower and upper case English letters.` - `All the values of heights are distinct`. Solution class Solution { public: vector\u0026lt;string\u0026gt; sortPeople(vector\u0026lt;string\u0026gt;\u0026amp; names, vector\u0026lt;int\u0026gt;\u0026amp; heights) { priority_queue\u0026lt;pair\u0026lt;int,string\u0026gt;,vector\u0026lt;pair\u0026lt;int,string\u0026gt;\u0026gt;\u0026gt;pq; for(int i=0;i\u0026lt;names.size();i++){ pq.push(make_pair(heights[i],names[i])); } vector\u0026lt;string\u0026gt;ans; while(!pq.empty()){ ans.push_back(pq.top().second); pq.pop(); } return ans; } }; Complexity Analysis | Algorithm | Time Complexity | Space Complexity | | --------- | --------------- | ---------------- | | Heap | O(nlogn) | O(n) | Explanation 1. Intuition - We need to sort the pairs of heights and names in descending order. - Then append the names to the answer vector. - We can use pair and priority queue to solve this problem. 2. Implementation - Initialize a priority queue of pairs of integers and strings named `pq`. - Iterate over the names array and push the pair of heights and names to the priority queue. - Initialize an empty vector of strings named `ans`. - Iterate over the priority queue and append the names to the answer vector. - Return the answer vector. ","date":"July 22, 2024","permalink":"/blog/leetcode-potd/problem-2418-sort-the-people/","summary":"Problem Statement Link - Problem 2418 Question You are given an array of strings names, and an array heights that consists of distinct positive integers.","title":"Problem 2418 Sort the People","type":"leetcode-potd"},{"content":" Problem Statement Link - Problem 1605 Question You are given two arrays rowSum and colSum of non-negative integers where rowSum[i] is the sum of the elements in the ith row and colSum[j] is the sum of the elements of the jth column of a 2D matrix. In other words, you do not know the elements of the matrix, but you do know the sums of each row and column.\nFind any matrix of non-negative integers of size rowSum.length x colSum.length that satisfies the rowSum and colSum requirements.\nReturn a 2D array representing any matrix that fulfills the requirements. It\u0026rsquo;s guaranteed that at least one matrix that fulfills the requirements exists.\nExample 1 Input: rowSum = [3,8], colSum = [4,7] Output: [[3,0], [1,7]] Explanation: 0th row: 3 + 0 = 3 == rowSum[0] 1st row: 1 + 7 = 8 == rowSum[1] 0th column: 3 + 1 = 4 == colSum[0] 1st column: 0 + 7 = 7 == colSum[1] The row and column sums match, and all matrix elements are non-negative. Another possible matrix is: [[1,2], [3,5]] Example 2 Input: rowSum = [5,7,10], colSum = [8,6,8] Output: [[0,5,0], [6,1,0], [2,0,8]] Constraints - `1 \u0026lt;= rowSum.length, colSum.length \u0026lt;= 500` - `0 \u0026lt;= rowSum[i], colSum[i] \u0026lt;= 10^8` - `sum(rowSum) == sum(colSum)` Solution class Solution { public: vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; restoreMatrix(vector\u0026lt;int\u0026gt;\u0026amp; rowSum, vector\u0026lt;int\u0026gt;\u0026amp; colSum) { int rows = rowSum.size(), cols = colSum.size(); vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;res(rows,vector\u0026lt;int\u0026gt;(cols,0)); for(int i = 0; i\u0026lt;rows; i++){ for(int j = 0; j\u0026lt;cols; j++){ res[i][j] = min(rowSum[i],colSum[j]); rowSum[i]-=res[i][j]; colSum[j]-=res[i][j]; } } return res; } }; Complexity Analysis | Algorithm | Time Complexity | Space Complexity | | ---------------- | --------------- | ---------------- | | Matrix Traversal | O(mn) | O(mn) | Explanation 1. Intuition - Seeing the problem statement it might seem its very hard. - We can use greedy method to solve this question. - Greedy works because of the following mathematical fact \u0026gt; If given a m variable system of equations and n constraints, if m\u0026gt;n, then the system is underdetermined and has infinite solutions. - We can use this fact to solve the problem. - If we can fix the value of one cell, we can derive the values of other cells. - First set the value of the cell to be the minimum of the rowSum and colSum. - Then subtract the value from the rowSum and colSum. - Continue this process until all the cells are filled. 2. Implementation - Initialize a result matrix `res` of size `rows x cols` with all values as 0. - Traverse the matrix and set the value of the cell to be the minimum of the rowSum and colSum. - Subtract the value from the rowSum and colSum. - Continue this process until all the cells are filled. ","date":"July 21, 2024","permalink":"/blog/leetcode-potd/problem-1605-find-valid-matrix-given-row-and-column-sums/","summary":"Problem Statement Link - Problem 1605 Question You are given two arrays rowSum and colSum of non-negative integers where rowSum[i] is the sum of the elements in the ith row and colSum[j] is the sum of the elements of the jth column of a 2D matrix.","title":"Problem 1605 Find Valid Matrix Given Row and Column Sums","type":"leetcode-potd"},{"content":" Problem Statement Link - Problem 1380 Question Given an m x n matrix of distinct numbers, return all lucky numbers in the matrix in any order.\nA lucky number is an element of the matrix such that it is the minimum element in its row and maximum in its column.\nExample 1 Input: matrix = [[3,7,8],[9,11,13],[15,16,17]] Output: [15] Explanation: 15 is the only lucky number since it is the minimum in its row and the maximum in its column. Example 2 Input: matrix = [[1,10,4,2],[9,3,8,7],[15,16,17,12]] Output: [12] Explanation: 12 is the only lucky number since it is the minimum in its row and the maximum in its column. Example 3 Input: matrix = [[7,8],[1,2]] Output: [7] Explanation: 7 is the only lucky number since it is the minimum in its row and the maximum in its column. Constraints - `m == mat.length` - `n == mat[i].length` - `1 \u0026lt;= n, m \u0026lt;= 50` - `1 \u0026lt;= matrix[i][j] \u0026lt;= 10^5.` - All elements in the matrix are distinct. Solution class Solution { public: vector\u0026lt;int\u0026gt; luckyNumbers (vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; matrix) { vector\u0026lt;int\u0026gt;rowMin(matrix.size(),INT_MAX); vector\u0026lt;int\u0026gt;colMax(matrix[0].size(),INT_MIN); int rows = matrix.size(); int cols = matrix[0].size(); for(int i = 0; i\u0026lt;rows; i++){ for(int j = 0; j\u0026lt;cols ; j++){ rowMin[i] = min(rowMin[i], matrix[i][j]); colMax[j] = max(colMax[j],matrix[i][j]); } } /*for(auto it:rowMin) cout\u0026lt;\u0026lt;it\u0026lt;\u0026lt;\u0026#34; \u0026#34;; cout\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;\u0026lt;\u0026lt;endl; for(auto it:colMax) cout\u0026lt;\u0026lt;it\u0026lt;\u0026lt;\u0026#34; \u0026#34;;*/ vector\u0026lt;int\u0026gt;ans; for(int i = 0; i\u0026lt;rows; i++){ for(int j=0; j\u0026lt;cols; j++){ if(matrix[i][j] == rowMin[i] \u0026amp;\u0026amp; matrix[i][j]==colMax[j]){ ans.push_back(matrix[i][j]); } } } return ans; } }; Complexity Analysis | Algorithm | Time Complexity | Space Complexity | | ---------------- | --------------- | ---------------- | | Matrix Traversal | O(N^2) | O(N) | Explanation 1. Intuition - We can store the row minimums and column maximums in two separate arrays. - Then we can check the each element of the matrix with the row minimum and column maximum of that row and column. - If the element is equal to both the row minimum and column maximum, then it is a lucky number. - We can store all the lucky numbers in a vector and return it. 2. Implementation - Initialize two vectors `rowMin` and `colMax` with INT_MAX and INT_MIN respectively. - Traverse the matrix and update the `rowMin` and `colMax` vectors. - Traverse the matrix again and check if the element is equal to the row minimum and column maximum. - If it is, then push the element into the answer vector. - Return the answer vector. Alternate Approach There is a more optimized approach to solve this problem. We can develop a Constant Space Complexity solution. But before that we need to prove that there is only one lucky number in the matrix.\nProof by Contradiction - Suppose we have an integer `X` which is the minimum in row `r1` and maximum in column `c1`. - Lets say there is another integer `Y` which is the minimum in row `r2` and maximum in column `c2`. Hence we can conclude that there can be only one lucky number in the matrix. - We can take advantage of the above fact as follows - The lucky number will always be the maximum of the minimums of Row and the minimum of the maximums of Column. - This is because every element is **unique** **Algorithm**: 1. iterate over each row and find the minimum element in that row. 2. then find the maximum of all the minimums. 3. iterate over each column and find the maximum element in that column. 4. then find the minimum of all the maximums. 5. if the maximum of minimums is equal to the minimum of maximums, then that element is the lucky number. 6. return the vector. Code class Solution { public: vector\u0026lt;int\u0026gt; luckyNumbers (vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; matrix) { int N = matrix.size(), M = matrix[0].size(); int rMinMax = INT_MIN; for (int i = 0; i \u0026lt; N; i++) { int rMin = INT_MAX; for (int j = 0; j \u0026lt; M; j++) { rMin = min(rMin, matrix[i][j]); } rMinMax = max(rMinMax, rMin); } int cMaxMin = INT_MAX; for (int i = 0; i \u0026lt; M; i++) { int cMax = INT_MIN; for (int j = 0; j \u0026lt; N; j++) { cMax = max(cMax, matrix[j][i]); } cMaxMin = min(cMaxMin, cMax); } if (rMinMax == cMaxMin) { return {rMinMax}; } return {}; } }; ","date":"July 19, 2024","permalink":"/blog/posts/previous-solutions/problem-lucky-number-in-a-matrix/","summary":"Problem Statement Link - Problem 1380 Question Given an m x n matrix of distinct numbers, return all lucky numbers in the matrix in any order.","title":"Problem 1380 Lucky Number in a Matrix","type":"posts"},{"content":" Problem Statement Link - Problem 1530 Question You are given the root of a binary tree and an integer distance. A pair of two different leaf nodes of a binary tree is said to be good if the length of the shortest path between them is less than or equal to distance.\nReturn the number of good leaf node pairs in the tree.\nExample 1 Input: root = [1,2,3,null,4], distance = 3 Output: 1 Explanation: The leaf nodes of the tree are 3 and 4 and the length of the shortest path between them is 3. This is the only good pair. Example 2 Input: root = [1,2,3,4,5,6,7], distance = 3 Output: 2 Explanation: The good pairs are [4,5] and [6,7] with shortest path = 2. The pair [4,6] is not good because the length of ther shortest path between them is 4. Example 3 Input: root = [7,1,4,6,null,5,3,null,null,null,null,null,2], distance = 3 Output: 1 Explanation: The only good pair is [2,5]. Constraints - The number of nodes in the tree is in the range `[1, 2^10]`. - `1 \u0026lt;= Node.val \u0026lt;= 100` - `1 \u0026lt;= distance \u0026lt;= 10` Solution /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: vector\u0026lt;int\u0026gt;countPair(TreeNode* root, int\u0026amp; dist, int\u0026amp; count){ if(!root) return {0}; if(root-\u0026gt;left == nullptr \u0026amp;\u0026amp; root-\u0026gt;right == nullptr) return {1}; vector\u0026lt;int\u0026gt; left = countPair(root-\u0026gt;left,dist,count); vector\u0026lt;int\u0026gt; right = countPair(root-\u0026gt;right,dist,count); for(int i:left){ for(int j:right){ if(i\u0026gt;0 \u0026amp;\u0026amp; j\u0026gt;0 \u0026amp;\u0026amp; i+j\u0026lt;=dist){ count++; } } } vector\u0026lt;int\u0026gt;ans; for(int i:left) if(i\u0026gt;0 \u0026amp;\u0026amp; i\u0026lt;dist) ans.push_back(i+1); for(int j:right) if(j\u0026gt;0 \u0026amp;\u0026amp; j\u0026lt;dist) ans.push_back(j+1); return ans; } int countPairs(TreeNode* root, int distance) { int count = 0; countPair(root,distance,count); return count; } }; Complexity Analysis | Algorithm | Time Complexity | Space Complexity | | --------- | --------------- | ---------------- | | DFS | O(n^2) | O(n) | Explanation 1. Intuition - We can count a good pair by checking the distance between the leaf nodes. - We need to build up the distance calculations from the leaf nodes to the root. - We can use a recursive approach to solve this problem. - If we can track the distances from leaf nodes to the current node, we can find out the combinations that match in that subtree - Return 1 if the node is a leaf node. - Return 0 if the node is null. - Keep track of the distances of the leaf nodes from left subtree of current node, and right subtree of the current node. - Now we can find out the good pairs by checking the distances of the leaf nodes in the left subtree and right subtree of the current node. - If the sum of the distances of the leaf nodes in the left subtree and right subtree is less than or equal to the distance, then we can increment the count. - We can return the distances of the leaf nodes from the current node to the parent node. 2. Implementation - Define a helper function `countPair` which takes the root node, distance and count as arguments. - If the root is null, return a vector with 0. - If the root is a leaf node, return a vector with 1. - Recursively call the function on the left and right child of the current node. - Store the distances of the leaf nodes of left subtree in the vector `left`. - Store the distances of the leaf nodes of right subtree in the vector `right`. - For each distance in the `left` vector, - For each distance in the `right` vector, - If the sum of the distances is less than or equal to the distance, increment the count. - Declare a vector `ans` to store the distances of the leaf nodes from the current node to the parent node. - For each distance in the `left` vector, - If the distance is greater than 0 and less than the distance, add the distance + 1 to the `ans` vector. - For each distance in the `right` vector, - If the distance is greater than 0 and less than the distance, add the distance + 1 to the `ans` vector. - This adding `1` basically says that there is a node between the leaf node and the parent node. - Return the `ans` vector. This is a good problem to understand the concept of DFS and how we can use it to solve problems related to binary trees.\n","date":"July 18, 2024","permalink":"/blog/posts/previous-solutions/problem-number-of-good-leaf-nodes-pairs/","summary":"Problem Statement Link - Problem 1530 Question You are given the root of a binary tree and an integer distance.","title":"Problem 1530 Number of Good Leaf Nodes Pairs","type":"posts"},{"content":" Problem Statement Link - Problem 1110 Question Given the root of a binary tree, each node in the tree has a distinct value.\nAfter deleting all nodes with a value in to_delete, we are left with a forest (a disjoint union of trees).\nReturn the roots of the trees in the remaining forest. You may return the result in any order.\nExample 1 Input: root = [1,2,3,4,5,6,7], to_delete = [3,5] Output: [[1,2,null,4],[6],[7]] Example 2 Input: root = [1,2,4,null,3], to_delete = [3] Output: [[1,2,4]] Constraints - The number of nodes in the given tree is at most `1000`. - Each node has a distinct value between `1` and `1000`. - `to_delete.length \u0026lt;= 1000` - `to_delete` contains distinct values between `1` and `1000`. Solution /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: void delNode(TreeNode* \u0026amp;root, vector\u0026lt;bool\u0026gt;\u0026amp; todel, vector\u0026lt;TreeNode*\u0026gt;\u0026amp; result){ if(root != nullptr){ delNode(root-\u0026gt;left,todel,result); delNode(root-\u0026gt;right,todel,result); if(todel[root-\u0026gt;val] == true){ if(root-\u0026gt;left) result.push_back(root-\u0026gt;left); if(root-\u0026gt;right) result.push_back(root-\u0026gt;right); root = nullptr; } } else return; } vector\u0026lt;TreeNode*\u0026gt; delNodes(TreeNode* root, vector\u0026lt;int\u0026gt;\u0026amp; to_delete) { vector\u0026lt;bool\u0026gt;todel(1001,false); for(const auto it:to_delete) todel[it] = true; vector\u0026lt;TreeNode*\u0026gt;res; delNode(root,todel,res); if(root) res.push_back(root); return res; } }; Complexity Analysis | Algorithm | Time Complexity | Space Complexity | | --------- | --------------- | ---------------- | | DFS | O(n) | O(n) | Explanation 1. Intuition - We can recursively traverse the tree and delete the nodes which are present in the `to_delete` vector. - Once we delete the node, we can add the left and right child of the node to the result vector. - But this pruning should be done in a post-order traversal so that we can delete nodes from the leaf nodes back to root. 2. Implementation - Since we know that the values of the nodes are distinct, we can use a vector of size 1001 to store the nodes to delete. - Declare a vector `toDel` of size 1001 and initialize it to false. - For each value in the `to_delete` vector, set the value at that index to true. - Declare a vector of TreeNode `res` to store the result. - Call the `delNode` function with the root, `toDel`, and `res` as arguments. - Helper function `delNode`: - If the root is not null, recursively call the function on the left and right child. - If the value of the root is present in the `toDel` vector, add the left and right child to the result vector and set the root to null. - once the `delNode` function is called, check if the root is not null and add it to the result vector. - Return the result vector. ","date":"July 17, 2024","permalink":"/blog/posts/previous-solutions/problem-delete-nodes-and-return-forest/","summary":"Problem Statement Link - Problem 1110 Question Given the root of a binary tree, each node in the tree has a distinct value.","title":"Problem 1110 Delete Nodes and Return Forest","type":"posts"},{"content":" Problem Statement Link - Problem 2096 Question You are given the root of a binary tree with n nodes. Each node is uniquely assigned a value from 1 to n. You are also given an integer startValue representing the value of the start node s, and a different integer destValue representing the value of the destination node t.\nFind the shortest path starting from node s and ending at node t. Generate step-by-step directions of such path as a string consisting of only the uppercase letters 'L', 'R', and 'U'. Each letter indicates a specific direction:\n'L' means to go from a node to its left child node. 'R' means to go from a node to its right child node. 'U' means to go from a node to its parent node. Return the step-by-step directions of the shortest path from node s to node t.\nExample 1 Input: root = [5,1,2,3,null,6,4], startValue = 3, destValue = 6 Output: \u0026#34;UURL\u0026#34; Explanation: The shortest path is: 3 → 1 → 5 → 2 → 6. Example 2 Input: root = [2,1], startValue = 2, destValue = 1 Output: \u0026#34;L\u0026#34; Explanation: The shortest path is: 2 → 1. Constraints - The number of nodes in the tree is `n`. - `2 \u0026lt;= n \u0026lt;= 10^5` - `1 \u0026lt;= Node.val \u0026lt;= n` - All the values in the tree are `unique`. - `1 \u0026lt;= startValue, destValue \u0026lt;= n` - `startValue != destValue` Solution /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: TreeNode* LCA(TreeNode* root, int\u0026amp; p, int\u0026amp; q){ if(root == nullptr || root-\u0026gt;val == p || root-\u0026gt;val == q) return root; TreeNode* left = LCA(root-\u0026gt;left,p,q); TreeNode* right = LCA(root-\u0026gt;right,p,q); if (left == nullptr) return right; if (right == nullptr) return left; return root; } bool dfs(TreeNode* root, int x, string\u0026amp; path, bool rev) { if (root == NULL) return 0; if (root-\u0026gt;val == x) return 1; path += (rev ? \u0026#39;U\u0026#39; : \u0026#39;L\u0026#39;); if (dfs(root-\u0026gt;left, x, path, rev)) return 1; path.pop_back(); path += (rev ? \u0026#39;U\u0026#39; : \u0026#39;R\u0026#39;); if (dfs(root-\u0026gt;right, x, path, rev)) return 1; path.pop_back(); return 0; } string getDirections(TreeNode* root, int startValue, int destValue) { std::ios::sync_with_stdio(false); root = LCA(root, startValue, destValue); string pathFrom = \u0026#34;\u0026#34;, pathTo = \u0026#34;\u0026#34;; dfs(root,startValue,pathFrom,1); dfs(root,destValue,pathTo,0); return pathFrom + pathTo; } }; Complexity Analysis | Time Complexity | Space Complexity | | --------------- | ---------------- | | O(N) | O(N) | Explanation 1. Intuition - The idea is to find the Lowest Common Ancestor of the two nodes. - This will help us to find the shortest path as the shortest path must pass through the LCA. - Once we find the shortest path, we can find the directions from the start node to the LCA and from the LCA to the destination node. - We need to build these paths as strings and return the concatenated string. - How do we build a path ? - Remember that from source to LCA it will always be `\u0026#39;U\u0026#39;` and `\u0026#39;L\u0026#39;` or `\u0026#39;R\u0026#39;` for LCA to destination. - So we need to keep track of direction which we are finding the path. - Use DFS, if we are going from LCA to Source append `\u0026#39;U\u0026#39;` else append `\u0026#39;L\u0026#39;` or `\u0026#39;R\u0026#39;` appropriately. - We first try to append the direction to `path` and then try to find the path in the left subtree. If not found then we pop the last character from the path and append the direction to the right subtree. If not found then we pop the last character from the path. 2. Implementation - Define a function `LCA` to find the Lowest Common Ancestor of the two nodes. 1. `LCA` - If the `root` is `NULL` or the value of the root is equal to `p` or `q` return the root. - Recursively find the LCA in the left and right subtree. - If the left is `NULL` return right. - If the right is `NULL` return left. - Return the `root`. 2. DFS to find the path, this is a boolean function - If `root` is `NULL` return `0`. It means the path is not found. - If the value of the root is equal to `x` return `1`. - If `root` is not the target nor the leaf node then - Append `\u0026#39;U\u0026#39;` or `\u0026#39;L\u0026#39;` based on the `rev` flag. - Recursively find the path in the left subtree. - If the path is found return `1`. - Pop the last character from the path. - Append `\u0026#39;U\u0026#39;` or `\u0026#39;R\u0026#39;` based on the `rev` flag. - Recursively find the path in the right subtree. - If the path is found return `1`. - Pop the last character from the path. - Return `0`. - In the main function `getDirections` - Find the LCA of the two nodes. - Initialize two strings `pathFrom` and `pathTo`. - Find the path from the source to the LCA and append it to `pathFrom`. - Find the path from the LCA to the destination and append it to `pathTo`. - Return the concatenated string of `pathFrom` and `pathTo`. ","date":"July 16, 2024","permalink":"/blog/posts/previous-solutions/problem-step-by-step-directions-from-a-binary-tree-node-to-another/","summary":"Problem Statement Link - Problem 2096 Question You are given the root of a binary tree with n nodes.","title":"Problem 2096 Step by Step Directions From a Binary Tree Node to Another","type":"posts"},{"content":" Problem Statement Link - Problem 2196 Question You are given a 2D integer array descriptions where descriptions[i] = [parenti, childi, isLefti] indicates that parenti is the parent of childi in a binary tree of unique values. Furthermore,\nIf isLefti == 1, then childi is the left child of parenti. If isLefti == 0, then childi is the right child of parenti. Construct the binary tree described by descriptions and return its root.\nThe test cases will be generated such that the binary tree is valid.\nExample 1 graph TD A((50)) --\u003e B((20)) A --\u003e C((80)) B --\u003e D((15)) B --\u003e E((17)) C --\u003e F((19)) Input: descriptions = [[20,15,1],[20,17,0],[50,20,1],[50,80,0],[80,19,1]] Output: [50,20,80,15,17,19] Explanation: The root node is the node with value 50 since it has no parent. The resulting binary tree is shown in the diagram. Example 2 graph TD A((1)) --\u003e B((2)) B((2)) --\u003e C((3)) C((3)) --\u003e D((4)) Input: descriptions = [[1,2,1],[2,3,0],[3,4,1]] Output: [1,2,null,null,3,4] Explanation: The root node is the node with value 1 since it has no parent. The resulting binary tree is shown in the diagram. Constraints - `1 \u0026lt;= descriptions.length \u0026lt;= 10^4` - `descriptions[i].length == 3` - `1 \u0026lt;= parenti, childi \u0026lt;= 10^5` - ` 0 \u0026lt;= isLefti \u0026lt;= 1` - The binary tree described by `descriptions` is valid. Solution /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: TreeNode* createBinaryTree(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; descriptions) { std::ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); unordered_map\u0026lt;int,TreeNode*\u0026gt; mp; unordered_set\u0026lt;int\u0026gt;isChild; for(auto \u0026amp;it:descriptions){ if(mp.find(it[0]) == mp.end()){ mp[it[0]] = new TreeNode(it[0]); } if(mp.find(it[1])==mp.end()){ mp[it[1]] = new TreeNode(it[1]); } if(it[2]){ mp[it[0]]-\u0026gt;left = mp[it[1]]; } else{ mp[it[0]]-\u0026gt;right = mp[it[1]]; } isChild.insert(it[1]); } TreeNode* root = nullptr; for(auto \u0026amp;it : descriptions){ if(isChild.find(it[0]) == isChild.end()){ root = mp[it[0]]; return root; } } return root; } }; Complexity Analysis Time Complexity : O(N) Space Complexity : O(N) Explanation 1. Intuition - Root node will be the node which has no parent. - So we need to maintain a set of nodes which are child nodes. - First create a map of all nodes and form the tree. - To find the root node, iterate over the set of nodes and find the node which is not a child node. 2. Implementation - Initialize a map `mp` to store the nodes. - Initialize a set `isChild` to store the child nodes. - Traverse the `descriptions` array. - If the parent node is not present in the map, then create a new node and add it to the map. - If the child node is not present in the map, then create a new node and add it to the map. - If the child node is a left child, then add the child node to the left of the parent node. - If the child node is a right child, then add the child node to the right of the parent node. - Add the child node to the set of child nodes. - Finally, iterate over the `descriptions` array. - Find the node which is not a child node. - Return the root node. The key idea is to find the node which is not a child node and return it as the root node.\n","date":"July 15, 2024","permalink":"/blog/posts/previous-solutions/problem-create-binary-tree-from-descriptions/","summary":"Problem Statement Link - Problem 2196 Question You are given a 2D integer array descriptions where descriptions[i] = [parenti, childi, isLefti] indicates that parenti is the parent of childi in a binary tree of unique values.","title":"Problem 2196 Create Binary Tree From Descriptions","type":"posts"},{"content":" Problem Statement Link - Problem 726 Question Given a string formula representing a chemical formula, return the count of each atom.\nThe atomic element always starts with an uppercase character, then zero or more lowercase letters, representing the name.\nOne or more digits representing that element\u0026rsquo;s count may follow if the count is greater than 1. If the count is 1, no digits will follow.\nFor example, \u0026quot;H2O\u0026quot; and \u0026quot;H2O2\u0026quot; are possible, but \u0026quot;H1O2\u0026quot; is impossible. Two formulas are concatenated together to produce another formula.\nFor example, \u0026quot;H2O2He3Mg4\u0026quot; is also a formula. A formula placed in parentheses, and a count (optionally added) is also a formula.\nFor example, \u0026quot;(H2O2)\u0026quot; and \u0026quot;(H2O2)3\u0026quot; are formulas. Return the count of all elements as a string in the following form: the first name (in sorted order), followed by its count (if that count is more than 1), followed by the second name (in sorted order), followed by its count (if that count is more than 1), and so on.\nThe test cases are generated so that all the values in the output fit in a 32-bit integer.\nExample 1 Input: formula = \u0026#34;H2O\u0026#34; Output: \u0026#34;H2O\u0026#34; Explanation: The count of elements are {\u0026#39;H\u0026#39;: 2, \u0026#39;O\u0026#39;: 1}. Example 2 Input: formula = \u0026#34;Mg(OH)2\u0026#34; Output: \u0026#34;H2MgO2\u0026#34; Explanation: The count of elements are {\u0026#39;H\u0026#39;: 2, \u0026#39;Mg\u0026#39;: 1, \u0026#39;O\u0026#39;: 2}. Example 3 Input: formula = \u0026#34;K4(ON(SO3)2)2\u0026#34; Output: \u0026#34;K4N2O14S4\u0026#34; Explanation: The count of elements are {\u0026#39;K\u0026#39;: 4, \u0026#39;N\u0026#39;: 2, \u0026#39;O\u0026#39;: 14, \u0026#39;S\u0026#39;: 4}. Constraints - `1 \u0026lt;= formula.length \u0026lt;= 1000` - `formula` consists of English letters, digits, `\u0026#39;(\u0026#39;`, and `\u0026#39;)\u0026#39;`. - `formula` is always valid. Solution class Solution { public: string countOfAtoms(string formula) { stack\u0026lt;unordered_map\u0026lt;string, int\u0026gt;\u0026gt; stack; stack.push(unordered_map\u0026lt;string, int\u0026gt;()); int index = 0; while (index \u0026lt; formula.length()) { if (formula[index] == \u0026#39;(\u0026#39;) { stack.push(unordered_map\u0026lt;string, int\u0026gt;()); index++; } else if (formula[index] == \u0026#39;)\u0026#39;) { unordered_map\u0026lt;string, int\u0026gt; currMap = stack.top(); stack.pop(); index++; string multiplier; while (index \u0026lt; formula.length() \u0026amp;\u0026amp; isdigit(formula[index])) { multiplier += formula[index]; index++; } if (!multiplier.empty()) { int mult = stoi(multiplier); for (auto\u0026amp; [atom, count] : currMap) { currMap[atom] = count * mult; } } for (auto\u0026amp; [atom, count] : currMap) { stack.top()[atom] += count; } } else { string currAtom; currAtom += formula[index]; index++; while (index \u0026lt; formula.length() \u0026amp;\u0026amp; islower(formula[index])) { currAtom += formula[index]; index++; } string currCount; while (index \u0026lt; formula.length() \u0026amp;\u0026amp; isdigit(formula[index])) { currCount += formula[index]; index++; } int count = currCount.empty() ? 1 : stoi(currCount); stack.top()[currAtom] += count; } } map\u0026lt;string, int\u0026gt; finalMap(stack.top().begin(), stack.top().end()); string ans; for (auto\u0026amp; [atom, count] : finalMap) { ans += atom; if (count \u0026gt; 1) { ans += to_string(count); } } return ans; } }; Complexity Analysis Time Complexity : O(N) Space Complexity : O(N) Explanation 1. Intuition - Given a string `formula` representing a chemical formula, we need to return the count of each atom. - We need to recursively parse the formula to get proper count of each atom. - We can use hash maps to count the atoms inbetween a given set of parenthesis. - We can use stack to keep track of the hash maps which has been used to so far. - First have a hashmaps to keep track of the count of each atom. - Push it into the stack. - Traverse the formula string. - If we encounter a `(`, then push an empty hashmap into the stack. - If we encounter a `)`, then pop the top hashmap from the stack. - If there is a number after the `)`, then multiply the count of each atom in the popped hashmap with the number. - Add the count of each atom in the popped hashmap to the top hashmap in the stack. - If we encounter a character, then add the count of the atom to the top hashmap in the stack. - Finally, we will have the count of each atom in the top hashmap in the stack. - Convert the hashmap to a map and then iterate over the map to get the final answer as a string 2. Implementation - Initialize a stack of hashmaps `stack` and push an empty hashmap into the stack. - Initialize an integer `index` to 0. - Traverse the formula string until the end. - If the character at the `index` is `(`, then push an empty hashmap into the `stack` and increment the `index`. - If the character at the `index` is `)`, then pop the top hashmap from the `stack` and increment the `index`. - Initialize a string `multiplier` to empty. - Traverse the formula string until the end and the character at the `index` is a digit. - Add the digit to the `multiplier` and increment the `index`. - If the `multiplier` is not empty, then convert the `multiplier` to an integer `mult`. - Multiply the count of each atom in the popped hashmap with the `mult`. - Add the count of each atom in the popped hashmap to the top hashmap in the stack. - If the character at the `index` is a character, then initialize a string `currAtom` with the character at the `index` and increment the `index`. - Traverse the formula string until the end and the character at the `index` is a lowercase character. - Add the lowercase character to the `currAtom` and increment the `index`. - Initialize a string `currCount` to empty. - Traverse the formula string until the end and the character at the `index` is a digit. - Add the digit to the `currCount` and increment the `index`. - If the `currCount` is empty, then convert the `currCount` to an integer `count`. - Add the `count` to the `currAtom` in the top hashmap in the stack. - Convert the top hashmap in the stack to a map `finalMap`. - Initialize a string `ans` to empty. - Iterate over the `finalMap` and add the atom to the `ans`. - If the count of the atom is greater than 1, then add the count to the `ans`. - Return the `ans`. This is indeed a tricky question but has a lot of edge cases.\n","date":"July 14, 2024","permalink":"/blog/posts/previous-solutions/problem-number-of-atoms/","summary":"Problem Statement Link - Problem 726 Question Given a string formula representing a chemical formula, return the count of each atom.","title":"Problem 726 Number of Atoms","type":"posts"},{"content":" Problem Statement Link - Problem 2751 Question There are n 1-indexed robots, each having a position on a line, health, and movement direction.\nYou are given 0-indexed integer arrays positions, healths, and a string directions (directions[i] is either \u0026lsquo;L\u0026rsquo; for left or \u0026lsquo;R\u0026rsquo; for right). All integers in positions are unique.\nAll robots start moving on the line simultaneously at the same speed in their given directions. If two robots ever share the same position while moving, they will collide.\nIf two robots collide, the robot with lower health is removed from the line, and the health of the other robot decreases by one. The surviving robot continues in the same direction it was going. If both robots have the same health, they are both removed from the line.\nYour task is to determine the health of the robots that survive the collisions, in the same order that the robots were given, i.e. final heath of robot 1 (if survived), final health of robot 2 (if survived), and so on. If there are no survivors, return an empty array.\nReturn an array containing the health of the remaining robots (in the order they were given in the input), after no further collisions can occur.\nNote: The positions may be unsorted.\nExample 1 Input: positions = [5,4,3,2,1], healths = [2,17,9,15,10], directions = \u0026#34;RRRRR\u0026#34; Output: [2,17,9,15,10] Explanation: No collision occurs in this example, since all robots are moving in the same direction. So, the health of the robots in order from the first robot is returned, [2, 17, 9, 15, 10]. Example 2 Input: positions = [3,5,2,6], healths = [10,10,15,12], directions = \u0026#34;RLRL\u0026#34; Output: [14] Explanation: There are 2 collisions in this example. Firstly, robot 1 and robot 2 will collide, and since both have the same health, they will be removed from the line. Next, robot 3 and robot 4 will collide and since robot 4\u0026#39;s health is smaller, it gets removed, and robot 3\u0026#39;s health becomes 15 - 1 = 14. Only robot 3 remains, so we return [14]. Example 3 Input: positions = [1,2,5,6], healths = [10,10,11,11], directions = \u0026#34;RLRL\u0026#34; Output: [] Explanation: Robot 1 and robot 2 will collide and since both have the same health, they are both removed. Robot 3 and 4 will collide and since both have the same health, they are both removed. So, we return an empty array, []. Constraints - `1 \u0026lt;= positions.length == healths.length == directions.length == n \u0026lt;= 10^5` - `1 \u0026lt;= positions[i], healths[i] \u0026lt;= 10^9` - `directions[i] == \u0026#39;L\u0026#39; or directions[i] == \u0026#39;R\u0026#39;` - All values in `positions` are distinct Solution class Solution { public: vector\u0026lt;int\u0026gt; survivedRobotsHealths(vector\u0026lt;int\u0026gt;\u0026amp; positions, vector\u0026lt;int\u0026gt;\u0026amp; healths, string directions) { int size = positions.size(); vector\u0026lt;int\u0026gt;indices(size), result; stack\u0026lt;int\u0026gt;st; for(int ind = 0; ind\u0026lt;size; ind++){ indices[ind] = ind; } sort(indices.begin(), indices.end(),[\u0026amp;](int lhs, int rhs) { return positions[lhs] \u0026lt; positions[rhs]; }); for(int currInd:indices){ if(directions[currInd] == \u0026#39;R\u0026#39;){ st.push(currInd); } else{ int topInd; while(!st.empty() \u0026amp;\u0026amp; healths[currInd]\u0026gt;0){ topInd = st.top(); st.pop(); if(healths[currInd]\u0026gt; healths[topInd]){ healths[currInd] -=1; healths[topInd] = 0; } else if(healths[currInd]\u0026lt;healths[topInd]){ healths[currInd] = 0; healths[topInd]-=1; st.push(topInd); } else{ healths[currInd] = 0; healths[topInd] = 0; } } } } for(int ind = 0; ind\u0026lt;size; ind++){ if(healths[ind]\u0026gt;0){ result.push_back(healths[ind]); } } return result; } }; Complexity Analysis Time Complexity : O(nlogn) Space Complexity : O(n) Explanation 1. Intuition - Given the problem we can make the following observations. 1. A right going robot will never collide with another right going robot. 2. A left going robot will never collide with another left going robot. 3. A right going robot will collide with a left going robot only if the left going robot is to the right of the right going robot. - Based on the above observations we can sort the robots based on their positions. - Sorted array will contain the robots in the order which they are placed on the line. - Now we can iterate over the sorted array and simulate the collisions. - We need to calculate the collisions only between right and left going robots. - We can use a stack to store the right going robots. - If a left going robot is encountered we can check if there are any right going robots in the stack. - If there are right going robots in the stack we can simulate the collision. - If the left going robot has more health than the right going robot we can reduce the health of the left going robot by 1. - If the left going robot has less health than the right going robot we can reduce the health of the right going robot by 1. - If both the robots have the same health we can remove both the robots. - We can continue this process until we reach the end of the sorted array. - Finally, we can return the health of the robots that survived the collisions. 2. Implementation - Initialize a vector `indices` of `size = positions.size()` to store the order of the robots. - Initialize a stack `st` to store the positions of the right going robots. - Sort the `indices` based on the positions of the robots. - Iterate over the `indices` array. - Assign the current index to `currInd`. - If the current robot is right going push the `currInd` to the stack. - Else do 1. While `st` is not empty and `healths[currInd]` is greater than 0. - Pop the top index from the stack and assign it to `topInd`. - If `healths[currInd]` is greater than `healths[topInd]` reduce the health of `currInd` by 1 and set the health of `topInd` to 0. - If `healths[currInd]` is less than `healths[topInd]` reduce the health of `topInd` by 1,set the health of `currInd` to 0 and push the `topInd` to the stack. This shows that \u0026#39;right going robot is still alive\u0026#39;. - If `healths[currInd]` is equal to `healths[topInd]` set the health of both `currInd` and `topInd` to 0. - Iterate over the `healths` array and push the health of the robots that survived the collisions to the `result` array. - Return the `result` array. The above method will preserve the initial order of the robots.\nNote - The key point was to figure out the fact that the robots will collide only if they are moving in opposite directions and the left going robot is to the right of the right going robot. Also this fact can be used to sort the robots based on their positions and simulate the collisions.\n","date":"July 13, 2024","permalink":"/blog/posts/previous-solutions/problem-robot-collisions/","summary":"Problem Statement Link - Problem 2751 Question There are n 1-indexed robots, each having a position on a line, health, and movement direction.","title":"Problem 2751 Robot Collisions","type":"posts"},{"content":" Problem Statement Link - Problem 297 Question Serialization is the process of converting a data structure or object into a sequence of bits so that it can be stored in a file or memory buffer, or transmitted across a network connection link to be reconstructed later in the same or another computer environment.\nDesign an algorithm to serialize and deserialize a binary tree. There is no restriction on how your serialization/deserialization algorithm should work. You just need to ensure that a binary tree can be serialized to a string and this string can be deserialized to the original tree structure.\nExample 1 Input: root = [1,2,3,null,null,4,5] Output: [1,2,3,null,null,4,5] Example 2 Input: root = [] Output: [] Constraints - The number of nodes in the tree is in the range `[0, 10^4]`. - `-1000 \u0026lt;= Node.val \u0026lt;= 1000` Solution /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Codec { public: string serialize(TreeNode* root) { string ans = \u0026#34;\u0026#34;; TreeNode* temp = root; queue\u0026lt;TreeNode*\u0026gt;q; q.push(temp); while(!q.empty()) { for(int i = 0; i\u0026lt;q.size(); i++) { if(q.front() != nullptr) { ans+=to_string(q.front()-\u0026gt;val); ans+=\u0026#39;#\u0026#39;; q.push(q.front()-\u0026gt;left); q.push(q.front()-\u0026gt;right); } else { ans+=\u0026#34;null#\u0026#34;; } q.pop(); } } return ans; } TreeNode* deserialize(string data) { vector\u0026lt;string\u0026gt; nodes; int l = 0, r = 0; while (l \u0026lt; data.size()) { while (r \u0026lt; data.size() \u0026amp;\u0026amp; data[r] != \u0026#39;#\u0026#39;) { r++; } nodes.push_back(data.substr(l, r - l)); l = r + 1; r = l; } if(nodes[0] == \u0026#34;null\u0026#34;) return nullptr; TreeNode* root = new TreeNode(stoi(nodes[0])); queue\u0026lt;TreeNode*\u0026gt;q; q.push(root); int ind = 1; while(!q.empty()) { TreeNode* curr = q.front(); q.pop(); if(nodes[ind]!=\u0026#34;null\u0026#34;) { TreeNode* temp = new TreeNode(stoi(nodes[ind])); curr-\u0026gt;left = temp; q.push(temp); } else { curr-\u0026gt;left = nullptr; } ind++; if(nodes[ind]!=\u0026#34;null\u0026#34;) { TreeNode* temp = new TreeNode(stoi(nodes[ind])); curr-\u0026gt;right = temp; q.push(temp); } else { curr-\u0026gt;right = nullptr; } ind++; } return root; } }; // Your Codec object will be instantiated and called as such: // Codec ser, deser; // TreeNode* ans = deser.deserialize(ser.serialize(root)); Complexity Analysis Time Complexity : O(n) where n is the number of nodes in the tree. Space Complexity : O(n) where n is the number of nodes in the tree. Explanation 1. Intuition 1. Serialization : - We can serialize a binary tree using level order traversal. - Use a queue to store the nodes of the tree. - If the node is not null, push the value of the node to the string and push the left and right child of the node to the queue. - If the node is null, push \u0026#34;null\u0026#34; to the string. - Use an appropriate delimiter to separate the values of the nodes. 2. Deserialization : - Split the string using the delimiter and store the values in a vector. - Create a queue and push the root node to the queue. - Iterate over the vector and create the left and right child of the current node. - Push the left and right child to the queue. - Return the root node. 2. Implementation 1. Serialization : - Initialize a string `ans` and a queue `q`. - Push the root node to the queue. - Iterate over the queue and check if the front of the queue is not null. - If the front of the queue is not null, push the value of the node to the string and push the left and right child of the node to the queue. - append the delimiter `#` to the string. - If the front of the queue is null, push \u0026#34;`null#`\u0026#34; to the string. - Return the string. 2. Deserialization : - Split the string using the delimiter `#` and store the values in a vector `nodes`. - If the first element of the vector is `\u0026#34;null\u0026#34;`, return `nullptr`. - Create a root node with the value of the first element of the vector. - Create a queue `q` and push the root node to the queue. - Initialize an index `ind` to 1. - Iterate over the queue and create the left and right child of the current node in the following manner - If the value at index `ind` is not `\u0026#34;null\u0026#34;`, create a new node with the value and assign it as the left child of the current node. - Push the left child to the queue. - Increment the index `ind`. - If the value at index `ind` is not `\u0026#34;null\u0026#34;`, create a new node with the value and assign it as the right child of the current node. - Push the right child to the queue. - Increment the index `ind`. - Return the root node. Picture credits : LeetCode\n","date":"July 12, 2024","permalink":"/blog/posts/previous-solutions/problem-serialize-and-deserialize-binary-tree/","summary":"Problem Statement Link - Problem 297 Question Serialization is the process of converting a data structure or object into a sequence of bits so that it can be stored in a file or memory buffer, or transmitted across a network connection link to be reconstructed later in the same or another computer environment.","title":"Problem 297 Serialize and Deserialize Binary Tree","type":"posts"},{"content":" Problem Statement Link - Problem 1717 Question You are given a string s and two integers x and y. You can perform two types of operations any number of times.\nRemove substring \u0026quot;ab\u0026quot; and gain x points. For example, when removing \u0026quot;ab\u0026quot; from \u0026quot;cabxbae\u0026quot; it becomes \u0026quot;cxbae\u0026quot;. Remove substring \u0026quot;ba\u0026quot; and gain y points. For example, when removing \u0026quot;ba\u0026quot; from \u0026quot;cabxbae\u0026quot; it becomes \u0026quot;cabxe\u0026quot;. Return the maximum points you can gain after applying the above operations on s.\nExample 1 Input: s = \u0026#34;cdbcbbaaabab\u0026#34;, x = 4, y = 5 Output: 19 - Remove \u0026#34;ba\u0026#34; at index 5\u0026amp;6, s = \u0026#34;cdbcbaabab\u0026#34;, score = 5. - Remove \u0026#34;ba\u0026#34; at index 4\u0026amp;5 s = \u0026#34;cdbcabab\u0026#34;, score = 10. - Remove \u0026#34;ba\u0026#34; at index 5\u0026amp;6, s = \u0026#34;cdbcab\u0026#34;, score = 15. - Remove \u0026#34;ab\u0026#34; at index 4\u0026amp;5, s = \u0026#34;cdcb\u0026#34;, score = 19. Total score = 5 + 4 + 5 + 5 = 19. Example 2 Input: s = \u0026#34;aabbaaxybbaabb\u0026#34;, x = 5, y = 4 Output: 20 Explanation: - Remove the \u0026#34;ab\u0026#34; at index 1\u0026amp;2, s = \u0026#34;abaaxybbaabb\u0026#34;, score = 5. - Remove the \u0026#34;ab\u0026#34; at index 0\u0026amp;1, s = \u0026#34;aaxybbaabb\u0026#34;, score = 10. - Remove the \u0026#34;ab\u0026#34; at index 7\u0026amp;8, s = \u0026#34;aaxybbab\u0026#34;, score = 15. - Remove the \u0026#34;ab\u0026#34; at index 6\u0026amp;7, s = \u0026#34;aaxybb\u0026#34;, score = 20. Total score = 5 + 5 + 5 + 5 = 20. Constraints - `1 \u0026lt;= s.length \u0026lt;= 10^5` - `1 \u0026lt;= x, y \u0026lt;= 10^4` - `s` consists of lowercase English letters. Note By seeing the constraints we can say that the solution should be of linear time complexity. hence DP is not a good choice. We can solve this problem using stack. We will be using a greedy algorithm to solve this problem.\nWhy greedy? We can show the following :\nOnly \u0026#34;aba\u0026#34; and \u0026#34;bab\u0026#34; substrings can potentially lead to a different final score. Why only those? Because it is possible to remove either \u0026#34;ab\u0026#34; or \u0026#34;ba\u0026#34; in only in those cases. Now to the proof part: Assume we have string S. Consider any substring \u0026#34;aba\u0026#34; (or \u0026#34;bab\u0026#34;) in it: prefix of S | aba | suffix of S notice that removing either ab or ba leads to the same string : prefix of S | a | suffix of S (or prefix of S | b | suffix of S) This shows that we must always go for a replacement with the higher value. Solution class Solution { public: int maximumGain(string s, int x, int y) { std::ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); int res = 0; string top, bot; int top_score, bot_score; if (y \u0026gt; x) { top = \u0026#34;ba\u0026#34;; top_score = y; bot = \u0026#34;ab\u0026#34;; bot_score = x; } else { top = \u0026#34;ab\u0026#34;; top_score = x; bot = \u0026#34;ba\u0026#34;; bot_score = y; } stack\u0026lt;char\u0026gt;st; for(char ch:s){ if(ch == top[1] \u0026amp;\u0026amp; !st.empty() \u0026amp;\u0026amp; st.top() == top[0]){ res+=top_score; st.pop(); } else{ st.push(ch); } } stack\u0026lt;char\u0026gt;newst; char ch; while(!st.empty()){ ch = st.top(); st.pop(); if(ch == bot[0] \u0026amp;\u0026amp; !newst.empty() \u0026amp;\u0026amp; newst.top()==bot[1]){ res+=bot_score; newst.pop(); } else{ newst.push(ch); } } return res; } }; Complexity Analysis Time Complexity : O(N) Because we are iterating over the string once. Space Complexity : O(N) Explanation 1. Intuition - First we need to check which substring has higher score. - Set the `top` string to the substring with higher score. - Set the `bot` string to the substring with lower score. - Iterate over the string and check if the top substring can be formed. - If yes, then add the score to the result. - Else push the character to the stack. - Iterate over the stack and check if the bot substring can be formed. - If yes, then add the score to the result. - Else push the character to the new stack. - Return the result. 2. Implementation - Initialize the result `res` to 0. - Initialize the `top` and `bot` substrings and their respective scores. - Check which substring has higher score and set the `top` and `bot` substrings accordingly. - Initialize a stack `st` and iterate over the string `s`. - Check if the character is the second character of the `top` substring and the top of the stack is the first character of the `top` substring. - This is because stack stores the string in reverse order. - If the condition is true, then add the score to the result and pop the top of the stack. - Else push the character to the stack. - Initialize a new stack `newst` and a character `ch`. - Iterate over the stack `st` and check if the character is the first character of the `bot` substring and the top of the new stack is the second character of the `bot` substring. - If the condition is true, then add the score to the result and pop the top of the new stack. - Else push the character to the new stack. - Return the result. ","date":"July 12, 2024","permalink":"/blog/posts/previous-solutions/problem-maximum-score-from-removing-substrings/","summary":"Problem Statement Link - Problem 1717 Question You are given a string s and two integers x and y.","title":"Problem 1717 Maximum Score From Removing Substrings","type":"posts"},{"content":" Problem Statement Link - Problem 1190 Question You are given a string s that consists of lower case English letters and brackets.\nReverse the strings in each pair of matching parentheses, starting from the innermost one.\nYour result should not contain any brackets.\nExample 1 Input: s = \u0026#34;(abcd)\u0026#34; Output: \u0026#34;dcba\u0026#34; Example 2 Input: s = \u0026#34;(u(love)i)\u0026#34; Output: \u0026#34;iloveu\u0026#34; Explanation: The substring \u0026#34;love\u0026#34; is reversed first, then the whole string is reversed. Example 3 Input: s = \u0026#34;(ed(et(oc))el)\u0026#34; Output: \u0026#34;leetcode\u0026#34; Explanation: First, we reverse the substring \u0026#34;oc\u0026#34;, then \u0026#34;etco\u0026#34;, and finally, the whole string. Constraints - `1 \u0026lt;= s.length \u0026lt;= 2000` - `s` only contains lower case English characters and parentheses. - It is guaranteed that all parentheses are balanced. Solution class Solution { public: string reverseParentheses(string s) { stack\u0026lt;char\u0026gt; st; queue\u0026lt;char\u0026gt; q; string ans; for(char i : s){ if(i!=\u0026#39;)\u0026#39;) st.push(i); else{ while(st.top()!=\u0026#39;(\u0026#39;){ q.push(st.top()); st.pop(); } st.pop(); while(!q.empty()){ st.push(q.front()); q.pop(); } } } while(!st.empty()){ ans.push_back(st.top()); st.pop(); } reverse(ans.begin(),ans.end()); return ans; } }; Complexity Analysis Time Complexity : O(N) Because we are iterating over the string once. Space Complexity : O(N) Explanation 1. Intuition - We can use a stack and a queue to solve this problem. - We can iterate over the string and push the characters into the stack. - Till we encounter a closing bracket, we keep pushing the characters into the stack. - Once we encounter a closing bracket, we pop the characters from the stack and push them into the queue till we encounter an opening bracket. - Once we encounter an opening bracket, we pop the opening bracket from the stack. - We then push the characters from the queue back into the stack. - This will effectively reverse the characters between the brackets. - Once we process the entire string, we can pop the characters from the stack and append them to the answer string. - Finally, we reverse the answer string and return it. 2. Implementation - Initialize a stack `st`, a queue `q`, and a string `ans`. - Iterate over the string `s` and check if the character is not a closing bracket, then push it into the stack. - If the character is a closing bracket, then pop the characters from the stack and push them into the queue till we encounter an opening bracket. - Once we encounter an opening bracket, pop the opening bracket from the stack. - Push the characters from the queue back into the stack. - Once we process the entire string, pop the characters from the stack and append them to the answer string. - Reverse the answer string and return it. ","date":"July 11, 2024","permalink":"/blog/posts/previous-solutions/problem-reverse-substrings-between-each-pair-of-parentheses/","summary":"Problem Statement Link - Problem 1190 Question You are given a string s that consists of lower case English letters and brackets.","title":"Problem 1190 Reverse Substrings Between Each Pair of Parentheses","type":"posts"},{"content":" Problem Statement Link - Problem 1598 Question The Leetcode file system keeps a log each time some user performs a change folder operation.\nThe operations are described below:\n\u0026quot;../\u0026quot; : Move to the parent folder of the current folder. (If you are already in the main folder, remain in the same folder). \u0026quot;./\u0026quot; : Remain in the same folder. \u0026quot;x/\u0026quot; : Move to the child folder named x (This folder is guaranteed to always exist). You are given a list of strings logs where logs[i] is the operation performed by the user at the ith step. The file system starts in the main folder, then the operations in logs are performed.\nReturn the minimum number of operations needed to go back to the main folder after the change folder operations.\nExample 1 Input: logs = [\u0026#34;d1/\u0026#34;,\u0026#34;d2/\u0026#34;,\u0026#34;../\u0026#34;,\u0026#34;d21/\u0026#34;,\u0026#34;./\u0026#34;] Output: 2 Explanation: Use this change folder operation \u0026#34;../\u0026#34; 2 times and go back to the main folder. Example 2 Input: logs = [\u0026#34;d1/\u0026#34;,\u0026#34;d2/\u0026#34;,\u0026#34;./\u0026#34;,\u0026#34;d3/\u0026#34;,\u0026#34;../\u0026#34;,\u0026#34;d31/\u0026#34;] Output: 3 Example 3 Input: logs = [\u0026#34;d1/\u0026#34;,\u0026#34;../\u0026#34;,\u0026#34;../\u0026#34;,\u0026#34;../\u0026#34;] Output: 0 Constraints - `1 \u0026lt;= logs.length \u0026lt;= 10^3` - `2 \u0026lt;= logs[i].length \u0026lt;= 10` - logs[i] contains lowercase English letters, digits, \u0026#39;.\u0026#39;, and \u0026#39;/\u0026#39;. - logs[i] follows the format described in the statement. - Folder names consist of lowercase English letters and digits. Solution class Solution { public: int minOperations(vector\u0026lt;string\u0026gt;\u0026amp; logs) { int count = 0; std::ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); for(string it:logs) { if(it == \u0026#34;../\u0026#34;) { count--; if(count\u0026lt;0) count = 0; } else if(it != \u0026#34;./\u0026#34;) count++; } return count; } }; Complexity Analysis Time Complexity : O(N) Space Complexity : O(1) Explanation 1. Intuition - Since the directory is Linear in the given problem, we can keep track of the count of the operations. - If the operation is `../` then we decrement the count and if the count is less than 0, we reset it to 0. - If the operation is not `./` then we increment the count. - Finally, we return the count. 2. Implementation - Initialize the `count` to 0. - Iterate over the `logs` and check if the operation is `../` then decrement the `count` and reset it to 0 if it is less than 0. - If the operation is not `./` then increment the `count`. - Finally, return the `count`. ","date":"July 10, 2024","permalink":"/blog/posts/previous-solutions/problem-crawler-log-folder/","summary":"Problem Statement Link - Problem 1598 Question The Leetcode file system keeps a log each time some user performs a change folder operation.","title":"Problem 1598 Crawler Log Folder","type":"posts"},{"content":" Problem Statement Link - Problem 1701 Question There is a restaurant with a single chef. You are given an array customers, where customers[i] = [arrivali, timei]:\n- arrivali is the arrival time of the ith customer. The arrival times are sorted in non-decreasing order.\ntimei is the time needed to prepare the order of the ith customer. When a customer arrives, he gives the chef his order, and the chef starts preparing it once he is idle. The customer waits till the chef finishes preparing his order. The chef does not prepare food for more than one customer at a time. The chef prepares food for customers in the order they were given in the input.\nReturn the average waiting time of all customers. Solutions within 10^-5 from the actual answer are considered accepted.\nExample 1 Input: customers = [[1,2],[2,5],[4,3]] Output: 5.00000 Explanation: 1. The first customer arrives at time 1, the chef takes his order and starts preparing it immediately at time 1, and finishes at time 3, so the waiting time of the first customer is 3 - 1 = 2. 2. The second customer arrives at time 2, the chef takes his order and starts preparing it at time 3, and finishes at time 8, so the waiting time of the second customer is 8 - 2 = 6. 3. The third customer arrives at time 4, the chef takes his order and starts preparing it at time 8, and finishes at time 11, so the waiting time of the third customer is 11 - 4 = 7. So the average waiting time = (2 + 6 + 7) / 3 = 5. Example 2 Input: customers = [[5,2],[5,4],[10,3],[20,1]] Output: 3.25000 Explanation: 1. The first customer arrives at time 5, the chef takes his order and starts preparing it immediately at time 5, and finishes at time 7, so the waiting time of the first customer is 7 - 5 = 2. 2. The second customer arrives at time 5, the chef takes his order and starts preparing it at time 7, and finishes at time 11, so the waiting time of the second customer is 11 - 5 = 6. 3. The third customer arrives at time 10, the chef takes his order and starts preparing it at time 11, and finishes at time 14, so the waiting time of the third customer is 14 - 10 = 4. 4. The fourth customer arrives at time 20, the chef takes his order and starts preparing it immediately at time 20, and finishes at time 21, so the waiting time of the fourth customer is 21 - 20 = 1. So the average waiting time = (2 + 6 + 4 + 1) / 4 = 3.25. Constraints - `1 \u0026lt;= customers.length \u0026lt;= 10^5` - `1 \u0026lt;= arrivali, timei \u0026lt;= 10^4` - `arrival(i) \u0026lt;= arrival(i+1)` Solution class Solution { public: double averageWaitingTime(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; customers) { std::ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); long long int endTime = customers[0][0] + customers[0][1]; double waitTime = customers[0][1]; int arrivalTime, time; vector\u0026lt;int\u0026gt; it; for(int i = 1; i\u0026lt;customers.size();i++) { it = customers[i]; arrivalTime = it[0]; time = it[1]; if(arrivalTime\u0026gt;endTime) { endTime = arrivalTime; } endTime += time; waitTime += endTime - arrivalTime; } return waitTime/customers.size(); } }; Complexity Analysis Time Complexity : O(N) Space Complexity : O(1) Explanation 1. Intuition - This just a calculation of FCFS scheduling. - Technically we are calculating the average turnaround time. - We know that `turn around time = end time - arrival time`. - `end time = service time + max(arrival time, previous end time)`. - So we need accumulate the turn around time and divide it by the number of customers. 2. Implementation - Initialize the `endTime` and `waitTime` with the first customer\u0026#39;s total time and service time respectively. - Iterate over the customers from the second customer. - Calculate the `arrivalTime` and `time` of the current customer. - If the `arrivalTime` is greater than the `endTime`, update the `endTime` with the `arrivalTime`. - This shows that chef is idle and had to wait for the customer to arrive. - Update the `endTime` with the `time` of the current customer. - Add the `endTime - arrivalTime` to the `waitTime`. - Return the `waitTime` divided by the number of customers. ","date":"July 9, 2024","permalink":"/blog/posts/previous-solutions/problem-average-waiting-time/","summary":"Problem Statement Link - Problem 1701 Question There is a restaurant with a single chef.","title":"Problem 1701 Average Waiting Time","type":"posts"},{"content":" Problem Statement Link - Problem 1823 Question There are n friends that are playing a game. The friends are sitting in a circle and are numbered from 1 to n in clockwise order. More formally, moving clockwise from the ith friend brings you to the (i+1)th friend for 1 \u0026lt;= i \u0026lt; n, and moving clockwise from the nth friend brings you to the 1st friend.\nThe rules of the game are as follows:\nStart at the 1st friend. Count the next k friends in the clockwise direction including the friend you started at. The counting wraps around the circle and may count some friends more than once. The last friend you counted leaves the circle and loses the game. If there is still more than one friend in the circle, go back to step 2 starting from the friend immediately clockwise of the friend who just lost and repeat. Else, the last friend in the circle wins the game. Given the number of friends, n, and an integer k, return the winner of the game. Note This is exactly the same as the Josephus problem, but with a different name. It is also called the n-people game.\nExample 1 Input: n = 5, k = 2 Output: 3 Explanation: Here are the steps of the game: 1. Start at friend 1. 2. Count 2 friends clockwise, which are friends 1 and 2. 3. Friend 2 leaves the circle. Next start is friend 3. 4. Count 2 friends clockwise, which are friends 3 and 4. 5. Friend 4 leaves the circle. Next start is friend 5. 6. Count 2 friends clockwise, which are friends 5 and 1. 7. Friend 1 leaves the circle. Next start is friend 3. 8. Count 2 friends clockwise, which are friends 3 and 5. 9. Friend 5 leaves the circle. Only friend 3 is left, so they are the winner. Example 2 Input: n = 6, k = 5 Output: 1 Explanation: The friends leave in this order: 5, 4, 6, 2, 3. The winner is friend 1. Constraints - `1 \u0026lt;= k \u0026lt;= n \u0026lt;= 500` Solution class Solution { public: int findTheWinner(int N, int k) { int i = 1, ans = 0; while (i \u0026lt;= N) { ans = (ans + k) % i; i++; } return ans + 1; } }; Complexity Analysis Time Complexity : O(N) Space Complexity : (1) Explanation 1. Intuition - We know that we can find the winner by simulating the result of each round from 1 to N. - We will count `k` friends in the clockwise direction including the friend we started at. - The quantity `ans` will store the index of the winner of each round. - We will return the winner of the last round. - The value `(ans+k)%i` will give us the index of the winner of the next round. - How does it give the index of winner ? - Let\u0026#39;s say we have `i` friends and we are at the `jth` friend. - We need to find the index of the winner of the next round. - We know that the winner of the next round will be the winner of the current round plus `k` friends. - but since the friends are being removed from the circle, we need to take the modulo of the number of friends got removed. - This will give us how many indexes we need to move from the current index to get the winner of the next round. TLDR - When there are n people, the person leaving is (k-1) positions away from the current starting person. - The new starting position is the next person clockwise after the person who leaves. - The winner for n people can be found using the winner of n-1 people adjusted by the counting step k. - Don\u0026#39;t forget to re-index to 1-indexing. Add 1 to the final answer. 2. Implementation - Initialize the variables `i` and `ans` to 1 and 0 respectively. - Iterate from 1 to N. - Update the value of `ans` to `(ans+k)%i`. - Return the value of `ans+1`. Alternate Approach class Solution { public: int findTheWinner(int n, int k) { // Initialize vector of N friends, labeled from 1-N vector\u0026lt;int\u0026gt; circle; for (int i = 1; i \u0026lt;= n; i++) { circle.push_back(i); } // Maintain the index of the friend to start the count on int startIndex = 0; // Perform eliminations while there is more than 1 friend left while (circle.size() \u0026gt; 1) { // Calculate the index of the friend to be removed int removalIndex = (startIndex + k - 1) % circle.size(); // Erase the friend at removalIndex circle.erase(circle.begin() + removalIndex); // Update startIndex for the next round startIndex = removalIndex; } return circle.front(); } }; Time Complexity: O(N^2) Space Complexity: O(N) Explanation - Just simulate the game by removing the friends one by one. - Keep track of the index of the friend to start the count on. - Calculate the index of the friend to be removed. - Erase the friend at the removal index. - Update the startIndex for the next round. - Return the winner of the game. ","date":"July 9, 2024","permalink":"/blog/posts/previous-solutions/problem-find-the-winner-of-the-circular-game/","summary":"Problem Statement Link - Problem 1823 Question There are n friends that are playing a game.","title":"Problem 1823 Find the Winner of the Circular Game","type":"posts"},{"content":" Problem Statement Link - Problem 1518 Question There are numBottles water bottles that are initially full of water. You can exchange bumExchange empty water bottles for one full water bottle. The operation of drinking a full water bottle turns it into an empty bottle.\nGiven two integers numBottles and numExchange, return the maximum number of water bottles you can drink.\nExample 1 Input: numBottles = 9, numExchange = 3 Output: 13 Explanation: You can exchange 3 empty bottles to get 1 full water bottle. Number of water bottles you can drink: 9 + 3 + 1 = 13. Example 2 Input: numBottles = 15, numExchange = 4 Output: 19 Explanation: You can exchange 4 empty bottles to get 1 full water bottle. Number of water bottles you can drink: 15 + 3 + 1 = 19. Constraints - `1 \u0026lt;= numBottles \u0026lt;= 100` - `2 \u0026lt;= numExchange \u0026lt;= 100` Solution class Solution { public: int numWaterBottles(int numBottles, int numExchange) { int numEmpty = 0, res = 0; while (numBottles) { res += numBottles; numEmpty += numBottles; numBottles = numEmpty / numExchange; numEmpty = numEmpty % numExchange; } return res; } }; Complexity Analysis Time Complexity : O(N) Space Complexity : O(1) Explanation 1. Intuition - We need to calculate the maximum number of water bottles we can drink. - First assign the number of empty bottles to 0 and the result to 0. - While the number of bottles is not 0, add the number of bottles to the result.(Simulates drinking the water) - Add the number of bottles to the number of empty bottles.(Simulates the number of empty bottles generated) - Calculate the number of bottles that can be exchanged for full bottles and the number of empty bottles left. - This will be empty bottles/numExchange. - Calculate the left over empty bottles. - This will be empty bottles%numExchange. - Continue the process until the number of bottles is not 0. 2. Implementation - Assign the number of empty bottles `numEmpty` to 0 and the result `res` to 0. - While `numBottles` is not 0, do: 1. Add the `numBottles` to the `res`. 2. Add the `numBottles` to the `numEmpty`. 3. Update the `numBottles` to `numEmpty/numExchange`. - This simulates the number of bottles that can be exchanged for full bottles. 4. Update the `numEmpty` to `numEmpty%numExchange`. - This simulates the number of empty bottles left after exchanging. 5. Continue the process until the number of bottles is not 0. - Return the result. Mathematical solution class Solution { public: int numWaterBottles(int numBottles, int numExchange) { return numBottles + (numBottles - 1) / (numExchange - 1); } }; Explanation - The mathematical solution is derived from the fact that we can drink all the water bottles and exchange the empty bottles for full bottles. - How many empty bottles can we exchange for full bottles? - If we give `numExchange` empty bottles, we can get 1 full bottle. - Then its same as giving out `numExchange - 1` empty bottles to get a refill. - If we keep aside 1 bottle to fill the refill, we can exchange `numBottles-1`. - Hence, the total number of bottles we can drink = `numBottles + (numBottles - 1) / (numExchange - 1)`. ","date":"July 7, 2024","permalink":"/blog/posts/previous-solutions/problem-water-bottles/","summary":"Problem Statement Link - Problem 1518 Question There are numBottles water bottles that are initially full of water.","title":"Problem 1518 Water Bottles","type":"posts"},{"content":" Problem Statement Link - Problem 2582 Question There are n people standing in a line labeled from 1 to n. The first person in the line is holding a pillow initially. Every second, the person holding the pillow passes it to the next person standing in the line. Once the pillow reaches the end of the line, the direction changes, and people continue passing the pillow in the opposite direction.\nFor example, once the pillow reaches the nth person they pass it to the n - 1th person, then to the n - 2th person and so on. Given the two positive integers n and time, return the index of the person holding the pillow after time seconds.\nExample 1 Input: n = 4, time = 5 Output: 2 Explanation: People pass the pillow in the following way: 1 -\u0026gt; 2 -\u0026gt; 3 -\u0026gt; 4 -\u0026gt; 3 -\u0026gt; 2. After five seconds, the 2nd person is holding the pillow. Example 2 Input: n = 3, time = 2 Output: 3 Explanation: People pass the pillow in the following way: 1 -\u0026gt; 2 -\u0026gt; 3. After two seconds, the 3rd person is holding the pillow. Constraints - 2 \u0026lt;= n \u0026lt;= 1000 - 1 \u0026lt;= time \u0026lt;= 1000 Solution class Solution { public: int passThePillow(int n, int time) { int direc = time/(n-1); int pos = time%(n-1); if(direc%2==0) return pos+1; else return n-pos; } }; Complexity Analysis Time Complexity : O(1) Space Complexity : O(1) Explanation 1. Intuition - Since the pillow is passed in a cyclic manner, we can calculate the direction and position of the person holding the pillow after time seconds. - The pillow changes direction after every n-1 seconds. - This can be proved by taking an example of n=4 and time=5. - at 0th second, the pillow is at 1st position. - at 1st second, the pillow is at 2nd position. - at 2nd second, the pillow is at 3rd position. - at 3rd second, the pillow is at 4th position. - at 4th second, the pillow is at 3rd position. - at 5th second, the pillow is at 2nd position. - Hence, the pillow changes direction after every n-1 seconds. - If we calculate the number of times the pillow changes direction, we can calculate the position of the person holding the pillow after time seconds. - Number of times the pillow changes direction = time/(n-1). - The relative position of the person holding the pillow after time seconds = time%(n-1). - If the direction is even, the position of the person holding the pillow = pos+1. (this means the pillow was moving from left to right) - If the direction is odd, the position of the person holding the pillow = n-pos. (this means the pillow was moving from right to left) 2. Implementation - declare a variable `direc` = time/(n-1). - This will give the number of times the pillow changes direction. - declare a variable `pos` = time%(n-1). - This will give the relative position of the person holding the pillow after time seconds. - If the direction is even, return pos+1. - If the direction is odd, return n-pos. ","date":"July 6, 2024","permalink":"/blog/posts/previous-solutions/problem-pass-the-pillow/","summary":"Problem Statement Link - Problem 2582 Question There are n people standing in a line labeled from 1 to n.","title":"Problem 2582 Pass the Pillow","type":"posts"},{"content":" Problem Statement Link - Problem 2058 Question A critical point in a linked list is defined as either a local maxima or a local minima.\nA node is a local maxima if the current node has a value strictly greater than the previous node and the next node.\nA node is a local minima if the current node has a value strictly smaller than the previous node and the next node.\nNote that a node can only be a local maxima/minima if there exists both a previous node and a next node.\nGiven a linked list head, return an array of length 2 containing [minDistance, maxDistance] where minDistance is the minimum distance between any two distinct critical points and maxDistance is the maximum distance between any two distinct critical points. If there are fewer than two critical points, return [-1, -1].\nExample 1 graph LR A((3)) --\u003e B((1)) Input: head = [3,1] Output: [-1,-1] Explanation: There are no critical points in [3,1]. Example 2 graph LR A((5)) --\u003e B((3)) B --\u003e C((1)) C --\u003e D((2)) D --\u003e E((5)) E --\u003e F((1)) F --\u003e G((2)) Input: head = [5,3,1,2,5,1,2] Output: [1,3] Explanation: There are three critical points: - [5,3,1,2,5,1,2]: The third node is a local minima because 1 is less than 3 and 2. - [5,3,1,2,5,1,2]: The fifth node is a local maxima because 5 is greater than 2 and 1. - [5,3,1,2,5,1,2]: The sixth node is a local minima because 1 is less than 5 and 2. The minimum distance is between the fifth and the sixth node. minDistance = 6 - 5 = 1. The maximum distance is between the third and the sixth node. maxDistance = 6 - 3 = 3. Example 3 graph LR A((1)) --\u003e B((3)) B --\u003e C((2)) C --\u003e D((2)) D --\u003e E((3)) E --\u003e F((2)) F --\u003e G((2)) G --\u003e H((2)) H --\u003e I((7)) Input: head = [1,3,2,2,3,2,2,2,7] Output: [3,3] Explanation: There are two critical points: - [1,3,2,2,3,2,2,2,7]: The second node is a local maxima because 3 is greater than 1 and 2. - [1,3,2,2,3,2,2,2,7]: The fifth node is a local maxima because 3 is greater than 2 and 2. Both the minimum and maximum distances are between the second and the fifth node. Thus, minDistance and maxDistance is 5 - 2 = 3. Note that the last node is not considered a local maxima because it does not have a next node. Constraints - The number of nodes in the list is in the range `[2, 10^5]`. - `1 \u0026lt;= Node.val \u0026lt;= 10^5` Solution /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ class Solution { public: vector\u0026lt;int\u0026gt; nodesBetweenCriticalPoints(ListNode* head) { std::ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); ListNode* prev = head; ListNode* curr = head-\u0026gt;next; if(head-\u0026gt;next == nullptr) return {-1,-1}; vector\u0026lt;int\u0026gt;positions; int ind = 1; while(curr-\u0026gt;next!=nullptr) { if((prev-\u0026gt;val\u0026lt;curr-\u0026gt;val \u0026amp;\u0026amp; curr-\u0026gt;val\u0026gt;curr-\u0026gt;next-\u0026gt;val)||(prev-\u0026gt;val\u0026gt;curr-\u0026gt;val \u0026amp;\u0026amp; curr-\u0026gt;val\u0026lt;curr-\u0026gt;next-\u0026gt;val)) { positions.push_back(ind); } ind++; prev = curr; curr =curr-\u0026gt;next; } if(positions.size()\u0026lt;2) return {-1,-1}; int mini = INT_MAX; for(int i = 1;i\u0026lt;positions.size();i++) mini = min(mini,positions[i]-positions[i-1]); return {mini,positions.back() - positions.front()}; } }; Complexity Analysis Time Complexity : O(n) Space Complexity : O(1) excluding the space for the output list. Explanation 1. Intuition - We need to find the critical points in the linked list and then find the minimum and maximum distance between them. - That means first we have to find the indexes of the critical points. - Then we can find the minimum and maximum distance between them. - We can find the critical points by comparing the current node with the previous and the next node. - Create an ascending sequence of the indexes of the critical points. - Maximum will be the difference between the last and the first index. - Minimum will be the minimum difference between the indexes. - Edge cases are when there are no critical points or only one critical point. - When there is less than 3 nodes in the linked list, there will be no critical points. 2. Implementation - Delcare two pointers `prev` and `curr` to traverse the linked list. - `prev` will point to the `head` and `curr` will point to the next node. - If there are less than 2 nodes in the linked list, return `[-1,-1]`. - Declare a vector `positions` to store the indexes of the critical points. - Declare an integer `ind` to store the index of the current node, initialize it to 1. - While `curr-\u0026gt;next` is not `nullptr` 1. If the current node is a critical point, add the index to the `positions` vector. 2. Increment the index `ind`. 3. Move the `prev` and `curr` pointers to the next node. - If there are less than 2 critical points, return `[-1,-1]`. - Initialize an integer `mini` to `INT_MAX`. - Iterate over the `positions` vector from the second element to the last element. 1. Find the minimum difference between the indexes of the critical points. - Return the minimum and maximum distance between the critical points. ","date":"July 5, 2024","permalink":"/blog/posts/previous-solutions/problem-find-the-minimum-and-maximum-number-of-nodes-between-critical-points/","summary":"Problem Statement Link - Problem 2058 Question A critical point in a linked list is defined as either a local maxima or a local minima.","title":"Problem 2058 Find the Minimum and Maximum Number of Nodes Between Critical Points","type":"posts"},{"content":" Problem Statement Link - Problem 2181 Question You are given the head of a linked list, which contains a series of integers separated by 0\u0026rsquo;s. The beginning and end of the linked list will have Node.val == 0.\nFor every two consecutive 0\u0026rsquo;s, merge all the nodes lying in between them into a single node whose value is the sum of all the merged nodes. The modified list should not contain any 0\u0026rsquo;s.\nReturn the head of the modified linked list.\nExample 1 graph LR A((0))--\u003eB((3)) B--\u003eC((1)) C--\u003eD((0)) D--\u003eE((4)) E--\u003eF((5)) F--\u003eG((2)) G--\u003eH((0)) Input: head = [0,3,1,0,4,5,2,0] Output: [4,11] Explanation: The above figure represents the given linked list. The modified list contains - The sum of the nodes marked in green: 3 + 1 = 4. - The sum of the nodes marked in red: 4 + 5 + 2 = 11. Example 2 graph LR A((0))--\u003eB((1)) B--\u003eC((0)) C--\u003eD((3)) D--\u003eE((0)) E--\u003eF((2)) F--\u003eG((2)) G--\u003eH((0)) Input: head = [0,1,0,3,0,2,2,0] Output: [1,3,4] Explanation: The above figure represents the given linked list. The modified list contains - The sum of the nodes marked in green: 1 = 1. - The sum of the nodes marked in red: 3 = 3. - The sum of the nodes marked in yellow: 2 + 2 = 4. Constraints - The number of nodes in the list is in the range `[3, 2 * 10^5]`. - `0 \u0026lt;= Node.val \u0026lt;= 1000` - There are no two consecutive nodes with` Node.val == 0`. - The beginning and end of the linked list have `Node.val == 0`. Solution /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ class Solution { public: ListNode* mergeNodes(ListNode* head) { std::ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); ListNode* dummy = new ListNode(0); ListNode* prev = dummy; int sum; ListNode* curr = head; while (curr != nullptr) { sum = 0; while (curr != nullptr \u0026amp;\u0026amp; curr-\u0026gt;val == 0) { curr = curr-\u0026gt;next; } while (curr != nullptr \u0026amp;\u0026amp; curr-\u0026gt;val != 0) { sum += curr-\u0026gt;val; curr = curr-\u0026gt;next; } if (sum != 0) { prev-\u0026gt;next = new ListNode(sum); prev = prev-\u0026gt;next; } } return dummy-\u0026gt;next; } }; Complexity Analysis Time Complexity : O(n) Space Complexity : O(1) excluding the space for the output list. Explanation 1. Intuition - We can use the zeroes as the delimiter to merge the nodes in between them. - Use one pointer to traverse the list. If value is zero skip the current node and start adding the values of the nodes until the next zero is encountered. - Once we encounter the next zero, we can add the sum of the nodes to the output list. - Keep repeating the above steps until the end of the list is reached. - Return the output list. 2. Implementation - Initialize a `dummy` node to 0. - Initialize a `prev` pointer to `dummy`. - Initialize a `sum` variable to 0. - Initialize a `curr` pointer to `head`. - Traverse the list until the end of the list is reached. - While traversing the list 1. Skip the current node till the value is zero. 2. Add the values of the nodes until the next zero is encountered. 3. If the sum is not zero then add the sum to the output list. - Return the output list. ","date":"July 4, 2024","permalink":"/blog/posts/previous-solutions/problem-merge-nodes-in-between-zeros/","summary":"Problem Statement Link - Problem 2181 Question You are given the head of a linked list, which contains a series of integers separated by 0\u0026rsquo;s.","title":"Problem 2181 Merge Nodes in Between Zeros","type":"posts"},{"content":" Problem Statement Link - Problem 1509 Question You are given an integer array nums.\nIn one move, you can choose one element of nums and change it to any value.\nReturn the minimum difference between the largest and smallest value of nums after performing at most three moves\nExample 1 Input: nums = [5,3,2,4] Output: 0 Explanation: We can make at most 3 moves. In the first move, change 2 to 3. nums becomes [5,3,3,4]. In the second move, change 4 to 3. nums becomes [5,3,3,3]. In the third move, change 5 to 3. nums becomes [3,3,3,3]. After performing 3 moves, the difference between the minimum and maximum is 3 - 3 = 0 Example 2 Input: nums = [1,5,0,10,14] Output: 1 Explanation: We can make at most 3 moves. In the first move, change 5 to 0. nums becomes [1,0,0,10,14]. In the second move, change 10 to 0. nums becomes [1,0,0,0,14]. In the third move, change 14 to 1. nums becomes [1,0,0,0,1]. After performing 3 moves, the difference between the minimum and maximum is 1 - 0 = 1. It can be shown that there is no way to make the difference 0 in 3 moves. Example 3 Input: nums = [6,6,0,1,1,4,6] Output: 2 Explanation: We can make at most 3 moves. In the first move change 0 to 6 In the second move change 1 to 6 In the third move change 1 to 6 After performing 3 moves, the difference between the minimum and maximum is 6 - 4 = 2 Constraints - 1 \u0026lt;= nums.length \u0026lt;= 10^5 - -10^9 \u0026lt;= nums[i] \u0026lt;= 10^9 Solution class Solution { public: int minDifference(vector\u0026lt;int\u0026gt;\u0026amp; nums) { if(nums.size()\u0026lt;=4) return 0; std::ios::sync_with_stdio(false); sort(nums.begin(),nums.end()); int ans = INT_MAX; for(int i = 0; i \u0026lt;= 3; i++) { ans = min(ans, nums[nums.size() -1 -(3 - i)] - nums[i]); } return ans; } }; Complexity Analysis Time Complexity : O(nlogn) Space Complexity : O(1) Explanation 1. Intuition - To get the minimum difference between the largest and smallest value we have the following logic. - If the size of array is less than or equal to 4 then we can change every element to the same value, hence difference will be 0. - If the size of the array is greater than 4 then we need to sort the array. - Since we have 3 moves it means we can change 3 numbers. - These are the possible combinations we can do to find a lower difference. 1. make the last 3 elements same as first element.(equivalent of removing last 3 elements.) then the difference will be nums[nums.size() - 4] - nums[0] 2. make the first 3 elements same as last element. (equivalent of removing first 3 elements.) then the difference will be nums[nums.size() - 1] - nums[3] 3. make first 2 elements and last element same.(equivalent of removing first 2 elements and last element) then the difference will be nums[nums.size()-2]-nums[2] 4. make the last 2 elements and first element same.(equivalent of removing last 2 elements and first element) then difference will be nums[nums.size()-3]-nums[1] - The answer will be minimum of these 4. 2. Implementation - If the size of `nums` is less than or equal to 4 then return 0. - Else sort the array. - Initialize `ans` to `INT_MAX`. - Iterate from 0 to 3. - Update `ans` to minimum of `ans` and `nums[nums.size() -1 -(3 - i)] - nums[i]`. - This will calculate the above mentioned 4 combinations and return the minimum difference. ","date":"July 3, 2024","permalink":"/blog/posts/previous-solutions/problem-minimum-difference-between-largest-and-smallest-value-in-three-moves/","summary":"Problem Statement Link - Problem 1509 Question You are given an integer array nums.","title":"Problem 1509 Minimum Difference Between Largest and Smallest Value in Three Moves","type":"posts"},{"content":" Problem Statement Link - Problem 350 Question Given two integer arrays nums1 and nums2, return an array of their intersection. Each element in the result must appear as many times as it shows in both arrays and you may return the result in any order.\nExample 1 Input: nums1 = [1,2,2,1], nums2 = [2,2] Output: [2,2] Example 2 Input: nums1 = [4,9,5], nums2 = [9,4,9,8,4] Output: [4,9] Explanation: [9,4] is also accepted.r Constraints - 1 \u0026lt;= nums1.length, nums2.length \u0026lt;= 1000 - 0 \u0026lt;= nums1[i], nums2[i] \u0026lt;= 1000 Solution // Iterative Solution class Solution { public: vector\u0026lt;int\u0026gt; intersect(vector\u0026lt;int\u0026gt;\u0026amp; nums1, vector\u0026lt;int\u0026gt;\u0026amp; nums2) { vector\u0026lt;int\u0026gt;freq(1001,0); for(int it:nums1){ freq[it]++; } vector\u0026lt;int\u0026gt;ans; for(int it:nums2){ if(freq[it]\u0026gt;0){ ans.push_back(it); freq[it]--; } } return ans; } }; Complexity Analysis Time Complexity : O(n) Space Complexity : O(n) Explanation 1. Intuition - We just need to copy the repeated elements from both arrays to the resultant array. - We can use a hashmap to store the frequency of elements in the first array. - Then we can iterate over the second array and check if the element is present in the hashmap. - If it is present, we can copy it to the resultant array and decrement the frequency in the hashmap. - Finally, we return the resultant array. 2. Implementation - Initialize a hashmap `freq` to store the frequency of elements in the first array. - Iterate over the first array and store the frequency of each element in the hashmap. - Initialize an empty vector `ans` to store the resultant array. - Iterate over the second array and check if the element is present in the hashmap. - If it is present, copy it to the resultant array and decrement the frequency in the hashmap. - Finally, return the resultant array. Binary Search Solution // Binary Search Solution class Solution { public: static vector\u0026lt;int\u0026gt; intersect(vector\u0026lt;int\u0026gt;\u0026amp; nums1, vector\u0026lt;int\u0026gt;\u0026amp; nums2) { if (nums1.size()\u0026lt;nums2.size()) return intersect(nums2, nums1); sort(nums1.begin(), nums1.end()); sort(nums2.begin(), nums2.end()); int sz=0, n1=nums1.size(), n2=nums2.size(); for (int i = 0, j = 0; i \u0026lt; n1 \u0026amp;\u0026amp; j \u0026lt; n2;) { int x=nums1[i], y=nums2[j]; if (x==y){ nums2[sz++] = x; i++; j++; } else if (x\u0026lt;y)// move i such that nums1[i]\u0026gt;=y i=lower_bound(nums1.begin()+i+1, nums1.end(), y)-nums1.begin(); else // x\u0026gt;y. Move j such that nums2[j]\u0026gt;=x j=lower_bound(nums2.begin()+j+1, nums2.end(), x)-nums2.begin(); } nums2.resize(sz); return nums2; } }; Explanation - We first sort both arrays. - We then iterate over both arrays using two pointers. - If the elements at the two pointers are equal, we copy the element to the resultant array and increment both pointers. - If the element in the first array is less than the element in the second array, we move the first pointer to the next element that is greater than or equal to the element in the second array. - If the element in the first array is greater than the element in the second array, we move the second pointer to the next element that is greater than or equal to the element in the first array. - Finally, we resize the resultant array to the size of the intersection and return it. Time Complexity: O(nlogn) Space Complexity: O(1) ","date":"July 2, 2024","permalink":"/blog/posts/previous-solutions/problem-intersection-of-two-arrays-ii/","summary":"Problem Statement Link - Problem 350 Question Given two integer arrays nums1 and nums2, return an array of their intersection.","title":"Problem 350 Intersection of Two Arrays II","type":"posts"},{"content":" Problem Statement Link - Problem 1550 Question Given an integer array arr, return true if there are three consecutive odd numbers in the array. Otherwise, return false.\nExample 1 Input: arr = [2,6,4,1] Output: false Explanation: There are no three consecutive odds. Example 2 Input: arr = [1,2,34,3,4,5,7,23,12] Output: true Explanation: [5,7,23] are three consecutive odds. Constraints - `1 \u0026lt;= arr.length \u0026lt;= 1000` - `1 \u0026lt;= arr[i] \u0026lt;= 1000` Solution class Solution { public: bool threeConsecutiveOdds(vector\u0026lt;int\u0026gt;\u0026amp; arr) { if(arr.size()==1||arr.size()==2) return false; for(int i=0;i\u0026lt;arr.size()-2;i++) { if(arr[i]%2!=0) { if(arr[i+1]%2 !=0 \u0026amp;\u0026amp; arr[i+2]%2 !=0) { return true; } } } return false; } }; Complexity Analysis Time Complexity : O(n) Space Complexity : O(1) Explanation 1. Intuition - We just need to check if there are three consecutive odd numbers in the array. - If we find such a sequence, we return true. - Otherwise, we return false. - If we find the current number to be odd check if next two numbers are also odd. 2. Implementation - If the size of the array is less than 3, return false. - Iterate from `0` to `n-2`. - Check if `arr[i]` is odd. - If it is odd, check if `arr[i+1]` and `arr[i+2]` are also odd. - If they are, return true. - If no such sequence is found, return false. ","date":"July 1, 2024","permalink":"/blog/posts/previous-solutions/problem-three-consecutive-odds/","summary":"Problem Statement Link - Problem 1550 Question Given an integer array arr, return true if there are three consecutive odd numbers in the array.","title":"Problem 1550 Three Consecutive Odds","type":"posts"},{"content":" Problem Statement Link - Problem 226 Question Given the root of a binary tree, invert the tree and return its root.\nExample 1 Input: root = [4,2,7,1,3,6,9] Output: [4,7,2,9,6,3,1] Input: graph TD 4 --- 2 4 --- 7 2 --- 1 2 --- 3 7 --- 6 7 --- 9 Output : graph TD 4 --- 7 4 --- 2 7 --- 9 7 --- 6 2 --- 3 2 --- 1 Example 2 Input: root = [2,1,3] Output: [2,3,1] Input : graph TD 2 --- 1 2 --- 3 Output : graph TD 2 --- 3 2 --- 1 Example 3 Input: root = [] Output: [] Constraints - The number of nodes in the tree is in the range `[0, 100]`. - `-100 \u0026lt;= Node.val \u0026lt;= 100` Solution /* * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: void invert(TreeNode* root) { if(root) { swap(root-\u0026gt;left,root-\u0026gt;right); invert(root-\u0026gt;left); invert(root-\u0026gt;right); } else return; } TreeNode* invertTree(TreeNode* root) { invert(root); return root; } }; Complexity Analysis Time Complexity : O(N) Space Complexity : O(N) Explanation 1. Intuition - We need to produce a mirror image of the binary tree. - To do this we just need to swap the left and right subtrees recursively. 2. Implementation - Define a helper function `invert` which takes a `TreeNode*` as input. - If the root is not null, swap the left and right subtrees. - Recursively call the `invert` function on the left and right subtrees. - Return the root. ","date":"June 30, 2024","permalink":"/blog/posts/previous-solutions/problem-invert-binary-tree/","summary":"Problem Statement Link - Problem 226 Question Given the root of a binary tree, invert the tree and return its root.","title":"Problem 226 Invert Binary Tree","type":"posts"},{"content":" Problem Statement Link - Problem 2192 Question You are given a positive integer n representing the number of nodes of a Directed Acyclic Graph (DAG). The nodes are numbered from 0 to n - 1 (inclusive).\nYou are also given a 2D integer array edges, where edges[i] = [fromi, toi] denotes that there is a unidirectional edge from fromi to toi in the graph.\nReturn a list answer, where answer[i] is the list of ancestors of the ith node, sorted in ascending order.\nA node u is an ancestor of another node v if u can reach v via a set of edges.\nExample 1 Input: n = 8, edgeList = [[0,3],[0,4],[1,3],[2,4],[2,7],[3,5],[3,6],[3,7],[4,6]] Output: [[],[],[],[0,1],[0,2],[0,1,3],[0,1,2,3,4],[0,1,2,3]] Explanation: The above diagram represents the input graph. - Nodes 0, 1, and 2 do not have any ancestors. - Node 3 has two ancestors 0 and 1. - Node 4 has two ancestors 0 and 2. - Node 5 has three ancestors 0, 1, and 3. - Node 6 has five ancestors 0, 1, 2, 3, and 4. - Node 7 has four ancestors 0, 1, 2, and 3. graph TD 0 --\u003e 3 0 --\u003e 4 1 --\u003e 3 2 --\u003e 4 2 --\u003e 7 3 --\u003e 5 3 --\u003e 6 3 --\u003e 7 4 --\u003e 6 Example 2 Input: n = 5, edgeList = [[0,1],[0,2],[0,3],[0,4],[1,2],[1,3],[1,4],[2,3],[2,4],[3,4]] Output: [[],[0],[0,1],[0,1,2],[0,1,2,3]] Explanation: The above diagram represents the input graph. - Node 0 does not have any ancestor. - Node 1 has one ancestor 0. - Node 2 has two ancestors 0 and 1. - Node 3 has three ancestors 0, 1, and 2. - Node 4 has four ancestors 0, 1, 2, and 3. graph TD 0 --\u003e 1 0 --\u003e 2 0 --\u003e 3 0 --\u003e 4 1 --\u003e 2 1 --\u003e 3 1 --\u003e 4 2 --\u003e 3 2 --\u003e 4 3 --\u003e 4 Constraints - `1 \u0026lt;= n \u0026lt;= 1000` - `0 \u0026lt;= edges.length \u0026lt;= min(2000, n * (n - 1) / 2)` - `edges[i].length == 2` - `0 \u0026lt;= fromi, toi \u0026lt;= n - 1` - `fromi != toi` - There are no duplicate edges. - The graph is **directed** and **acyclic** Solution class Solution { public: void dfs(vector\u0026lt;bool\u0026gt;\u0026amp; visited, vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; adjList, vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; ancestor ,int parent, int curr) { visited[curr] = true; for( int forward:adjList[curr]) { if(!visited[forward]) { ancestor[forward].push_back(parent); dfs(visited,adjList,ancestor,parent,forward); } } } vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; getAncestors(int n, vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; edges) { std::ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; adjList(n); vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; ancestor(n); for (const auto\u0026amp; edge : edges) { adjList[edge[0]].push_back(edge[1]); } for(int i = 0; i\u0026lt;n; i++){ vector\u0026lt;bool\u0026gt;visited(n,false); dfs(visited,adjList,ancestor,i,i); } //for(int i = 0;i \u0026lt;n; i++) //sort(ancestor[i].begin(),ancestor[i].end()); return ancestor; } }; Complexity Analysis Time Complexity : O(n) - where n is the number of nodes in the graph Space Complexity : O(n) - where n is the number of nodes in the graph Explanation 1. Intuition - We need to find the ancestors of each node in the graph and store it in sorted order in form of a list. - To find the ancestors of a node we can perform a DFS traversal of the graph. - We can start the DFS traversal from each node and keep track of the parent node. - For each children nodes which is reachable from the current node, we can add the parent node as an ancestor. - To prevent multiple visits to the same node we can use a visited array. 2. Implementation - We can create an adjacency list `adjList` to store the graph. - We can create a 2D vector `ancestor` to store the ancestors of each node. - Now we will perform the DFS traversal of the graph. - For each node from `0` to `n-1` , create a new `visted` array and call the `dfs` function. - DFS Function - Input : `visited` array, `adjList`, `ancestor` array, `parent` node, `current` node - Output : void - mark the current node as visited - for each forward node reachable from the current node - if the forward node is not visited - add the parent node as an ancestor of the forward node - call the dfs function recursively for the forward node 3. Dry Run - Let\u0026#39;s dry run the first example to understand the solution better. - We have `n = 8` and `edgeList = [[0,3],[0,4],[1,3],[2,4],[2,7],[3,5],[3,6],[3,7],[4,6]]` - The adjaceny list is as follows: - 0 -\u0026gt; 3,4 - 1 -\u0026gt; 3 - 2 -\u0026gt; 4,7 - 3 -\u0026gt; 5,6,7 - 4 -\u0026gt; 6 - 5 -\u0026gt; - 6 -\u0026gt; - 7 -\u0026gt; - We will start the DFS traversal from each node and find the ancestors. - For node 0, the ancestors are [] - For node 1, the ancestors are [] - For node 2, the ancestors are [] - For node 3, the ancestors are [0,1] - For node 4, the ancestors are [0,2] - For node 5, the ancestors are [0,1,3] - For node 6, the ancestors are [0,1,2,3,4] - For node 7, the ancestors are [0,1,2,3] The solution automatically gives the output in sorted form because the order of parent nodes is maintained while performing the DFS traversal.\n","date":"June 29, 2024","permalink":"/blog/posts/previous-solutions/problem-all-ancestors-of-a-node-in-a-dag/","summary":"Problem Statement Link - Problem 2192 Question You are given a positive integer n representing the number of nodes of a Directed Acyclic Graph (DAG).","title":"Problem 2192 All Ancestors of a Node in a DAG","type":"posts"},{"content":" Problem Statement Link - Problem 2285 Question You are given an integer n denoting the number of cities in a country. The cities are numbered from 0 to n - 1.\nYou are also given a 2D integer array roads where roads[i] = [ai, bi] denotes that there exists a bidirectional road connecting cities ai and bi.\nYou need to assign each city with an integer value from 1 to n, where each value can only be used once. The importance of a road is then defined as the sum of the values of the two cities it connects.\nReturn the maximum total importance of all roads possible after assigning the values optimally.\nExample 1 Input: n = 5, roads = [[0,1],[1,2],[2,3],[0,2],[1,3],[2,4]] Output: 43 Explanation: The figure above shows the country and the assigned values of [2,4,5,3,1]. - The road (0,1) has an importance of 2 + 4 = 6. - The road (1,2) has an importance of 4 + 5 = 9. - The road (2,3) has an importance of 5 + 3 = 8. - The road (0,2) has an importance of 2 + 5 = 7. - The road (1,3) has an importance of 4 + 3 = 7. - The road (2,4) has an importance of 5 + 1 = 6. The total importance of all roads is 6 + 9 + 8 + 7 + 7 + 6 = 43. It can be shown that we cannot obtain a greater total importance than 43. 1 / | \\ 0 --|-- 2 -- 4 \\ | / 3 Example 2 Input: n = 5, roads = [[0,3],[2,4],[1,3]] Output: 20 Explanation: The figure above shows the country and the assigned values of [4,3,2,5,1]. - The road (0,3) has an importance of 4 + 5 = 9. - The road (2,4) has an importance of 2 + 1 = 3. - The road (1,3) has an importance of 3 + 5 = 8. The total importance of all roads is 9 + 3 + 8 = 20. It can be shown that we cannot obtain a greater total importance than 20. 3 2 / \\ | 0 1 4 Constraints - `2 \u0026lt;= n \u0026lt;= 5 * 10^4` - `1 \u0026lt;= roads.length \u0026lt;= 5 * 10^4` - `roads[i].length == 2` - `0 \u0026lt;= ai, bi \u0026lt;= n - 1` - `ai != bi` - There are no duplicate `roads`. Solution class Solution { public: long long maximumImportance(int n, vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; roads) { std::ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); vector\u0026lt;long long int\u0026gt;freq(n,0); for(const vector\u0026lt;int\u0026gt;\u0026amp; it:roads) { freq[it[0]]++; freq[it[1]]++; } sort(freq.begin(),freq.end()); long long int ans = 0; /*priority_queue\u0026lt;pair\u0026lt;long long int,int\u0026gt;\u0026gt;pq; for(int i = 0;i\u0026lt;n;i++) pq.push({freq[i],i}); for(int i = n;i\u0026gt;0;i--) { ans += pq.top().first * i; pq.pop(); }*/ for(int i =n;i\u0026gt;0;i--) { ans+=freq[i-1]*i; } return ans; } }; Complexity Analysis Time Complexity : O(nlogn) Space Complexity : O(n) Explanation 1. Intuition - Looking at the problem we can see that importance of a node is directly proportional to the number of roads connected to it. - So the node with highest number of roads must have higher importance. - We know that each edge will connect 2 nodes and there are no duplicate edges. - We can get the maximum sum when we assign the importance from `n` to `1` in the order of highly connected nodes to sparsely connected nodes. 2. Implementation - Initialize a frequency vector `freq` of size `n` with all elements as `0`. - Iterate over the `roads` vector and increment the frequency of the nodes connected by the road. - Sort the `freq` vector in ascending order. - Initialize a variable `ans` of datatype `long long` to store the maximum importance. - Iterate from the last element of the `freq` vector to the first element (`i=n to i=1`). - Here `i` represents the importance of the node. - `freq[i-1]` represents the number of roads connected to the `i-1`th node. - Add the product of `freq[i-1]` and `i` to the `ans` - Return the `ans`. This is a relatively simple problem where we need to assign importance to the nodes based on the number of roads connected to them. We can get the maximum importance by assigning the importance from n to 1 in the order of highly connected nodes to sparsely connected nodes.\n","date":"June 28, 2024","permalink":"/blog/posts/previous-solutions/problem-maximum-total-importance-of-roads/","summary":"Problem Statement Link - Problem 2285 Question You are given an integer n denoting the number of cities in a country.","title":"Problem 2285 Maximum Total Importance of Roads","type":"posts"},{"content":" Problem Statement Link - Problem 1791 Question There is an undirected star graph consisting of n nodes labeled from 1 to n. A star graph is a graph where there is one center node and exactly n - 1 edges that connect the center node with every other node.\nYou are given a 2D integer array edges where each edges[i] = [ui, vi] indicates that there is an edge between the nodes ui and vi. Return the center of the given star graph.\nExample 1 Input: edges = [[1,2],[2,3],[4,2]] Output: 2 Explanation: As shown in the figure above, node 2 is connected to every other node, so 2 is the center. graph TD A((1)) --- B((2)) B --- C((3)) D((4)) --- B Example 2 Input: edges = [[1,2],[5,1],[1,3],[1,4]] Output: 1 graph TD A((2)) --- B((1)) A --- C((3)) A --- D((4)) E((5)) --- A Constraints - `3 \u0026lt;= n \u0026lt;= 10^5` - `edges.length == n - 1` - `edges[i].length == 2` - `1 \u0026lt;= ui, vi \u0026lt;= n` - `ui != vi` - The given `edges` represent a valid star graph. Solution class Solution { public: int findCenter(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; edges) { std::ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); return edges[0][0]==edges[1][0] || edges[0][0] == edges[1][1]?edges[0][0]:edges[0][1]; } }; Complexity Analysis Time Complexity : O(1) Space Complexity : O(1) Explanation 1. Intuition - Since it\u0026#39;s a star graph it means that the center node will have the maximum degree. - `Also none of the other nodes will have degree more than 1.` - So we can just check the first two edges and return the node which is common in both the edges. 2. Implementation - We can just check the first two edges and return the node which is common in both the edges. Simple graph question which teaches the characteristics of a star graph.\n","date":"June 27, 2024","permalink":"/blog/posts/previous-solutions/problem-find-center-of-star-graph/","summary":"Problem Statement Link - Problem 1791 Question There is an undirected star graph consisting of n nodes labeled from 1 to n.","title":"Problem 1791 Find Center of Star Graph","type":"posts"},{"content":" Problem Statement Link - Problem 1382 Question Given the root of a binary search tree, return a balanced binary search tree with the same node values. If there is more than one answer, return any of them.\nA binary search tree is balanced if the depth of the two subtrees of every node never differs by more than 1.\nExample 1 Input: root = [1,null,2,null,3,null,4,null,null] Output: [2,1,3,null,null,null,4] Explanation: This is not the only correct answer, [3,1,4,null,2] is also correct. Input graph TD A((1)) --\u003e B((2)) B --\u003e C((3)) C--\u003e D((4)) Output graph TD A((2)) --\u003e B((1)) A --\u003e C((3)) C --\u003e D((4)) Example 2 Input: root = [2,1,3] Output: [2,1,3] Input graph TD A((2)) --\u003e B((1)) A --\u003e C((3)) Output graph TD A((2)) --\u003e B((1)) A --\u003e C((3)) Constraints The number of nodes in the tree is in the range [1, 10^4]. 1 \u0026lt;= Node.val \u0026lt;= 10^5 Solution class Solution { public: TreeNode* balanceBST(TreeNode* root) { vector\u0026lt;int\u0026gt; sortedElements; std::ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); inOrderTraversal(root, sortedElements); return buildBalancedBST(sortedElements, 0, sortedElements.size() - 1); } private: void inOrderTraversal(TreeNode* node, vector\u0026lt;int\u0026gt;\u0026amp; sortedElements) { if (!node) { return; } inOrderTraversal(node-\u0026gt;left, sortedElements); sortedElements.push_back(node-\u0026gt;val); inOrderTraversal(node-\u0026gt;right, sortedElements); } TreeNode* buildBalancedBST(const vector\u0026lt;int\u0026gt;\u0026amp; elements, int start, int end) { if (start \u0026gt; end) { return nullptr; } int mid = start + (end - start) / 2; TreeNode* node = new TreeNode(elements[mid]); node-\u0026gt;left = buildBalancedBST(elements, start, mid - 1); node-\u0026gt;right = buildBalancedBST(elements, mid + 1, end); return node; } }; Complexity Analysis Time Complexity : O(n) Space Complexity : O(n) Explanation 1. Intuition - The given input is already sorted so if we perform an inorder traversal we will get the sorted elements. - To build a balanced BST we need the root value to be from middle of the sorted elements. - Tree can be recursively built by dividing the sorted elements into two halves. 2. Implementation - Using the `inOrderTraversal` function we can get the sorted elements. - Using the `buildBalancedBST` function we can build the balanced BST. - The `buildBalancedBST` function is a recursive function that takes the sorted elements and the start and end index. - The mid value is calculated as the middle of the start and end index. - The mid value is used as the root value and the left and right subtrees are recursively built. - The base case is when the start index is greater than the end index. - Then return `nullptr`. ","date":"June 26, 2024","permalink":"/blog/posts/previous-solutions/problem-balance-a-binary-search-tree/","summary":"Problem Statement Link - Problem 1382 Question Given the root of a binary search tree, return a balanced binary search tree with the same node values.","title":"Problem 1382 Balance a Binary Search Tree","type":"posts"},{"content":" Problem Statement Link - Problem 1038 Question Given the root of a Binary Search Tree (BST), convert it to a Greater Tree such that every key of the original BST is changed to the original key plus the sum of all keys greater than the original key in BST.\nAs a reminder, a binary search tree is a tree that satisfies these constraints:\nThe left subtree of a node contains only nodes with keys less than the node\u0026rsquo;s key. The right subtree of a node contains only nodes with keys greater than the node\u0026rsquo;s key. Both the left and right subtrees must also be binary search trees. Note The question is a bit confusing. Lets De-Leetcodify it. We need to convert the given Binary Search Tree to a Greater Sum Tree. In a Greater Sum Tree, every node\u0026rsquo;s value is changed to the sum of all nodes greater than the node\u0026rsquo;s value in the BST. To convert the BST to Greater Sum Tree, we need to do a reverse inorder traversal of the BST. Example 1 Input: root = [4,1,6,0,2,5,7,null,null,null,3,null,null,null,8] Output: [30,36,21,36,35,26,15,null,null,null,33,null,null,null,8] Input: graph TD A((4)) --\u003e B((1)) A --\u003e C((6)) B --\u003e D((0)) B --\u003e E((2)) C --\u003e F((5)) C --\u003e G((7)) E --\u003e H((3)) G --\u003e I((8)) Output: graph TD A((30)) --\u003e B((36)) A --\u003e C((21)) B --\u003e D((36)) B --\u003e E((35)) C --\u003e F((26)) C --\u003e G((15)) E --\u003e H((33)) G --\u003e I((8)) Example 2 Input: root = [0,null,1] Output: [1,null,1] Input: graph TD A((0)) --\u003e C((1)) Output: graph TD A((1)) --\u003e C((1)) Constraints The number of nodes in the tree is in the range [1, 100]. 0 \u0026lt;= Node.val \u0026lt;= 100 All the values in the tree are unique. Solution /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: int sum = 0; TreeNode* helper(TreeNode* root) { if(root == nullptr) return root; helper(root-\u0026gt;right); sum+=root-\u0026gt;val; root-\u0026gt;val=sum; helper(root-\u0026gt;left); return root; } TreeNode* bstToGst(TreeNode* root) { std::ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); return helper(root); } }; Complexity Analysis Time Complexity : O(n) Space Complexity : O(n) Explanation 1. Intuition - To generate a Greater Sum Tree, we need to do a reverse inorder traversal of the BST. - What is a reverse inorder traversal? - In a reverse inorder traversal, we visit the right subtree first, then the root, and then the left subtree. - We can use this to visit the right most leaf node first, then the parent node, and then the left child node. - Now we can obtain the sum of all the nodes greater than the current node. 2. Implementation - Define a global variable `sum` to store the sum of all the nodes greater than the current node. - Define a `helper` function that takes the `root` node as an argument. - In the `helper` function, check if the `root` is `nullptr`, if so return the `root`. - Recursively call the `helper` function with the right child of the `root`. - Add the value of the `root` to the `sum`. - Update the value of the `root` to the `sum`. - Recursively call the `helper` function with the left child of the `root`. - Return the `root`. This problem is exactly same as the Problem 538 . The only difference is the name of the function. The problem statement is exactly the same. So, the solution is also the same.\n","date":"June 25, 2024","permalink":"/blog/posts/previous-solutions/problem-binary-search-tree-to-greater-sum-tree/","summary":"Problem Statement Link - Problem 1038 Question Given the root of a Binary Search Tree (BST), convert it to a Greater Tree such that every key of the original BST is changed to the original key plus the sum of all keys greater than the original key in BST.","title":"Problem 1038 Binary Search Tree to Greater Sum Tree","type":"posts"},{"content":" Problem Statement Link - Problem 1552 Question In the universe Earth C-137, Rick discovered a special form of magnetic force between two balls if they are put in his new invented basket. Rick has n empty baskets, the ith basket is at position[i], Morty has m balls and needs to distribute the balls into the baskets such that the minimum magnetic force between any two balls is maximum.\nRick stated that magnetic force between two different balls at positions x and y is |x - y|.\nGiven the integer array position and the integer m. Return the required force.\nNote This problem explaination is absolute trash. Lets De-Leetcodify it. Lets say we have n baskets and m balls. We need to distribute the m balls in the n baskets such that the minimum distance between any two balls is maximum. We need to find the maximum distance between any two balls such that we can distribute the balls in the baskets such that the minimum distance between any two balls is maximum. Example 1 Input: position = [1,2,3,4,7], m = 3 Output: 3 Explanation: Distributing the 3 balls into baskets 1, 4 and 7 will make the magnetic force between ball pairs [3, 3, 6]. The minimum magnetic force is 3. We cannot achieve a larger minimum magnetic force than 3. Example 2 Input: position = [5,4,3,2,1,1000000000], m = 2 Output: 999999999 Explanation: We can use baskets 1 and 1000000000 Constraints - `n == position.length` - `2 \u0026lt;= n \u0026lt;= 10^5` - `1 \u0026lt;= position[i] \u0026lt;= 10^9` - All integers in `position` are `distinct`. - `2 \u0026lt;= m \u0026lt;= position.length` Solution class Solution { public: int maxDistance(vector\u0026lt;int\u0026gt;\u0026amp; position, int m) { sort(position.begin(), position.end()); int l = 1, r = position[position.size()-1]; int ans = -1; while(l \u0026lt;= r) { int mid = l + (r - l) / 2; int lastPosition = position[0], balls = 1; for(int i = 1; i \u0026lt; position.size(); i++) { if(position[i] - lastPosition \u0026gt;= mid) { lastPosition = position[i]; balls++; } } if(balls \u0026gt;= m) { ans = mid; l = mid + 1; } else { r = mid - 1; } } return ans; } }; Complexity Analysis Time Complexity : O(nlogn) Space Complexity : O(1) Explanation 1. Intuition - Lets find out a strategy to accomplish this question. - First find the maximum possible distance between any two balls. - Then first place the first ball at the first position. - Then try to place the next ball at the maximum possible distance from the first ball. - If we can place all the balls at the maximum possible distance then we can say that the maximum possible distance is the answer. - If we cannot place all the balls at the maximum possible distance then we need to reduce the maximum possible distance and try again. 2. Implementation - Sort the `position` array in increasing order. - Set the `l` to 1 and `r` to the last element of the `position` array. - Set the `ans` to -1. - Run a binary search loop until `l` is less than or equal to `r`. - Calculate the `mid` as `l + (r - l) / 2`. - Set the `lastPosition` to the first element of the `position` array and `balls` to 1. - The variable `lastPosition` will store the last position where we placed the ball. - `balls` is set to `1` because we have already placed the first ball. - Run a loop from `1` to `position.size()`. - If the difference between the current position and the `lastPosition` is greater than or equal to `mid` then we can place the ball at the current position. - This will tell us in which position we can place the ball. - Update the value of `lastPosition` to the current position and increment the value of `balls`. - Once the loop is over check if the value of `balls` is greater than or equal to `m`. - If yes then set the `ans` to `mid` and set `l` to `mid + 1`. - This will check if we can increase the distance between the balls. - If no then set `r` to `mid - 1`. - This will check if we can decrease the distance between the balls. - Finally return the value of `ans`. This problem is similar to yesterday\u0026rsquo;s problem. We are trying to find the maximum distance between any two balls such that we can place the balls in the baskets such that the minimum distance between any two balls is maximum. We are using binary search to find the maximum distance between any two balls. This is a very good example of binary search on answer.\n","date":"June 20, 2024","permalink":"/blog/posts/previous-solutions/problem-magnetic-force-between-two-balls/","summary":"Problem Statement Link - Problem 1552 Question In the universe Earth C-137, Rick discovered a special form of magnetic force between two balls if they are put in his new invented basket.","title":"Problem 1552 Magnetic Force Between Two Balls","type":"posts"},{"content":" Problem Statement Link - Problem 1482 Question You are given an integer array bloomDay, an integer m and an integer k.\nYou want to make m bouquets. To make a bouquet, you need to use k adjacent flowers from the garden.\nThe garden consists of n flowers, the ith flower will bloom in the bloomDay[i] and then can be used in exactly one bouquet.\nReturn the minimum number of days you need to wait to be able to make m bouquets from the garden. If it is impossible to make m bouquets return -1.\nNote Problem description hides 2 crucial points\nwe need to collect m bouquests on the SAME given day. Can\u0026rsquo;t collect m-x bouqets on some day, then collect more on another, till we reach m. This can be understood only from the examples. Once flower bloomed but we can\u0026rsquo;t collect m bouquets -\u0026gt; that flower stays in the garden in the \u0026lsquo;bloomed\u0026rsquo; status. Solution is inspired from Problem 278 Example 1 Input: bloomDay = [1,10,3,10,2], m = 3, k = 1 Output: 3 Explanation: Let us see what happened in the first three days. x means flower bloomed and _ means flower did not bloom in the garden. We need 3 bouquets each should contain 1 flower. After day 1: [x, _, _, _, _] // we can only make one bouquet. After day 2: [x, _, _, _, x] // we can only make two bouquets. After day 3: [x, _, x, _, x] // we can make 3 bouquets. The answer is 3. Example 2 Input: bloomDay = [1,10,3,10,2], m = 3, k = 2 Output: -1 Explanation: We need 3 bouquets each has 2 flowers, that means we need 6 flowers. We only have 5 flowers so it is impossible to get the needed bouquets and we return -1. Example 3 Input: bloomDay = [7,7,7,7,12,7,7], m = 2, k = 3 Output: 12 Explanation: We need 2 bouquets each should have 3 flowers. Here is the garden after the 7 and 12 days: After day 7: [x, x, x, x, _, x, x] We can make one bouquet of the first three flowers that bloomed. We cannot make another bouquet from the last three flowers that bloomed because they are not adjacent. After day 12: [x, x, x, x, x, x, x] It is obvious that we can make two bouquets in different ways. Constraints - `bloomDay.length == n` - `1 \u0026lt;= n \u0026lt;= 10^5` - `1 \u0026lt;= bloomDay[i] \u0026lt;= 10^9` - `1 \u0026lt;= m \u0026lt;= 10^6` - `1 \u0026lt;= k \u0026lt;= n` Solution class Solution { public: int minDays(vector\u0026lt;int\u0026gt;\u0026amp; bloomDay, int m, int k) { int l = 1, r = 1e9; int ans = -1; while(l \u0026lt;= r) { int mid = l + (r - l) / 2; int consecutiveLength = 0, boquets = 0; for(int i = 0; i \u0026lt; bloomDay.size(); i++) { if(bloomDay[i] \u0026lt;= mid) { consecutiveLength++; if(consecutiveLength \u0026gt;= k) { consecutiveLength = 0; boquets++; } } else { consecutiveLength = 0; } } if(boquets \u0026gt;= m) { ans = mid; r = mid - 1; } else { l = mid + 1; } } return ans; } }; Complexity Analysis Time Complexity : O(nlogn) Space Complexity : O(1) Explanation 1. Intuition - If we know how many flowers are blooming on a given day, we can easily calculate the number of bouquets we can make. - Ask this question: Is `x` days sufficient to make `m` bouquets? - If yes it means that we can make `m` bouquets in `x+t` days where `t` is any number of days greater than `x`. - Hence we need to find the minimum number of days to make `m` bouquets. 2. Implementation - Initialize `l` and `r` as 1 and 1e9 respectively. - They represent the minimum and maximum number of days required to make `m` bouquets. (according to the constraints) - Initialize `ans` as -1. - This will represent the minimum number of days required to make `m` bouquets. - Run a while loop till `l \u0026lt;= r`. - Calculate the mid value as `l + (r - l) / 2`. - Initialize `consecutiveLength` and `boquets` as 0. - Run a loop for all the flowers in the garden. - If the flower blooms on the `mid` day, increment the `consecutiveLength`. This represents the number of flowers blooming consecutively. - If the `consecutiveLength` is greater than or equal to `k`, reset the `consecutiveLength` and increment the `boquets`. - If the flower does not bloom on the `mid` day, reset the `consecutiveLength`. - Once the for loop ends, check if the number of `boquets` is greater than or equal to `m`. - If yes, update the `ans` as `mid` and update `r` as `mid - 1`. - This shows that we can make `m` bouquets in `mid` days. So we need to check if they can be made in less than `mid` days. - If no, update `l` as `mid + 1`. - This shows that we cannot make `m` bouquets in `mid` days. So we need to check if they can be made in more than `mid` days. - Return the `ans`. This is a very good problem to understand the power of binary search. In this problem we use binary search to find the point after which the required condition will always be true. We are trying to use the leftmost binary search to find the minimum number of days required to make m bouquets. This is a very good example of binary search on answer.\n","date":"June 19, 2024","permalink":"/blog/posts/previous-solutions/problem-minimum-number-of-days-to-make-m-bouquets/","summary":"Problem Statement Link - Problem 1482 Question You are given an integer array bloomDay, an integer m and an integer k.","title":"Problem 1482 Minimum Number of Days to Make M Bouquets","type":"posts"},{"content":" Problem Statement Link - Problem 826 Question You have n jobs and m workers. You are given three arrays: difficulty, profit, and worker where:\ndifficulty[i] and profit[i] are the difficulty and the profit of the ith job, and\nworker[j] is the ability of jth worker (i.e., the jth worker can only complete a job with difficulty at most worker[j]). Every worker can be assigned at most one job, but one job can be completed multiple times.\nFor example, if three workers attempt the same job that pays $1, then the total profit will be $3. If a worker cannot complete any job, their profit is $0. Return the maximum profit we can achieve after assigning the workers to the jobs.\nExample 1 Input: difficulty = [2,4,6,8,10], profit = [10,20,30,40,50], worker = [4,5,6,7] Output: 100 Explanation: Workers are assigned jobs of difficulty [4,4,6,6] and they get a profit of [20,20,30,30] separately. Example 2 Input: difficulty = [85,47,57], profit = [24,66,99], worker = [40,25,25] Output: 0 Constraints - n == difficulty.length - n == profit.length - m == worker.length - 1 \u0026lt;= n, m \u0026lt;= 10^4 - 1 \u0026lt;= difficulty[i], profit[i], worker[i] \u0026lt;= 10^5 Solution class Solution { public: int maxProfitAssignment(vector\u0026lt;int\u0026gt;\u0026amp; difficulty, vector\u0026lt;int\u0026gt;\u0026amp; profit, vector\u0026lt;int\u0026gt;\u0026amp; worker) { std::ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); vector\u0026lt;pair\u0026lt;int,int\u0026gt;\u0026gt;pq(profit.size()); for (int i = 0; i \u0026lt; profit.size(); i++) { pq[i]= {profit[i], difficulty[i]} ; } int wsize = worker.size(), pqsize = pq.size(),i =0, j=0, ans = 0; sort(worker.begin(), worker.end(), greater\u0026lt;int\u0026gt;()); sort(pq.begin(),pq.end(),greater\u0026lt;pair\u0026lt;int,int\u0026gt;\u0026gt;()); while (i \u0026lt; wsize \u0026amp;\u0026amp; j \u0026lt; pqsize) { while(j\u0026lt;pqsize \u0026amp;\u0026amp; pq[j].second\u0026gt;worker[i]) j++; if(i == wsize || j == pqsize) break; while(i\u0026lt;wsize \u0026amp;\u0026amp; j\u0026lt;pqsize \u0026amp;\u0026amp; pq[j].second \u0026lt;= worker[i]) { // cout\u0026lt;\u0026lt;j\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;\u0026#34; \u0026#34;\u0026lt;\u0026lt;pq[j].first\u0026lt;\u0026lt;endl; ans+=pq[j].first; i++; } } return ans; } }; Complexity Analysis Time Complexity : O(nlogn) Space Complexity : O(n) Explanation 1. Intuition - We can get maximum profit if we keep assigning the maximum profit job repeatedly. - But we need to ensure that the worker can complete the job. - So we can create pairs of profit and difficulty and sort them in descending order. - We can sort the workers in descending order. - Now we find the first job that the worker can complete and assign it to him. - We try to assign the same job to all the workers who can complete the job; this way, we can get the maximum profit. - If a worker cannot complete any job, we move to the next possible job. 2. Implementation - Initialize a vector of pairs `pq` of size `profit.size()`. - Fill the vector with pairs of profit and difficulty. - Initialize `wsize = worker.size()`, `pqsize = pq.size()`, `i = 0`, `j = 0`, and `ans = 0`. - Sort the workers and the pairs in descending order. - Run a while loop till `i \u0026lt; wsize` and `j \u0026lt; pqsize`. - Run a while loop till `j \u0026lt; pqsize` and `pq[j].second \u0026gt; worker[i]`. - Keep incrementing `j` till we find the first job that the worker can complete. - This loop will find the first possible job that the worker can complete. - If `i == wsize` or `j == pqsize`, break. - This loop will break if we reach the end of the workers or the pairs of jobs. - Run a while loop till `i \u0026lt; wsize` and `j \u0026lt; pqsize` and `pq[j].second \u0026lt;= worker[i]`. - This loop represents the assignment of jobs to workers. - Same job will be assigned to all the workers who can complete the job. - Increment `i` and add the profit to `ans`. - Return `ans`. Note - The code can be optimized by using a priority queue instead of sorting the pairs. Also this problem can be solved using a greedy approach as shown.\n","date":"June 18, 2024","permalink":"/blog/posts/previous-solutions/problem-most-profit-assigning-work/","summary":"Problem Statement Link - Problem 826 Question You have n jobs and m workers.","title":"Problem 826 Most Profit Assigning Work","type":"posts"},{"content":" Problem Statement Link - Problem 633 Question Given a non-negative integer c, decide whether there are two integers a and b such that a^2 + b^2 = c.\nNote Even thought it doesn\u0026rsquo;t say in the question , the numbers can be equal, ie a=b is valid. since we are talking about square sums, it is safe to say that values of any one of variable can be atmost sqrt(c) Example 1 Input: c = 5 Output: true Explanation: 1 * 1 + 2 * 2 = 5 Example 2 Input: c = 3 Output: false Constraints 0 \u0026lt;= c \u0026lt;= 2^31 - 1 Solution class Solution { public: bool judgeSquareSum(int c) { long long int l =0,r = sqrt(c); long long int sum; while(l\u0026lt;=r) { sum = l*l + r*r; if(sum == c) return true; else if(sum\u0026gt;c) r--; else l++; } return false; } }; Complexity Analysis Time Complexity : O(sqrt(n)) Space Complexity : O(1) Explanation 1. Intuition - The equation `a^2 + b^2 = c` can be resolved into a two pointer problem. - We know that one of the values of `a` and `b` can be atmost `sqrt(c)`. - When `l` and `r` are at the extreme ends, the sum of squares will be maximum. - So we can start from `l=0` and `r=sqrt(c)` and keep moving the pointers based on the sum. - If the sum is greater than `c`, we need to reduce the sum, so we decrement `r`. - If the sum is lesser than `c`, we need to increase the sum, so we increment `l`. - If the sum is equal to `c`, we return true. - If the pointers cross each other, we return false. 2. Implementation - Initialize `long long int l =0,r = sqrt(c);` and `long long int sum;`. - Run a while loop till `l\u0026lt;=r`. - Calculate the sum of squares `sum = l*l + r*r`. - If the sum is equal to `c`, return true. - If the sum is greater than `c`, decrement `r`. - If the sum is lesser than `c`, increment `l`. - If the loop ends, return false. Mathematical Solution There is a pure mathematical solution to this problem. Fermat\u0026rsquo;s Theorem on Sum of Two Squares Any positive number `n` is expressible as a sum of two squares if and only if the prime factorization of `n`, every prime of the form `(4k+3)` occurs an even number of times. Using the above theorem we can check if any of the prime factors of c which is of the form (4k+3) occurs an odd number of times. If yes, then we can return false. If no, then we need to check if the number c itself is of form (4k+3). If yes, then we can return false. If no, then we can return true. Code public class Solution { public boolean judgeSquareSum(int c) { for (int i = 2; i * i \u0026lt;= c; i++) { int count = 0; if (c % i == 0) { while (c % i == 0) { count++; c /= i; } if (i % 4 == 3 \u0026amp;\u0026amp; count % 2 != 0) return false; } } return c % 4 != 3; } } Complexity Time Complexity : O(sqrt(n)) Space Complexity : O(1) The wikipedia article for this theorem is here ","date":"June 17, 2024","permalink":"/blog/posts/previous-solutions/problem-sum-of-square-numbers/","summary":"Problem Statement Link - Problem 633 Question Given a non-negative integer c, decide whether there are two integers a and b such that a^2 + b^2 = c.","title":"Problem 633 Sum of Square Numbers","type":"posts"},{"content":" Problem Statement Link - Problem 502 Question Suppose LeetCode will start its IPO soon. In order to sell a good price of its shares to Venture Capital, LeetCode would like to work on some projects to increase its capital before the IPO. Since it has limited resources, it can only finish at most k distinct projects before the IPO. Help LeetCode design the best way to maximize its total capital after finishing at most k distinct projects.\nYou are given n projects where the ith project has a pure profit profits[i] and a minimum capital of capital[i] is needed to start it.\nInitially, you have w capital. When you finish a project, you will obtain its pure profit and the profit will be added to your total capital.\nPick a list of at most k distinct projects from given projects to maximize your final capital, and return the final maximized capital.\nThe answer is guaranteed to fit in a 32-bit signed integer.\nNote This question says Pure profit, which means the capital is not getting deducted for performing the project. if we are able to perform a project , we will get the profit directly added to current capital. We can perform a project only once. Example 1 Input: k = 2, w = 0, profits = [1,2,3], capital = [0,1,1] Output: 4 Explanation: Since your initial capital is 0, you can only start the project indexed 0. After finishing it you will obtain profit 1 and your capital becomes 1. With capital 1, you can either start the project indexed 1 or the project indexed 2. Since you can choose at most 2 projects, you need to finish the project indexed 2 to get the maximum capital. Therefore, output the final maximized capital, which is 0 + 1 + 3 = 4. Example 2 Input : k = 4, w = 0, profits = [1,2,3,4], capital = [0,1,2,3] Output : 10 Explanation : Since your initial capital is 0, you can only start the project indexed 0. After finishing it you will obtain profit 1 and your capital becomes 1. With capital 1 , we can start the project indexed 1, now capital becomes 3. With capital 3, we can start the project indexed 2, now capital becomes 6. With capital 6, we can start the project indexed 3, now capital becomes 10. Constraints - `1 \u0026lt;= k \u0026lt;= 10^5` - `0 \u0026lt;= w \u0026lt;= 10^9` - `n == profits.length` - `n == capital.length` - `1 \u0026lt;= n \u0026lt;= 10^5` - `0 \u0026lt;= profits[i] \u0026lt;= 10^4` - `0 \u0026lt;= capital[i] \u0026lt;= 10^9` Solution class Solution { public: int findMaximizedCapital(int k, int w, vector\u0026lt;int\u0026gt;\u0026amp; profits, vector\u0026lt;int\u0026gt;\u0026amp; capital) { std::ios::sync_with_stdio(false); vector\u0026lt;pair\u0026lt;int,int\u0026gt;\u0026gt;job; for(int i = 0; i\u0026lt;profits.size();i++) job.push_back({capital[i],profits[i]}); sort(job.begin(),job.end()); priority_queue\u0026lt;int\u0026gt; maxProfit; int i = 0; while(k\u0026gt;0) { while(i\u0026lt;profits.size() \u0026amp;\u0026amp; job[i].first\u0026lt;=w) { maxProfit.push(job[i].second); i++; } if(maxProfit.empty()) break; w+=maxProfit.top(); maxProfit.pop(); k--; } return w; } }; Complexity Analysis Time Complexity : O(nlogn) Space Complexity : O(n) Explanation 1. Intuition - We need to find the maximum possible profit for a given capital. - For this if we pair the capital and profit and sort them based on capital. - We can then iterate over the projects and check if the capital is less than or equal to the current capital. - If yes then we can add the profit to the max heap. - We can then pop the top element from the max heap and add it to the capital. - We can repeat this process until we have performed k projects. 2. Implementation - Pair the capital and profit and sort them, store them in a vector of pairs called `job`. - Initialize a max heap called `maxProfit`. - Initialize a variable `i` to 0. - Iterate over the projects until `k` becomes 0. - Check if the capital is less than or equal to the current capital and `i` is less than the size of the projects. - If yes then add the profit to the `maxProfit` heap. - Increment `i`. - This will add all the projects which can be performed with the current capital. - If the `maxProfit` heap is empty then break. - Add the top element of the `maxProfit` heap to the capital. - Pop the top element from the `maxProfit` heap. - Decrement `k`. - Return the final capital. This is a greedy approach where we are trying to maximize the profit by selecting the projects which can be performed with the current capital.\n","date":"June 15, 2024","permalink":"/blog/posts/previous-solutions/problem-ipo/","summary":"Problem Statement Link - Problem 502 Question Suppose LeetCode will start its IPO soon.","title":"Problem 502 IPO","type":"posts"},{"content":" Problem Statement Link - Problem 945 Question You are given an integer array nums. In one move, you can pick an index i where 0 \u0026lt;= i \u0026lt; nums.length and increment nums[i] by 1.\nReturn the minimum number of moves to make every value in nums unique.\nThe test cases are generated so that the answer fits in a 32-bit integer.\nExample 1 Input: nums = [1,2,2] Output: 1 Explanation: After 1 move, the array could be [1, 2, 3]. Example 2 Input: nums = [3,2,1,2,1,7] Output: 6 Explanation: After 6 moves, the array could be [3, 4, 1, 2, 5, 7]. Constraints 0 \u0026lt;= nums[i] \u0026lt;= 10^5 1 \u0026lt;= nums.length \u0026lt;= 10^5 Solution class Solution { public: int minIncrementForUnique(vector\u0026lt;int\u0026gt;\u0026amp; nums) { std::ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); sort(nums.begin(),nums.end()); int ans = 0,diff=0; for(int i = 1;i\u0026lt;nums.size();i++) { if(nums[i]\u0026lt;=nums[i-1]) { diff = nums[i-1]-nums[i]+1; ans+= diff; nums[i]+=diff; } } return ans; } }; Complexity Analysis Time Complexity : O(nlogn) Space Complexity : O(1) Explanation 1. Intuition - If the array is sorted, we need to check the if current element is less than or equal to the previous element. - If yes then we need to increment the current element by the difference of previous element and current element + 1. - We add 1 just to make it unique. 2. Implementation - Sort the array. - Initialize the answer `ans` and difference `diff` variable to 0. - Iterate over the array from 1 to n. - if `nums[i]` is less than or equal to `nums[i-1]` then calculate the difference. - Difference is the difference between the previous element and the current element + 1. - Increment the answer by the difference. - Increment the current element by the difference. - Return the answer. Alternate Approach Code class Solution { public: int minIncrementForUnique(vector\u0026lt;int\u0026gt;\u0026amp; nums) { int n = nums.size(); int max_val = 0; int minIncrements = 0; // Find maximum value in nums using a loop for (int val : nums) { max_val = max(max_val, val); } // Create a frequencyCount vector to store the frequency of each value in nums vector\u0026lt;int\u0026gt; frequencyCount(n + max_val + 1, 0); // Populate frequencyCount vector with the frequency of each value in nums for (int val : nums) { frequencyCount[val]++; } // Iterate over the frequencyCount vector to make all values unique for (int i = 0; i \u0026lt; frequencyCount.size(); i++) { if (frequencyCount[i] \u0026lt;= 1) continue; // Determine excess occurrences, carry them over to the next value, // ensure single occurrence for current value, and update minIncrements. int duplicates = frequencyCount[i] - 1; frequencyCount[i + 1] += duplicates; frequencyCount[i] = 1; minIncrements += duplicates; } return minIncrements; } }; // Time Complexity: O(n + max_val) // Space Complexity: O(n + max_val) Approach : Counting Another way to track duplicates is to use an array called frequencyCount. In this array, each index represents a unique value from our given array, nums, and the value at each index represents the count of occurrences of that value in nums.\nFor example: if 3 appears in nums twice, frequencyCount[3] would equal 2.\nnums = [1,3,3,5,5] frequencyCount = [0, 1, 0, 2, 0, 2] We know nums contains all unique values when none of the values in frequencyCount is greater than 1.\nOnce we\u0026rsquo;ve created the frequencyCount array from nums, we can iterate through it and simulate the process used in Approach 1 to increment each duplicate value until all values become unique.\nSo elements with a count of 1 or less will remain unchanged. Upon encountering a duplicate, we\u0026rsquo;ll calculate the surplus of elements with that value, carry that count to the next index, and set the current index value to 1.\nWe\u0026rsquo;ll keep a running count for the number that we carry over to the next index; that equals how many moves it will take to make each value of nums unique.\nWe want to initialize frequencyCount with the largest possible range that could be needed to solve the problem. How do we determine this range?\nThe minimum length of frequencyCount would be the largest value in nums, and it must be long enough to hold the new values we get from incrementing any duplicates. Keep in mind that the maximum number of duplicates that we could possibly have is equal to the length of nums.\nIn problems like this, we can determine the longest possible length needed by considering a worst-case scenario. For instance, take the edge case where nums = [4, 4, 4, 4, 4].\nThe frequencyCount array for this would be:\nfrequencyCount = [0, 0, 0, 0, 5]\nIf we make every element unique, the frequencyCount array transforms to:\nfrequencyCount = [0, 0, 0, 0, 5, 6, 7, 8, 9]\nAs you can observe, the size of the frequencyCount array is 9, which equals the length of the original nums array plus the largest value found in nums.\nAlgorithm Initialize variables: n as the length of nums. max to store the maximum value in nums. minIncrements to store the total number of increments needed. Find the maximum value in nums. Create an array frequencyCount to store the frequency of each element. Loop over nums and populate frequencyCount. Loop over the frequencyCount array. For each element: If the frequency is less than or equal to one, continue with the next iteration. Add the duplicates to the frequency of the next element. Set the frequency of the current element to one. Update minIncrements to account for the movement of the duplicates. Return minIncrements. ","date":"June 14, 2024","permalink":"/blog/posts/previous-solutions/problem-minimum-increment-to-make-array-unique/","summary":"Problem Statement Link - Problem 945 Question You are given an integer array nums.","title":"Problem 945 Minimum Increment to Make Array Unique","type":"posts"},{"content":" Problem Statement Link - Problem 2037 Question There are n seats and n students in a room. You are given an array seats of length n, where seats[i] is the position of the ith seat. You are also given the array students of length n, where students[j] is the position of the jth student.\nYou may perform the following move any number of times:\nIncrease or decrease the position of the ith student by 1 (i.e., moving the ith student from position x to x + 1 or x - 1) Return the minimum number of moves required to move each student to a seat such that no two students are in the same seat. Note that there may be multiple seats or students in the same position at the beginning.\nNote This question is very confusing, but the question is asking what is the number of moves required to seat all the students in the seats such that no two students are in the same seat. Also the to get minimum moves we need to make sure the student is matched to the seat which is closest to him. Example 1 Input: seats = [3,1,5], students = [2,7,4] Output: 4 Explanation: The students are moved as follows: - The first student is moved from from position 2 to position 1 using 1 move. - The second student is moved from from position 7 to position 5 using 2 moves. - The third student is moved from from position 4 to position 3 using 1 move. In total, 1 + 2 + 1 = 4 moves were used. Example 2 Input: seats = [4,1,5,9], students = [1,3,2,6] Output: 7 Explanation: The students are moved as follows: - The first student is not moved. - The second student is moved from from position 3 to position 4 using 1 move. - The third student is moved from from position 2 to position 5 using 3 moves. - The fourth student is moved from from position 6 to position 9 using 3 moves. In total, 0 + 1 + 3 + 3 = 7 moves were used. Example 3 Input: seats = [2,2,6,6], students = [1,3,2,6] Output: 4 Explanation: Note that there are two seats at position 2 and two seats at position 6. The students are moved as follows: - The first student is moved from from position 1 to position 2 using 1 move. - The second student is moved from from position 3 to position 6 using 3 moves. - The third student is not moved. - The fourth student is not moved. In total, 1 + 3 + 0 + 0 = 4 moves were used. Constraints n == seats.length == students.length 1 \u0026lt;= n \u0026lt;= 100 1 \u0026lt;= seats[i], students[j] \u0026lt;= 100 Solution class Solution { public: int minMovesToSeat(vector\u0026lt;int\u0026gt;\u0026amp; seats, vector\u0026lt;int\u0026gt;\u0026amp; students) { sort(students.begin(),students.end()); sort(seats.begin(),seats.end()); int answer = 0; for(int i =0;i\u0026lt;seats.size();i++) { answer+=abs(seats[i]-students[i]); } return answer; } }; Complexity Analysis Time Complexity : O(NlogN) Space Complexity : O(1) Explanation 1. Intuition - We need to implement a greedy approach to solve this problem. - We need to sort the students and seats array. - Then we can match the students to the seats which are closest to them. 2. Implementation - First we sort the students and seats array. - Then we iterate over the seats array and calculate the absolute difference between the seat and student. - We add the difference to the answer. - Finally we return the answer. ","date":"June 13, 2024","permalink":"/blog/posts/previous-solutions/problem-minimum-number-of-moves-to-seat-everyone/","summary":"Problem Statement Link - Problem 2037 Question There are n seats and n students in a room.","title":"Problem 2037 Minimum Number of Moves to Seat Everyone","type":"posts"},{"content":" Problem Statement Link - Problem 75 Question Given an array nums with n objects colored red, white, or blue, sort them in-place so that objects of the same color are adjacent, with the colors in the order red, white, and blue.\nWe will use the integers 0, 1, and 2 to represent the color red, white, and blue, respectively.\nYou must solve this problem without using the library\u0026rsquo;s sort function.\nExample 1 Input: nums = [2,0,2,1,1,0] Output: [0,0,1,1,2,2] Example 2 Input: nums = [2,0,1] Output: [0,1,2] Constraints n == nums.length 1 \u0026lt;= n \u0026lt;= 300 nums[i] is either 0, 1, or 2. Solution // Two loop solution class Solution { public: void sortColors(vector\u0026lt;int\u0026gt;\u0026amp; nums) { for(int i = 0;i\u0026lt;nums.size();i++) { for(int j = i+1;j\u0026lt;nums.size();j++) { if(nums[i]\u0026gt;nums[j]) { int temp = nums[i]; nums[i]=nums[j]; nums[j]=temp; } } } } }; Complexity Analysis Time Complexity : O(N^2) Space Complexity : O(1) Explanation 1. Intuition - Since they need it to be in-place, we can use two loops to sort the array. - This is similar to bubble sort. 2. Implementation - Outer loop runs from 0 to n-1. - Inner loop runs from i+1 to n. - If nums[i] \u0026gt; nums[j], then swap the elements. - Continue this process until the array is sorted. - This will ensure that the array is sorted in-place. Alternate Solution Dutch National Flag Algorithm class Solution { public: void sortColors(vector\u0026lt;int\u0026gt;\u0026amp; nums) { int low = 0; int mid = 0; int high = nums.size()-1; while(mid\u0026lt;=high) { if(nums[mid]==0) { swap(nums[low],nums[mid]); low++; mid++; } else if(nums[mid]==1) { mid++; } else { swap(nums[mid],nums[high]); high--; } } } }; Time Complexity : O(N) Space Complexity : O(1) Intuition - We can use the Dutch National Flag Algorithm to solve this problem. - We use three pointers to keep track of the elements. - We use `low` to keep track of the 0\u0026#39;s. - We use `mid` to keep track of the 1\u0026#39;s. - We use `high` to keep track of the 2\u0026#39;s. - We traverse through the array and swap the elements accordingly. Implementation - Initialize `low` to 0, `mid` to 0, and `high` to n-1. - Traverse through the array until `mid` is less than or equal to `high`. - If `nums[mid]` is 0, then swap `nums[low]` and `nums[mid]` and increment `low` and `mid`. - If `nums[mid]` is 1, then increment `mid`. - If `nums[mid]` is 2, then swap `nums[mid]` and `nums[high]` and decrement `high`. - Continue this process until `mid` is less than or equal to `high`. - This will ensure that the array is sorted according to the colors. Shows a similarity to count sort. We can use the same approach to solve this problem. We can count the number of 0\u0026rsquo;s, 1\u0026rsquo;s, and 2\u0026rsquo;s and then fill the array accordingly. This will also solve the problem in O(N) time complexity.\n","date":"June 12, 2024","permalink":"/blog/posts/previous-solutions/problem-sort-colors/","summary":"Problem Statement Link - Problem 75 Question Given an array nums with n objects colored red, white, or blue, sort them in-place so that objects of the same color are adjacent, with the colors in the order red, white, and blue.","title":"Problem 75 Sort Colors","type":"posts"},{"content":" Problem Statement Link - Problem 1122 Question Given two arrays arr1 and arr2, the elements of arr2 are distinct, and all elements in arr2 are also in arr1.\nSort the elements of arr1 such that the relative ordering of items in arr1 are the same as in arr2. Elements that do not appear in arr2 should be placed at the end of arr1 in ascending order.\nExample 1 Input: arr1 = [2,3,1,3,2,4,6,7,9,2,19], arr2 = [2,1,4,3,9,6] Output: [2,2,2,1,4,3,3,9,6,7,19] Example 2 Input: arr1 = [28,6,22,8,44,17], arr2 = [22,28,8,6] Output: [22,28,8,6,17,44] Constraints 1 \u0026lt;= arr1.length, arr2.length \u0026lt;= 1000 0 \u0026lt;= arr1[i], arr2[i] \u0026lt;= 1000 All the elements of arr2 are distinct. Each arr2[i] is in arr1. Solution class Solution { public: vector\u0026lt;int\u0026gt; relativeSortArray(vector\u0026lt;int\u0026gt;\u0026amp; arr1, vector\u0026lt;int\u0026gt;\u0026amp; arr2) { vector\u0026lt;int\u0026gt;freqCount(1001,0); for(int i = 0;i\u0026lt;arr1.size();i++) { freqCount[arr1[i]]++; } int ansptr=0; for(int i=0; i\u0026lt;arr2.size();i++) { while(freqCount[arr2[i]]) { arr1[ansptr] = arr2[i]; ansptr++; freqCount[arr2[i]]--; } } for(int i = 0;i\u0026lt;freqCount.size();i++) { while(freqCount[i]) { arr1[ansptr] = i; ansptr++; freqCount[i]--; } } return arr1; } }; Complexity Analysis Time Complexity : O(N) Space Complexity : O(N) Explanation 1. Intuition - We need to know the count of elements in `arr1` - Hence we use `freqCount` vector to store frequency counts. - `arr2` will give us the order of insertion. 2. Implementation - First create a `freqCount` vector of size 1001 and initialize it with 0. - Traverse through `arr1` and increment the frequency count of each element. - Traverse through `arr2` and insert the elements in `arr1` in the order of `arr2`. - Traverse through `freqCount` and insert the remaining elements in `arr1`. - Now the array is sorted according to `arr2`. - Return `arr1`. Note Hashmap implementation class Solution{ public: vector\u0026lt;int\u0026gt; relativeSortArray(vector\u0026lt;int\u0026gt;\u0026amp; arr1, vector\u0026lt;int\u0026gt;\u0026amp; arr2) { map\u0026lt;int,int\u0026gt;freqCount; for(int i = 0;i\u0026lt;arr1.size();i++) { freqCount[arr1[i]]++; } int ansptr=0; for(int i=0; i\u0026lt;arr2.size();i++) { while(freqCount[arr2[i]]) { arr1[ansptr] = arr2[i]; ansptr++; freqCount[arr2[i]]--; } } for(auto i:freqCount) { while(i.second) { arr1[ansptr] = i.first; ansptr++; i.second--; } } return arr1; } }; ","date":"June 11, 2024","permalink":"/blog/posts/previous-solutions/problem-relative-sort-array/","summary":"Problem Statement Link - Problem 1122 Question Given two arrays arr1 and arr2, the elements of arr2 are distinct, and all elements in arr2 are also in arr1.","title":"Problem 1122 Relative Sort Array","type":"posts"},{"content":" Problem Statement Link - Problem 136 Question Given a non-empty array of integers nums, every element appears twice except for one. Find that single one.\nYou must implement a solution with a linear runtime complexity and use only constant extra space.\nNote We need O(1) space and O(n) time complexity. That means we cant use any other space to store frequency of elements and cant sort the array and check for the element which is not repeated. This hints that we need to manipulate the given array and find the single number. Example 1 Input: nums = [2,2,1] Output: 1 Example 2 Input: nums = [4,1,2,1,2] Output: 4 Example 3 Input: nums = [1] Output: 1 Constraints 1 \u0026lt;= nums.length \u0026lt;= 3 * 10^4 -3 * 10^4 \u0026lt;= nums[i] \u0026lt;= 3 * 10^4 Each element in the array appears twice except for one element which appears only once. Solution class Solution { public: int singleNumber(vector\u0026lt;int\u0026gt;\u0026amp; nums) { std::ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); int ans = nums[0]; for(int i= 1; i\u0026lt;nums.size(); i++) ans = ans^nums[i]; return ans; } }; Complexity Analysis Time Complexity : O(N) Space Complexity : O(1) Explanation 1. Intuition - We know that a number XOR with itself is 0. - So, if we XOR all the elements in the array, the elements which are repeated will cancel each other. - We will be left with the single number. 2. Implementation - Initialize a variable `ans` with the first element of the array. - Iterate over the array from the second element. - XOR the `ans` with the current element. - Return the `ans`. This solution shows the power of XOR operation. XOR operation is commutative and associative. So, we can use it to find the single number in the array.\n","date":"June 10, 2024","permalink":"/blog/posts/previous-solutions/problem-single-number/","summary":"Problem Statement Link - Problem 136 Question Given a non-empty array of integers nums, every element appears twice except for one.","title":"Problem 136 Single Number","type":"posts"},{"content":" Problem Statement Link - Problem 1051 Question A school is trying to take an annual photo of all the students. The students are asked to stand in a single file line in non-decreasing order by height. Let this ordering be represented by the integer array expected where expected[i] is the expected height of the ith student in line.\nYou are given an integer array heights representing the current order that the students are standing in. Each heights[i] is the height of the ith student in line (0-indexed).\nReturn the number of indices where heights[i] != expected[i].\nExample 1 Input: heights = [1,1,4,2,1,3] Output: 3 Explanation: heights: [1,1,4,2,1,3] expected: [1,1,1,2,3,4] Indices 2, 4, and 5 do not match. Example 2 Input: heights = [5,1,2,3,4] Output: 5 Explanation: heights: [5,1,2,3,4] expected: [1,2,3,4,5] All indices do not match. Example 3 Input: heights = [1,2,3,4,5] Output: 0 Explanation: heights: [1,2,3,4,5] expected: [1,2,3,4,5] All indices match. Constraints 1\u0026lt;= heights.length \u0026lt;= 100 1 \u0026lt;= heights[i] \u0026lt;= 100 Solution class Solution { public: int heightChecker(vector\u0026lt;int\u0026gt;\u0026amp; heights) { vector\u0026lt;int\u0026gt; ans; for(auto i : heights) ans.push_back(i); sort(ans.begin(), ans.end()); int count = 0; for(int i = 0 ; i \u0026lt; heights.size() ; i ++) if(heights[i] != ans[i]) count++; return count; } }; Complexity Analysis Time Complexity : O(NlogN) Space Complexity : O(N) Explanation 1. Intuition - We need to have a copy of the original array. - Sort the copy. - Compare the original array with the sorted array. - Count the number of mismatches. 2. Implementation - Create a copy of the `heights` array and name it `expected`. - Sort the `expected` array. - Compare the `heights` array with the `expected` array. - Count the number of mismatches. - Return the count. ","date":"June 10, 2024","permalink":"/blog/posts/previous-solutions/problem-height-checker/","summary":"Problem Statement Link - Problem 1051 Question A school is trying to take an annual photo of all the students.","title":"Problem 1051 Height Checker","type":"posts"},{"content":" Problem Statement Link - Problem 523 Question Given an integer array nums and an integer k, return true if nums has a good subarray or false otherwise.\nA good subarray is a subarray where:\nits length is at least two, and the sum of the elements of the subarray is a multiple of k.\nNote A subarray is a contiguous part of the array. An integer x is a multiple of k if there exists an integer n such that x = n * k. 0 is always a multiple of k. Example 1 Input: nums = [23,2,4,6,7], k = 6 Output: true Explanation: [2, 4] is a continuous subarray of size 2 whose elements sum up to 6. Example 2 Input: nums = [23,2,6,4,7], k = 6 Output: true Explanation: [23, 2, 6, 4, 7] is an continuous subarray of size 5 whose elements sum up to 42. 42 is a multiple of 6 because 42 = 7 * 6 and 7 is an integer. Example 3 Input: nums = [23,2,6,4,7], k = 13 Output: false Constraints - `1 \u0026lt;= nums.length \u0026lt;= 10^5` - `0 \u0026lt;= nums[i] \u0026lt;= 10^9` - `0 \u0026lt;= sum(nums[i]) \u0026lt;= 23^1 - 1` - `1 \u0026lt;= k \u0026lt;= 2^31 - 1` Solution A Brute force Solution // This code is practically useless for larger values of k and nums; class Solution { public: bool checkSubarraySum(vector\u0026lt;int\u0026gt;\u0026amp; nums,int k) { std::ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); int size = nums.size(); for(int i = 0; i\u0026lt;size; i++) { int sum = nums[i]; for(int j = i+1; j\u0026lt;size; j++) { sum+=nums[j]; if(k==0) { if(sum==0) return true; } else if(sum%k==0) return true; } } return false; } }; // Time complexity is O(N^2) // Space complexity is O(1) A Better Solution class Solution { public: bool checkSubarraySum(vector\u0026lt;int\u0026gt;\u0026amp; nums, int k) { std::ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); int size = nums.size(), sum = 0; unordered_map\u0026lt;int,int\u0026gt;indexOccured; indexOccured[0] = -1; for(int i= 0; i\u0026lt;size; i++) { sum+=nums[i]; if(indexOccured.find(sum%k) == indexOccured.end()) { indexOccured[sum%k] = i; } else { int found = indexOccured[sum%k]; if(i-found\u0026gt;1) return true; } } return false; } }; Complexity Analysis Time Complexity : O(n) Space Complexity : O(n) Explanation 1. Intuition - We need to find a subarray whose sum is a multiple of k and length is atleast 2. - We can use two loops to define start and end points of a subarray and calculate the sum. - If the sum is a multiple of k, we can return true. - But this solution is not optimal. - We can use a hashmap to store the sum%k and the index where it occured. This works for fast lookups. - So make it just a single loop to calculate the sum so far and store the sum%k in a hashmap. - If the sum%k is already present in the hashmap, we can check if the difference between the current index and the index where the sum%k occured is greater than 1. - if yes return true. If not continue. 2. Implementation - Intialize a hashmap `indexOccured` with key as 0 and value as -1. - This initialization is to prevent the edge case where the first element is a multiple of k. - Iterate over the array `nums` and calculate the `sum` so far. - If the `sum%k` is not present in the hashmap, add it to the hashmap with the index. - If the `sum%k` is already present in the hashmap: check if the difference between the current index and the index where the `sum%k` occured is greater than 1. - If yes return true. If not continue. - If we reach end of the loop, return false. A really good mathematical optimization problem. The hashmap is the key to this solution. The hashmap stores the sum%k and the index where it occured. If the sum%k is already present in the hashmap, we can check if the difference between the current index and the index where the sum%k occured is greater than 1.\n","date":"June 8, 2024","permalink":"/blog/posts/previous-solutions/problem-continuous-subarray-sum/","summary":"Problem Statement Link - Problem 523 Question Given an integer array nums and an integer k, return true if nums has a good subarray or false otherwise.","title":"Problem 523 Continuous Subarray Sum","type":"posts"},{"content":" Problem Statement Link - Problem 1002 Question Given a string array words, return an array of all characters that show up in all strings within the words (including duplicates). You may return the answer in any order.\nExample 1 Input: words = [\u0026#34;bella\u0026#34;,\u0026#34;label\u0026#34;,\u0026#34;roller\u0026#34;] Output: [\u0026#34;e\u0026#34;,\u0026#34;l\u0026#34;,\u0026#34;l\u0026#34;] Example 2 Input: words = [\u0026#34;cool\u0026#34;,\u0026#34;lock\u0026#34;,\u0026#34;cook\u0026#34;] Output: [\u0026#34;c\u0026#34;,\u0026#34;o\u0026#34;] Constraints 1 \u0026lt;= words.length \u0026lt;= 100 1 \u0026lt;= words[i].length \u0026lt;= 100 words[i] consists of lowercase English letters. Solution class Solution { public: vector\u0026lt;string\u0026gt; commonChars(vector\u0026lt;string\u0026gt;\u0026amp; words) { vector\u0026lt;int\u0026gt;baselineCount(26,0); string temp; for(int i =0;i\u0026lt;words[0].size();i++) { baselineCount[words[0][i]-\u0026#39;a\u0026#39;]++; } for(auto word:words) { vector\u0026lt;int\u0026gt;newCount(26,0); for(const auto\u0026amp; ch:word) newCount[ch-\u0026#39;a\u0026#39;]++; for(int i= 0;i\u0026lt;26;i++) baselineCount[i] = min(baselineCount[i],newCount[i]); } vector\u0026lt;string\u0026gt;answer; for(int i =0; i\u0026lt;26;i++) { while(baselineCount[i]--) { temp = \u0026#34;\u0026#34;; temp += \u0026#39;a\u0026#39;+i; answer.push_back(temp); } } return answer; } }; Complexity Analysis Time Complexity : O(N) Space Complexity : O(1) Explanation 1. Intuition - We need to find the common characters in all the strings. - We need some kind of hash table to store all the common characters. - Characters may be repeated so we need to store the count of each character. 2. Implementation - Initialize a vector `baselineCount` of size 26 with all elements as `0`. - Iterate over the first word and increment the count of each character in the `baselineCount`. - Iterate over all the words and for each word create a new vector `newCount` of size 26 with all elements as `0`. - Increment the count of each character in the `newCount`. - Iterate over the `baselineCount` and `newCount` and update the `baselineCount` with the minimum of both. - This will give us the count of each character that is common in all the words seen so far. - Iterate over the `baselineCount` and for each character that has a count greater than `0` add it to the answer. - Return the answer. This problem is about finding the common characters in a given set of strings.\n","date":"June 6, 2024","permalink":"/blog/posts/previous-solutions/problem-find-common-characters/","summary":"Problem Statement Link - Problem 1002 Question Given a string array words, return an array of all characters that show up in all strings within the words (including duplicates).","title":"Problem 1002 Find Common Characters","type":"posts"},{"content":" Problem Statement Link - Problem 846 Question Alice has some number of cards and she wants to rearrange the cards into groups so that each group is of size groupSize, and consists of groupSize consecutive cards.\nGiven an integer array hand where hand[i] is the value written on the ith card and an integer groupSize, return true if she can rearrange the cards, or false otherwise.\nNote : Only groupSize matters not the number of groups. We can only form groups of size groupSize if total number of cards is divisible by groupSize. Consecutive cards means cards with consecutive values ie groups like [1,2,3] or [3,4,5] are valid but [1,3,4] is not valid for given groupSize = 3 Example 1 Input: hand = [1,2,3,6,2,3,4,7,8], groupSize = 3 Output: true Explanation: Alice\u0026#39;s hand can be rearranged as [1,2,3],[2,3,4],[6,7,8] Example 2 Input: hand = [1,2,3,4,5], groupSize = 4 Output: false Explanation: Alice\u0026#39;s hand can not be rearranged into groups of 4. Constraints - `1 \u0026lt;= hand.length \u0026lt;= 10^4` - `0 \u0026lt;= hand[i] \u0026lt;= 10^9` - `1 \u0026lt;= groupSize \u0026lt;= hand.length` Solution class Solution { public: bool isNStraightHand(vector\u0026lt;int\u0026gt;\u0026amp; hand, int groupSize) { std::ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); if (hand.size() % groupSize != 0) return false; map\u0026lt;int, int\u0026gt; freqCount; for (const int\u0026amp; card : hand) freqCount[card]++; for (auto it = freqCount.begin(); it != freqCount.end(); ++it) { if (it-\u0026gt;second \u0026gt; 0) { int count = it-\u0026gt;second; for (int i = 0; i \u0026lt; groupSize; ++i) { if (freqCount[it-\u0026gt;first + i] \u0026lt; count) return false; freqCount[it-\u0026gt;first + i] -= count; } } } return true; } }; Complexity Analysis Time Complexity : O(NlogN) Space Complexity : O(N) Explanation 1. Intuition - We need to check if we can form groups of size `groupSize` with given cards. - If not possible return false. - We need to maintain the count of each card. - We need this count to check if we can form groups of size `groupSize`. 2. Implementation - Check if total number of cards is divisible by `groupSize`. - If not return `false`. - Create a map `freqCount` to store the count of each card. - Iterate over the `hand` and increment the count of each card in `freqCount`. - For every card in `freqCount` check if the count is greater than `0`. - If yes then assign the count to a variable `count`. - Iterate over the next `groupSize` cards and check if the count of each card is greater than or equal to `count`. - This will help us to check if we can form groups of size `groupSize` with current card and next `groupSize-1` cards. - If not return `false`. - If yes then decrement the count of each card by `count`. - Continue this process until we have checked all the cards. - If we reach here then return `true`. This problem is also same as Problem 1296 . We need to dovode the array into groups of size k such that each group is consecutive.\n","date":"June 6, 2024","permalink":"/blog/posts/previous-solutions/problem-hand-of-straights/","summary":"Problem Statement Link - Problem 846 Question Alice has some number of cards and she wants to rearrange the cards into groups so that each group is of size groupSize, and consists of groupSize consecutive cards.","title":"Problem 846 Hand of Straights","type":"posts"},{"content":" Problem Statement Link - Problem 344 Question Write a function that reverses a string. The input string is given as an array of characters s.\nYou must do this by modifying the input array in-place with O(1) extra memory.\nExample 1 Input: s = [\u0026#34;h\u0026#34;,\u0026#34;e\u0026#34;,\u0026#34;l\u0026#34;,\u0026#34;l\u0026#34;,\u0026#34;o\u0026#34;] Output: [\u0026#34;o\u0026#34;,\u0026#34;l\u0026#34;,\u0026#34;l\u0026#34;,\u0026#34;e\u0026#34;,\u0026#34;h\u0026#34;] Example 2 Input: s = [\u0026#34;H\u0026#34;,\u0026#34;a\u0026#34;,\u0026#34;n\u0026#34;,\u0026#34;n\u0026#34;,\u0026#34;a\u0026#34;,\u0026#34;h\u0026#34;] Output: [\u0026#34;h\u0026#34;,\u0026#34;a\u0026#34;,\u0026#34;n\u0026#34;,\u0026#34;n\u0026#34;,\u0026#34;a\u0026#34;,\u0026#34;H\u0026#34;] Constraints 1 \u0026lt;= s.length \u0026lt;= 10^5 s[i] is a printable ascii character. Solution class Solution { public: void reverseString(vector\u0026lt;char\u0026gt;\u0026amp; s) { int start = 0, end = s.size()-1; char ch; while(start\u0026lt;end) { ch = s[start]; s[start] = s[end]; s[end] = ch; ++start; --end; } } }; Complexity Analysis Time Complexity : O(N) Space Complexity :O(1) Explanation 1. Intuition - Use two pointer approach to swap the elements. - We need to write a swapping logic without using any extra space. 2. Implementation 1. Initialize two pointers `start` and `end` to `0` and `s.size()-1` respectively. 2. Swap the elements at `start` and `end` index. 3. Increment `start` and decrement `end` until `start` is less than `end`. Alternate Solution class Solution { public: void reverseString(vector\u0026lt;char\u0026gt;\u0026amp; s) { reverse(s.begin(),s.end()); } }; Complexity Analysis Time Complexity : O(N) Space Complexity :O(1) Explanation - This solution uses the inbuilt `reverse` function to reverse the string. Utilizes the two pointer approach to swap the elements in the array.\n","date":"June 2, 2024","permalink":"/blog/posts/previous-solutions/problem-reverse-string/","summary":"Problem Statement Link - Problem 344 Question Write a function that reverses a string.","title":"Problem 344 Reverse String","type":"posts"},{"content":" Problem Statement Link - Problem 3110 Question You are given a string s. The score of a string is defined as the sum of the absolute difference between the ASCII values of adjacent characters.\nReturn the score of s.\nExample 1 Input: s = \u0026#34;hello\u0026#34; Output: 13 Explanation: The ASCII values of the characters in s are: \u0026#39;h\u0026#39; = 104, \u0026#39;e\u0026#39; = 101, \u0026#39;l\u0026#39; = 108, \u0026#39;o\u0026#39; = 111. So, the score of s would be |104 - 101| + |101 - 108| + |108 - 108| + |108 - 111| = 3 + 7 + 0 + 3 = 13. Example 2 Input: s = \u0026#34;zaz\u0026#34; Output: 50 Explanation: The ASCII values of the characters in s are: \u0026#39;z\u0026#39; = 122, \u0026#39;a\u0026#39; = 97. So, the score of s would be |122 - 97| + |97 - 122| = 25 + 25 = 50. Constraints 2 \u0026lt;= s.length \u0026lt;= 100 s consists only of lowercase English letters. Solution class Solution { public: int scoreOfString(string s) { std::ios::sync_with_stdio(false); cout.tie(0); cin.tie(0); int score = 0; for(int i = 0;i\u0026lt;s.size()-1;i++) { score+= abs((int)(s[i]-s[i+1])); } return score; } }; Complexity Analysis Time Complexity: O(N) Space Complexity: O(1) Explanation 1. Intuition We can iterate over the string and calculate the score by taking the absolute difference between the ASCII values of adjacent characters. 2. Implementation Initialize the score to 0. Iterate over the string from 0 to s.size()-1. Calculate the score by taking the absolute difference between the ASCII values of adjacent characters. Return the score. This solution is a simple implementation of problem statement.\n","date":"June 1, 2024","permalink":"/blog/posts/previous-solutions/problem-score-of-a-string/","summary":"Problem Statement Link - Problem 3110 Question You are given a string s.","title":"Problem 3110 Score of a String","type":"posts"},{"content":" Problem Statement Link - Problem 131 Question Given a string s, partition s such that every substring of the partition is a palindrome. Return all possible palindrome partitioning of s.\nNote to self First we need to split the string into all possible substrings. Then we need to check if each substring is a palindrome or not. If that split is palindromic then we need to add it to the result. Example 1 Input: s = \u0026#34;aab\u0026#34; Output: [[\u0026#34;a\u0026#34;,\u0026#34;a\u0026#34;,\u0026#34;b\u0026#34;],[\u0026#34;aa\u0026#34;,\u0026#34;b\u0026#34;]] Example 2 Input: s = \u0026#34;a\u0026#34; Output: [[\u0026#34;a\u0026#34;]] Additional Examples s = \u0026#34;aaab\u0026#34; output = [[\u0026#34;a\u0026#34;,\u0026#34;a\u0026#34;,\u0026#34;a\u0026#34;,\u0026#34;b\u0026#34;],[\u0026#34;a\u0026#34;,\u0026#34;aa\u0026#34;,\u0026#34;b\u0026#34;],[\u0026#34;aa\u0026#34;,\u0026#34;a\u0026#34;,\u0026#34;b\u0026#34;],[\u0026#34;aaa\u0026#34;,\u0026#34;b\u0026#34;]] s = \u0026#34;abcaa\u0026#34; output = [[\u0026#34;a\u0026#34;,\u0026#34;b\u0026#34;,\u0026#34;c\u0026#34;,\u0026#34;a\u0026#34;,\u0026#34;a\u0026#34;],[\u0026#34;a\u0026#34;,\u0026#34;b\u0026#34;,\u0026#34;c\u0026#34;,\u0026#34;aa\u0026#34;]] s = \u0026#34;abbab\u0026#34; output = [[\u0026#34;a\u0026#34;,\u0026#34;b\u0026#34;,\u0026#34;b\u0026#34;,\u0026#34;a\u0026#34;,\u0026#34;b\u0026#34;],[\u0026#34;a\u0026#34;,\u0026#34;b\u0026#34;,\u0026#34;bab\u0026#34;],[\u0026#34;a\u0026#34;,\u0026#34;bb\u0026#34;,\u0026#34;a\u0026#34;,\u0026#34;b\u0026#34;],[\u0026#34;abba\u0026#34;,\u0026#34;b\u0026#34;]] s = \u0026#34;abaca\u0026#34; output = [[\u0026#34;a\u0026#34;,\u0026#34;b\u0026#34;,\u0026#34;a\u0026#34;,\u0026#34;c\u0026#34;,\u0026#34;a\u0026#34;],[\u0026#34;a\u0026#34;,\u0026#34;b\u0026#34;,\u0026#34;aca\u0026#34;],[\u0026#34;aba\u0026#34;,\u0026#34;c\u0026#34;,\u0026#34;a\u0026#34;]] s = \u0026#34;aaa\u0026#34; output = [[\u0026#34;a\u0026#34;,\u0026#34;a\u0026#34;,\u0026#34;a\u0026#34;],[\u0026#34;a\u0026#34;,\u0026#34;aa\u0026#34;],[\u0026#34;aa\u0026#34;,\u0026#34;a\u0026#34;],[\u0026#34;aaa\u0026#34;]] Constraints 1 \u0026lt;= s.length \u0026lt;= 16 s contains only lowercase English letters. Solution class Solution { public: vector\u0026lt;vector\u0026lt;string\u0026gt;\u0026gt; partition(string s) { std::ios::sync_with_stdio(false); cin.tie(0); cout.tie(0); vector\u0026lt;vector\u0026lt;string\u0026gt;\u0026gt; result; vector\u0026lt;string\u0026gt; path; backtrack(s, 0, path, result); return result; } private: void backtrack(const string\u0026amp; s, int start, vector\u0026lt;string\u0026gt;\u0026amp; path, vector\u0026lt;vector\u0026lt;string\u0026gt;\u0026gt;\u0026amp; result) { if (start == s.length()) { result.push_back(path); return; } for (int end = start + 1; end \u0026lt;= s.length(); ++end) { if (isPalindrome(s, start, end - 1)) { path.push_back(s.substr(start, end - start)); backtrack(s, end, path, result); path.pop_back(); } } } bool isPalindrome(const string\u0026amp; s, int left, int right) { while (left \u0026lt; right) { if (s[left++] != s[right--]) return false; } return true; } }; Complexity Analysis Time Complexity : O(N * 2^N) : 2^N subsets and each subset has N elements Space Complexity : O(N) : Recursive stack space Explanation 1. Intuition The intuition behind the solution is to use backtracking to generate all possible partitions of the input string s. For each position in the string, the algorithm considers extending the current partition with substrings starting from that position. Before extending, it checks if the substring is a palindrome using the isPalindrome helper function. If the substring is a palindrome, it adds the substring to the current partition (path) and recursively explores further partitions starting from the next character. Once a full partition is found (i.e., the end of the string is reached), it adds the partition to the result set. 2. Implementation Backtracking Function: The backtrack function is the core of the solution. It takes the input string s, the current start position, the current partition path, and the result set result. It iterates through the string, considering each position as a potential start of a new substring. For each position, it checks if the substring ending at that position is a palindrome. If so, it extends the current partition with this substring and recursively calls itself to explore further partitions. When the end of the string is reached, it means a valid partition has been found, which is then added to the result set. Is Palindrome Helper Function: The isPalindrome function checks if a given substring is a palindrome. It compares characters from both ends of the substring moving towards the center. If any pair of characters does not match, it returns false; otherwise, it continues comparing until the middle of the substring is reached, indicating that the entire substring is a palindrome. 3. Dry Run Let\u0026rsquo;s dry run the solution on the example input s = \u0026ldquo;aab\u0026rdquo; to understand how the backtracking algorithm generates all possible palindrome partitions. Input: s = \u0026#34;aab\u0026#34; Output: [[\u0026#34;a\u0026#34;,\u0026#34;a\u0026#34;,\u0026#34;b\u0026#34;],[\u0026#34;aa\u0026#34;,\u0026#34;b\u0026#34;]] - First, the backtrack function is called with the input string \u0026#34;aab\u0026#34;, start position 0, an empty path, and an empty result set. - At position 0, the substring \u0026#34;a\u0026#34; is a palindrome, so it is added to the path, and the function is recursively called with the updated path and the next position. - At position 1, the substring \u0026#34;a\u0026#34; is a palindrome, so it is added to the path, and the function is recursively called with the updated path and the next position. - At position 2, the substring \u0026#34;b\u0026#34; is a palindrome, so it is added to the path, and the function reaches the end of the string, adding the current partition [\u0026#34;a\u0026#34;,\u0026#34;a\u0026#34;,\u0026#34;b\u0026#34;] to the result set. - Backtracking occurs, and the last character \u0026#34;b\u0026#34; is removed from the path. - At position 1, the substring \u0026#34;aa\u0026#34; is a palindrome, so it is added to the path, and the function is recursively called with the updated path and the next position. - At position 2, the substring \u0026#34;b\u0026#34; is a palindrome, so it is added to the path, and the function reaches the end of the string, adding the current partition [\u0026#34;aa\u0026#34;,\u0026#34;b\u0026#34;] to the result set. - Backtracking occurs, and the last character \u0026#34;b\u0026#34; is removed from the path. - Backtracking occurs again, and the last character \u0026#34;a\u0026#34; is removed from the path. - The function returns the final result set containing all possible palindrome partitions of the input string \u0026#34;aab\u0026#34;. This solution uses backtracking to generate all possible palindrome partitions of the input string. By exploring all possible partitions, it ensures that no valid partition is missed, resulting in a complete set of palindrome partitions.\n","date":"May 22, 2024","permalink":"/blog/posts/previous-solutions/problem-palindrome-partitioning/","summary":"Problem Statement Link - Problem 131 Question Given a string s, partition s such that every substring of the partition is a palindrome.","title":"Problem 131 Palindrome Partitioning","type":"posts"},{"content":" Problem Statement Link - Problem 78 Question Given an integer array nums of unique elements, return all possible subsets (the power set).\nA subset of an array is a selection of elements (possibly none) of the array. The solution set must not contain duplicate subsets. Return the solution in any order.\nExample 1 Input: nums = [1,2,3] Output: [[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]] Example 2 Input: nums = [0] Output: [[],[0]] Constraints 1 \u0026lt;= nums.length \u0026lt;= 10 -10 \u0026lt;= nums[i] \u0026lt;= 10 All the numbers of nums are unique. Solution class Solution { public: vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; subsets(vector\u0026lt;int\u0026gt;\u0026amp; nums) { vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; result; result.push_back({}); int n; for (int num : nums) { n = result.size(); for (int i = 0; i \u0026lt; n; ++i) { vector\u0026lt;int\u0026gt; subset = result[i]; subset.push_back(num); result.push_back(subset); } } return result; } }; Complexity Analysis Time Complexity : O(N * 2^N) - 2^N subsets and each subset has N elements Space Complexity : O(N * 2^N) - 2^N subsets and each subset has N elements Explanation 1. Intuition The idea is to start with an empty subset and keep adding elements to it. For each element in the input array, we add it to all the existing subsets and create new subsets. 2. Implementation We start with an empty subset and add it to the result. For each element in the input array, we iterate over all the existing subsets and create new subsets by adding the current element to them. We add these new subsets to the result. Finally, we return the result containing all the subsets. Solution with backtracking class Solution { public: vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; subsets(vector\u0026lt;int\u0026gt;\u0026amp; nums) { vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; result; vector\u0026lt;int\u0026gt; subset; backtrack(result, subset, nums, 0); return result; } void backtrack(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; result, vector\u0026lt;int\u0026gt;\u0026amp; subset, vector\u0026lt;int\u0026gt;\u0026amp; nums, int start) { result.push_back(subset); for (int i = start; i \u0026lt; nums.size(); ++i) { subset.push_back(nums[i]); backtrack(result, subset, nums, i + 1); subset.pop_back(); } } }; Complexity Analysis of backtracking solution Time Complexity : O(N * 2^N) - 2^N subsets and each subset has N elements Space Complexity : O(N) - The depth of the recursion tree can go up to N Explanation of backtracking solution 1. Intuition We can either add an element to the subset or not add it. We will get one subset with element added to it and another subset without the element. Recursion tree for the input [1,2,3] graph TD A[ ] --\u003e B1[1] A[ ] --\u003e C[ ] B1[1] --\u003e D12[1, 2] B1[1] --\u003e E1[1] D12[1, 2] --\u003e F123[1, 2, 3] D12[1, 2] --\u003e G12[1, 2] E1[1] --\u003e L13[1, 3] E1[1] --\u003e M1[1] C[ ] --\u003e R2[2] C[ ] --\u003e S[ ] R2[2] --\u003e T23[2, 3] S[ ] --\u003e Z3[3] 2. Implementation result is the vector of all subsets. For each element in the input array, we add it to the subset and call the backtrack function recursively. In the backtrack function, we add the subset to the result and iterate over the remaining elements in the input array. This is ensured by starting the loop from the start index. Then we remove the current element from the subset once the recursive call returns. Shows the usage of backtracking to ensure proper subset generation.\n","date":"May 21, 2024","permalink":"/blog/posts/previous-solutions/problem-subsets/","summary":"Problem Statement Link - Problem 78 Question Given an integer array nums of unique elements, return all possible subsets (the power set).","title":"Problem 78 Subsets","type":"posts"},{"content":" Problem Statement Link - Problem 1863 Question The XOR total of an array is defined as the bitwise XOR of all its elements, or 0 if the array is empty.\nFor example, the XOR total of the array [2,5,6] is 2 XOR 5 XOR 6 = 1. Given an array nums, return the sum of all XOR totals for every subset of nums.\nNote: Subsets with the same elements should be counted multiple times.\nAn array a is a subset of an array b if a can be obtained from b by deleting some (possibly zero) elements of b.\nExample 1 Input: nums = [1,3] Output: 6 Explanation: The 4 subsets of [1,3] are: - The empty subset has an XOR total of 0. - [1] has an XOR total of 1. - [3] has an XOR total of 3. - [1,3] has an XOR total of 1 XOR 3 = 2. 0 + 1 + 3 + 2 = 6 Example 2 Input: nums = [5,1,6] Output: 28 Explanation: The 8 subsets of [5,1,6] are: - The empty subset has an XOR total of 0. - [5] has an XOR total of 5. - [1] has an XOR total of 1. - [6] has an XOR total of 6. - [5,1] has an XOR total of 5 XOR 1 = 4. - [5,6] has an XOR total of 5 XOR 6 = 3. - [1,6] has an XOR total of 1 XOR 6 = 7. - [5,1,6] has an XOR total of 5 XOR 1 XOR 6 = 2. 0 + 5 + 1 + 6 + 4 + 3 + 7 + 2 = 28 Example 3 Input: nums = [3,4,5,6,7,8] Output: 480 Explanation: The sum of all XOR totals for every subset is 480. Constraints 1 \u0026lt;= nums.length \u0026lt;= 12 1 \u0026lt;= nums[i] \u0026lt;= 20 Solution class Solution { public: int subsetXORSum(vector\u0026lt;int\u0026gt;\u0026amp; nums) { std::ios::sync_with_stdio(false); return calculate(nums, 0, 0); } int calculate(vector\u0026lt;int\u0026gt;\u0026amp; nums, int level, int currentXOR) { if (level == nums.size()) return currentXOR; int include = calculate(nums, level + 1, currentXOR ^ nums[level]); int exclude = calculate(nums, level + 1, currentXOR); return include + exclude; } }; Complexity Analysis Time Complexity: O(2^n), where n is the length of nums. This is because there are 2^n subsets. Space Complexity: O(n), which is the depth of the recursion tree. Explanation 1. Intuition The problem requires calculating the XOR total of all subsets. Each element can either be included or excluded in a subset. We need to explore both possibilities for each element using recursion. Recursion Tree for Example 1 graph TD A[Start nums = 1, 3 currentXOR = 0] --\u003e B[Include 1 currentXOR = 1] A --\u003e C[Exclude 1 currentXOR = 0] B --\u003e D[Include 3 currentXOR = 1 XOR 3 = 2] B --\u003e E[Exclude 3 currentXOR = 1] C --\u003e F[Include 3 currentXOR = 0 XOR 3 = 3] C --\u003e G[Exclude 3 currentXOR = 0] D --\u003e H[Leaf Node currentXOR = 2] E --\u003e I[Leaf Node currentXOR = 1] F --\u003e J[Leaf Node currentXOR = 3] G --\u003e K[Leaf Node currentXOR = 0] 2. Implementation The calculate function is a recursive function that explores all subsets. At each step, we decide whether to include or exclude the current element. The base case is when we\u0026rsquo;ve considered all elements, at which point we return the current XOR total. The final result is the sum of XOR totals for all subsets. 3. Functions subsetXORSum: Initializes the recursive process. calculate: Recursively calculates the XOR total for all subsets, either including or excluding the current element, and sums the results. This problem demonstrates the use of recursion, backtracking and bit manipulation to solve combinatorial problems.\n","date":"May 20, 2024","permalink":"/blog/posts/previous-solutions/problem-sum-of-all-subset-xor-totals/","summary":"Problem Statement Link - Problem 1863 Question The XOR total of an array is defined as the bitwise XOR of all its elements, or 0 if the array is empty.","title":"Problem 1863 Sum of All Subset XOR Totals","type":"posts"},{"content":" Problem Statement Link - Problem 3068 Question There exists an undirected tree with n nodes numbered 0 to n - 1. You are given a 0-indexed 2D integer array edges of length n - 1, where edges[i] = [ui, vi] indicates that there is an edge between nodes ui and vi in the tree. You are also given a positive integer k, and a 0-indexed array of non-negative integers nums of length n, where nums[i] represents the value of the node numbered i.\nAlice wants the sum of values of tree nodes to be maximum, for which Alice can perform the following operation any number of times (including zero) on the tree:\nChoose any edge [u, v] connecting the nodes u and v, and update their values as follows:\nnums[u] = nums[u] XOR k nums[v] = nums[v] XOR k Return the maximum possible sum of the values Alice can achieve by performing the operation any number of times. Example 1 Input: nums = [1,2,1], k = 3, edges = [[0,1],[0,2]] Output: 6 Explanation: Alice can achieve the maximum sum of 6 using a single operation: - Choose the edge [0,2]. nums[0] and nums[2] become: 1 XOR 3 = 2, and the array nums becomes: [1,2,1] -\u0026gt; [2,2,2]. The total sum of values is 2 + 2 + 2 = 6. It can be shown that 6 is the maximum achievable sum of values. flowchart TD id1(input) A((1)) --\u003e B((2)) A --\u003e C((1)) Example 2 Input: nums = [2,3], k = 7, edges = [[0,1]] Output: 9 Explanation: Alice can achieve the maximum sum of 9 using a single operation: - Choose the edge [0,1]. nums[0] becomes: 2 XOR 7 = 5 and nums[1] become: 3 XOR 7 = 4, and the array nums becomes: [2,3] -\u0026gt; [5,4]. The total sum of values is 5 + 4 = 9. It can be shown that 9 is the maximum achievable sum of values. flowchart TD id1(input) A((2)) --\u003e B((3)) Example 3 Input: nums = [7,7,7,7,7,7], k = 3, edges = [[0,1],[0,2],[0,3],[0,4],[0,5]] Output: 42 Explanation: The maximum achievable sum is 42 which can be achieved by Alice performing no operations. flowchart TD id1(input) A((7)) --\u003e B((7)) A --\u003e C((7)) A --\u003e D((7)) A --\u003e E((7)) A --\u003e F((7)) Constraints 2 \u0026lt;= n == nums.length \u0026lt;= 2 * 10*4 1 \u0026lt;= k \u0026lt;= 10^9 0 \u0026lt;= nums[i] \u0026lt;= 10^9 edges.length == n - 1 edges[i].length == 2 0 \u0026lt;= edges[i][0], edges[i][1] \u0026lt;= n - 1 The input is generated such that edges represent a valid tree. Solution static auto fastio = [](){ std::ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); return nullptr; }; class Solution { public: long long maximumValueSum(vector\u0026lt;int\u0026gt;\u0026amp; nums, int k, vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; edges) { long long res = 0; int changes = 0; int minDiff = INT_MAX; for (int num : nums) { int xorNum = num ^ k; if (num \u0026lt; xorNum) { changes++; res += xorNum; } else { res += num; } minDiff = min(minDiff, abs(num - xorNum)); } if (changes % 2 == 1) return res - minDiff; else return res; } }; Complexity Analysis Time Complexity : O(N) Space Complexity : O(1) Explanation 1. Intuition The problem is to find the maximum sum of the values of the nodes in the tree. We know that since its a tree, a path can be found between any two nodes. Hence we need to make sure that only even number of nodes need to be updated. 2. Implementation We iterate over the nodes and calculate the XOR value of the node with k. If the XOR value is greater than the original value, we update the node and increment the changes. We also calculate the minimum difference between the original value and the XOR value. If the number of changes is odd, we subtract the minimum difference from the result. This step is done to make sure that only even number of nodes are updated. Finally, we return the result. There are DP solutions possible for this problem, but the above greedy solution is the most optimal one. -\u0026gt; Click DP Solution In Leetcode ","date":"May 19, 2024","permalink":"/blog/posts/previous-solutions/problem-find-the-maximum-sum-of-node-values/","summary":"Problem Statement Link - Problem 3068 Question There exists an undirected tree with n nodes numbered 0 to n - 1.","title":"Problem 3068 Find the Maximum Sum of Node Values","type":"posts"},{"content":" Problem Statement Link - Problem 979 Question You are given the root of a binary tree with n nodes where each node in the tree has node.val coins. There are n coins in total throughout the whole tree.\nIn one move, we may choose two adjacent nodes and move one coin from one node to another. A move may be from parent to child, or from child to parent.\nReturn the minimum number of moves required to make every node have exactly one coin.\nNote Actually here the word minimum doesnt make any sense. Because we can move coins from parent to child and child to parent. What exactly we need to find is the flow of coins in a given path. Example 1 Input: root = [3,0,0] Output: 2 Explanation: From the root of the tree, we move one coin to its left child, and one coin to its right child. Example 2 Input: root = [0,3,0] Output: 3 Explanation: From the left child of the root, we move two coins to the root [taking two moves]. Then, we move one coin from the root of the tree to the right child. Example 3 (Important case) Since the only constraint is number of coins in the tree is same as number of nodes, it can be distributed in any manner.\nInput: root = [1,0,2] Output: 2 Explanation: From the root of the tree, we move one coin to the left child. From right child, we move one coin to the root. Constraints The number of nodes in the tree is n. 1 \u0026lt;= n \u0026lt;= 100 0 \u0026lt;= node.val \u0026lt;= n The sum of all node.val is n. Solution /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { int countSteps(TreeNode* root, int\u0026amp; step) { if( root == nullptr) return 0; int leftCoin = countSteps(root-\u0026gt;left,step); int rightCoin = countSteps(root-\u0026gt;right,step); step += abs(leftCoin) + abs(rightCoin); return (root-\u0026gt;val -1) + leftCoin + rightCoin; } public: int distributeCoins(TreeNode* root) { int ans = 0; countSteps(root,ans); return ans; } }; Complexity Analysis Time Complexity - O(N) - We are visiting each node once. Space Complexity - O(H) - Height of the tree. Explanation 1. Intuition We just need to find the movement of coins in the tree. If a node has y coins, then it will give y-1 coins to its parent. If a node has 0 coins then it will request 1 coin from its parent. So, we can say that abs(y-1) is the number of coins that will be moved from that node. Number of coins moved from a node is abs(z-1) + Coins from left subtree + Coins from right subtree. 2. Implementation If the root is null, return 0. This handles the base case. Recursively call the function on the left and right subtree. Calculate the number of coins moved from the left and right subtree. Store it in leftCoin and rightCoin. Store total steps so far done in step. Calculate the number of coins moved from the current node using the formula root-\u0026gt;val - 1 + leftCoin + rightCoin. ","date":"May 19, 2024","permalink":"/blog/posts/previous-solutions/problem-distribute-coins-in-binary-tree/","summary":"Problem Statement Link - Problem 979 Question You are given the root of a binary tree with n nodes where each node in the tree has node.","title":"Problem 979 Distribute Coins in Binary Tree","type":"posts"},{"content":" Problem Statement Link - Problem 1325 Question Given a binary tree root and an integer target, delete all the leaf nodes with value target.\nNote that once you delete a leaf node with value target, if its parent node becomes a leaf node and has the value target, it should also be deleted (you need to continue doing that until you cannot).\nExample 1 Input: root = [1,2,3,2,null,2,4], target = 2 Output: [1,null,3,null,4] Explanation: Leaf nodes in green with value (target = 2) are removed (Picture in left). After removing, new nodes become leaf nodes with value (target = 2) (Picture in center). flowchart TD id1(input) A((1)) --\u003e B((2)) A --\u003e C((3)) C --\u003e D((2)) D --\u003e E((2)) D --\u003e F((4)) id2(Output) G((1)) --\u003eH((3)) H --\u003e I((4)) Example 2 Input: root = [1,3,3,3,2], target = 3 Output: [1,3,null,null,2] flowchart TD id1(input) A((1)) --\u003e B((3)) A --\u003e C((3)) C --\u003e D((3)) D --\u003e E((3)) D --\u003e F((2)) id2(Output) G((1)) --\u003eH((3)) H --\u003e I((2)) Example 3 Input: root = [1,2,null,2,null,2], target = 2 Output: [1] Explanation: Leaf nodes in green with value (target = 2) are removed at each step. flowchart TD id1(input) A((1)) --\u003e B((2)) A --\u003e C((2)) C --\u003e D((2)) id2(Output) E((1)) Constraints The number of nodes in the tree is in the range [1, 3000]. 1 \u0026lt;= Node.val, target \u0026lt;= 1000 Solution /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: TreeNode* removeLeafNodes(TreeNode* root, int target) { if (!root) return nullptr; root-\u0026gt;left = removeLeafNodes(root-\u0026gt;left, target); root-\u0026gt;right = removeLeafNodes(root-\u0026gt;right, target); if (!root-\u0026gt;left \u0026amp;\u0026amp; !root-\u0026gt;right \u0026amp;\u0026amp; root-\u0026gt;val == target) return nullptr; return root; } }; Complexity Analysis Time complexity - O(N) Space complexity - O(H) Explanation 1. Intuition This can be solved using DFS. We will traverse the tree in post-order fashion. If the node is leaf and has the value equal to the target, Remove it. Otherwise, return the node. 2. Implementation If the root is null, return null. Recursively call the function on the left and right subtree. By this we will reach the leaf nodes. If the leaf node has the value equal to the target, return null. Otherwise, return the node. ","date":"May 19, 2024","permalink":"/blog/posts/previous-solutions/problem-delete-leaves-with-a-given-value/","summary":"Problem Statement Link - Problem 1325 Question Given a binary tree root and an integer target, delete all the leaf nodes with value target.","title":"Problem 1325 Delete Leaves With a Given Value","type":"posts"},{"content":" Problem Statement Link - Problem 2331 Question You are given the root of a full binary tree with the following properties:\nLeaf nodes have either the value 0 or 1, where 0 represents False and 1 represents True. Non-leaf nodes have either the value 2 or 3, where 2 represents the boolean OR and 3 represents the boolean AND. The evaluation of a node is as follows:\nIf the node is a leaf node, the evaluation is the value of the node, i.e. True or False. Otherwise, evaluate the node\u0026rsquo;s two children and apply the boolean operation of its value with the children\u0026rsquo;s evaluations. Return the boolean result of evaluating the root node. A full binary tree is a binary tree where each node has either 0 or 2 children.\nA leaf node is a node that has zero children.\nExample 1 Input graph TD A((2))--\u003eB((1)) A--\u003eC((3)) C((3))--\u003eD((0)) C((3))--\u003eE((1)) F((OR))--\u003eG((True)) F--\u003eH((AND)) H--\u003eI((False)) H--\u003eJ((True)) Input: root = [2,1,3,null,null,0,1] Output: true Explanation: The above diagram illustrates the evaluation process. The AND node evaluates to False AND True = False. The OR node evaluates to True OR False = True. The root node evaluates to True, so we return true. Example 2 Input: root = [0] Output: false Explanation: The root node is a leaf node and it evaluates to false, so we return false. Constraints The number of nodes in the tree is in the range [1, 1000]. 0 \u0026lt;= Node.val \u0026lt;= 3 Every node has either 0 or 2 children. Leaf nodes have a value of 0 or 1. Non-leaf nodes have a value of 2 or 3. Solution /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: bool evaluateTree(TreeNode* root) { if(root-\u0026gt;left == nullptr \u0026amp;\u0026amp; root-\u0026gt;right == nullptr) return root-\u0026gt;val; else { if(root-\u0026gt;val == 2) return evaluateTree(root-\u0026gt;left) || evaluateTree(root-\u0026gt;right); else return evaluateTree(root-\u0026gt;left) \u0026amp;\u0026amp; evaluateTree(root-\u0026gt;right); } } }; Complexity Analysis Time: O(N) Space: O(N) Explanation 1. Intuition To evalute any node we need to evaluate its left and right child. There is no need to evaluate the leaf nodes as they are the base case. Using this we can develop a DFS based solution. 2. Implementation The evaluateTree function is used to evaluate the tree. If the node is a leaf node, we return the value of the node. Otherwise, we evaluate the left and right child and apply the operation based on the value of the node. If the value of the node is 2, we apply OR operation. If the value of the node is 3, we apply AND operation. ","date":"May 17, 2024","permalink":"/blog/posts/previous-solutions/problem-evaluate-boolean-binary-tree/","summary":"Problem Statement Link - Problem 2331 Question You are given the root of a full binary tree with the following properties:","title":"Problem 2331 Evaluate Boolean Binary Tree","type":"posts"},{"content":" Problem Statement Link - Problem 1219 Question In a gold mine grid of size m x n, each cell in this mine has an integer representing the amount of gold in that cell, 0 if it is empty.\nReturn the maximum amount of gold you can collect under the conditions:\nEvery time you are located in a cell you will collect all the gold in that cell. From your position, you can walk one step to the left, right, up, or down. You can\u0026rsquo;t visit the same cell more than once. Never visit a cell with 0 gold. You can start and stop collecting gold from any position in the grid that has some gold. Example 1 Input: grid = [[0,6,0],[5,8,7],[0,9,0]] Output: 24 Explanation: [[0,6,0], [5,8,7], [0,9,0]] Path to get the maximum gold, 9 -\u0026gt; 8 -\u0026gt; 7. Example 2 Input: grid = [[1,0,7],[2,0,6],[3,4,5],[0,3,0],[9,0,20]] Output: 28 Explanation: [[1,0,7], [2,0,6], [3,4,5], [0,3,0], [9,0,20]] Path to get the maximum gold, 1 -\u0026gt; 2 -\u0026gt; 3 -\u0026gt; 4 -\u0026gt; 5 -\u0026gt; 6 -\u0026gt; 7. Constraints m == grid.length n == grid[i].length 1 \u0026lt;= m, n \u0026lt;= 15 0 \u0026lt;= grid[i][j] \u0026lt;= 100 There are at most 25 cells containing gold. Solution class Solution { const vector\u0026lt;pair\u0026lt;int,int\u0026gt;\u0026gt;direc = {{1,0},{-1,0},{0,-1},{0,1}}; int checkIfAllNonZeros(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; grid){ int count = 0; for(int i=0; i\u0026lt;grid.size(); i++){ for(int j=0; j\u0026lt;grid[0].size(); j++){ if(grid[i][j] != 0) count += grid[i][j]; else return 0; } } return count; } int dfs(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; grid, int x, int y, const int\u0026amp; row, const int\u0026amp; col) { if(x\u0026lt;0 || y\u0026lt;0 || x\u0026gt;=row || y\u0026gt;= col || grid[x][y] == 0) return 0; int val = grid[x][y]; grid[x][y] = 0; int localMax = val; for(const pair\u0026lt;int,int\u0026gt;\u0026amp; it:direc) { localMax = max(localMax, val + dfs(grid,x + it.first,y + it.second,row,col)); } grid[x][y] = val; return localMax; } public: int getMaximumGold(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; grid) { std::ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); int row = grid.size(), col = grid[0].size(); int maxVal = 0; int count = checkIfAllNonZeros(grid); if(count) { return count; } for(int i = 0; i\u0026lt;row; i++) { for(int j = 0; j\u0026lt;col; j++) { if(grid[i][j] != 0) maxVal = max(maxVal, dfs(grid,i,j,row,col)); } } return maxVal; } }; Complexity Analysis Time Complexity: O(4^{mn}). Space Complexity: O(mn). Explanation 1. Intuition We can start from any cell in the grid and move in any direction (up, down, left, right) to collect gold. We can\u0026rsquo;t visit the same cell more than once. We can\u0026rsquo;t visit a cell with 0 gold. We need to find the maximum amount of gold we can collect. This constraints suggest that we need to explore every possible path to find the maximum gold. Hence we need DFS to explore every possible path. But we need to backtrack so that a path once explored does not stop from exploring other paths. 2. Implementation The dfs function is used to explore every possible path. The checkIfAllNonZeros function is used to check if all the cells have non-zero gold. The edge case of all cells having non-zero gold is handled separately by the checkIfAllNonZeros function. The direc vector is used to move in all four directions. 3. Functions dfs function is used to explore every possible path.\nThe input to the dfs function is the grid, the current cell\u0026rsquo;s row and column, and the total number of rows and columns.\nIf the current cell is out of bounds or has 0 gold, we return 0.\nElse we store the current cell\u0026rsquo;s gold in a variable val.\nThen the current cell\u0026rsquo;s gold is set to 0.\nWe store the current cell\u0026rsquo;s gold in a variable localMax.\nRecursively we move in all four directions and store the maximum gold in the localMax variable.\nIf all 4 sides are 0 then the localMax will be equal to the current cell\u0026rsquo;s gold.\nWe restore the current cell\u0026rsquo;s gold to the original value.\nThis is to let other paths explore the current cell.\nWe return the localMax variable.\ngetMaximumGold function is used to find the maximum gold.\nThe input to the getMaximumGold function is the grid.\nWe initialize the row and col variables to store the total number of rows and columns.\nWe initialize the maxVal variable to store the maximum gold.\nWe check if all the cells have non-zero gold by calling the checkIfAllNonZeros function.\nIf all the cells have non-zero gold then we return the sum of all the cells.\nElse we iterate over all the cells and call the dfs function to find the maximum gold.\nWe return the maxVal variable.\nThis problem enables us to apply DFS and backtracking to a 2 dimensional matrix.\n","date":"May 14, 2024","permalink":"/blog/posts/previous-solutions/problem-path-with-maximum-gold/","summary":"Problem Statement Link - Problem 1219 Question In a gold mine grid of size m x n, each cell in this mine has an integer representing the amount of gold in that cell, 0 if it is empty.","title":"Problem 1219 Path With Maximum Gold","type":"posts"},{"content":" Problem Statement Link - Problem 861 Question You are given an m x n binary matrix grid.\nA move consists of choosing any row or column and toggling each value in that row or column (i.e., changing all 0\u0026rsquo;s to 1\u0026rsquo;s, and all 1\u0026rsquo;s to 0\u0026rsquo;s).\nEvery row of the matrix is interpreted as a binary number, and the score of the matrix is the sum of these numbers.\nReturn the highest possible score after making any number of moves (including zero moves).\nExample 1 Input: grid = [[0,0,1,1],[1,0,1,0],[1,1,0,0]] Output: 39 Explanation: 0b1111 + 0b1001 + 0b1111 = 15 + 9 + 15 = 39 Example 2 Input: grid = [[0]] Output: 1 Constraints m == grid.length n == grid[i].length 1 \u0026lt;= m, n \u0026lt;= 20 grid[i][j] is either 0 or 1. Solution class Solution { public: int matrixScore(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; grid) { std::ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); for(int row =0; row\u0026lt;grid.size(); row++) { if(grid[row][0] == 0) { for(int col = 0; col\u0026lt;grid[0].size(); col++) { grid[row][col] = !grid[row][col]; } } } int zero = 0, one = 0; for(int col=0; col\u0026lt;grid[0].size(); col++) { for(int row=0; row\u0026lt;grid.size(); row++) { if(grid[row][col] == 0) zero++; else one++; } vector\u0026lt;int\u0026gt;zeroCnt(grid[0].size(),0); vector\u0026lt;int\u0026gt;oneCnt(grid[0].size(),0); if(zero \u0026gt; one ) { for(int row=0; row\u0026lt;grid.size(); row++) { grid[row][col] = !grid[row][col]; } } one = 0; zero = 0; } int answer = 0; int temp,base; for(int row = 0; row\u0026lt;grid.size(); row++) { temp = 0; base = 0; for(int col = grid[0].size()-1; col\u0026gt;=0; col--) { if(grid[row][col]) { temp+= (int)pow(2,base); } base++; } answer+= temp; } return answer; } }; Complexity Analysis Time Complexity - O(n^2) Space Complexity - O(1) Explanation 1. Intuition The goal is to maximize the final score of the matrix ie. maximize the sum of the binary numbers formed by the rows of the matrix. We can make a binary number maximum by making the most significant bit of the number 1. Example : 0111 is always less than 1000. Then we can greedily make the other bits of the number into 1 provided it increases the sum of the binary numbers formed by the rows of the matrix. We can iterate over the columns and check if the number of 0's in the column is greater than the number of 1's then we can flip the column. This flipping is guranteed to increase the sum of the binary numbers formed by the rows of the matrix. Example : [[1,0,1],[1,0,0]], if we flip 2nd column then the matrix becomes [[1,1,1],[1,1,0]] and the sum of the binary numbers formed by the rows of the matrix is 7+6 = 13 which is greater than 5+4 = 9. 2. Implementation Iterate over the rows of the matrix and if the first element of the row is 0 then flip the row. Iterate over the columns of the matrix and if the number of 0's in the column is greater than the number of 1's then flip the column. Calculate the sum of the binary numbers formed by the rows of the matrix and return the sum. Shows the implementation of greedy technique to maximize the sum of the binary numbers formed by the rows of the matrix.\n","date":"May 13, 2024","permalink":"/blog/posts/previous-solutions/problem-score-after-flipping-matrix/","summary":"Problem Statement Link - Problem 861 Question You are given an m x n binary matrix grid.","title":"Problem 861 Score After Flipping Matrix","type":"posts"},{"content":" Problem Statement Link - Problem 2373 Question You are given an n x n integer matrix grid.\nGenerate an integer matrix maxLocal of size (n - 2) x (n - 2) such that:\nmaxLocal[i][j] is equal to the largest value of the 3 x 3 matrix in grid centered around row i + 1 and column j + 1. In other words, we want to find the largest value in every contiguous 3 x 3 matrix in grid.\nReturn the generated matrix.\nExample 1 Input: grid = [[9,9,8,1],[5,6,2,6],[8,2,6,4],[6,2,2,2]] Output: [[9,9],[8,6]] Explanation: The diagram above shows the original matrix and the generated matrix. Each value in the generated matrix corresponds to the largest value of a contiguous 3 x 3 matrix in grid. Example 2 Input: grid = [[1,1,1,1,1],[1,1,1,1,1],[1,1,2,1,1],[1,1,1,1,1],[1,1,1,1,1]] Output: [[2,2,2],[2,2,2],[2,2,2]] Explanation: Notice that the 2 is contained within every contiguous 3 x 3 matrix in grid. Constraints n == grid.length == grid[i].length 3 \u0026lt;= n \u0026lt;= 100 1 \u0026lt;= grid[i][j] \u0026lt;= 100 Solution class Solution { public: vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; largestLocal(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; grid) { vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;ans(grid.size()-2,vector\u0026lt;int\u0026gt;(grid[0].size()-2)); int locMax = INT_MIN; for(int row = 0; row \u0026lt; grid.size()-2; row++) { for(int col = 0; col \u0026lt; grid[0].size()-2; col++) { for(int i = row; i\u0026lt;row+3; i++) { for(int j = col; j\u0026lt;col+3; j++) locMax = max(locMax,grid[i][j]); } ans[row][col] = locMax; locMax = INT_MIN; } } return ans; } }; Complexity Analysis Time Complexity - O(n^2) Space Complexity - O(n^2) We are iterating over a 3x3 matrix each time thats 9 units and we have to visit each cell of the matrix so the time complexity is 9*n^2 which is O(n^2). The space complexity is O(n^2) as we are storing the result in a 2D vector of size (n-2) x (n-2). Explanation 1. Intuition We need to find the largest value in every contiguous 3 x 3 matrix in grid. We can iterate over the matrix and find the largest value in every 3 x 3 matrix. We can store the result in a new matrix and return it. To iterate over each contiguous 3 x 3 matrix, we need to iterate over the rows and columns of the matrix. 2. Implementation Initialize a 2D vector ans of size (n-2) x (n-2) to store the result. Initialize a variable locMax to store the maximum value in the 3 x 3 matrix. Iterate over the rows from 0 to n-2 and columns from 0 to n-2. This will give us the starting point of each 3 x 3 matrix. Iterate over the rows from row to row+3 and columns from col to col+3. This will give us the 3 x 3 matrix. Find the maximum value in the 3 x 3 matrix and store it in locMax. Store the maximum value in the result matrix ans[row][col]. Reset locMax to INT_MIN for the next 3 x 3 matrix. Return the result matrix ans. Intresting fact This problem closely simulates a very powerful ML algorithm in CNNs called as Max Pooling. Max pooling is a sample-based discretization process. The objective is to down-sample an input representation (image, hidden-layer output matrix, etc.), reducing its dimensionality and allowing for assumptions to be made about features contained in the sub-regions binned.\nKey terms in Max Pooling:\nPooling Layer: The pooling layer is a new layer added after the convolutional layer. It is used to reduce the spatial dimensions of the output volume. Max Pooling: Max pooling is a pooling operation that selects the maximum element from the region of the feature map covered by the filter. Thus, the output after max-pooling is the maximum value of the region covered by the filter. Filter: The filter is a matrix that is used to extract features from the input image. The filter is also known as a kernel. The filter is applied to the input image to produce the feature map. In this case, the filter is of size 3x3. Stride: The stride is the number of pixels by which the filter is moved over the input image. The stride is used to reduce the spatial dimensions of the output volume. In this case, the stride is 1. This problem simulates Max pooling. This shows a real world application of a DSA problem.\n","date":"May 12, 2024","permalink":"/blog/posts/previous-solutions/problem-largest-local-values-in-a-matrix/","summary":"Problem Statement Link - Problem 2373 Question You are given an n x n integer matrix grid.","title":"Problem 2373 Largest Local Values in a Matrix","type":"posts"},{"content":" Problem Statement Link - Problem 786 Question You are given a sorted integer array arr containing 1 and prime numbers, where all the integers of arr are unique. You are also given an integer k.\nFor every i and j where 0 \u0026lt;= i \u0026lt; j \u0026lt; arr.length, we consider the fraction arr[i] / arr[j].\nReturn the kth smallest fraction considered. Return your answer as an array of integers of size 2, where answer[0] == arr[i] and answer[1] == arr[j].\nExample 1 Input: arr = [1,2,3,5], k = 3 Output: [2,5] Explanation: The fractions to be considered in sorted order are: 1/5, 1/3, 2/5, 1/2, 3/5, and 2/3. The third fraction is 2/5. Example 2 Input: arr = [1,7], k = 1 Output: [1,7] Constraints 2 \u0026lt;= arr.length \u0026lt;= 1000 1 \u0026lt;= arr[i] \u0026lt;= 3 * 10^4 arr[0] == 1 arr[i] is a prime number for i \u0026gt; 0. All the numbers of arr are unique and sorted in strictly increasing order. 1 \u0026lt;= k \u0026lt;= arr.length * (arr.length - 1) / 2 Solution class Solution { public: vector\u0026lt;int\u0026gt; kthSmallestPrimeFraction(vector\u0026lt;int\u0026gt;\u0026amp; arr, int k) { std::ios::sync_with_stdio(false); cin.tie(0); cout.tie(0); auto comparePair = [](const pair\u0026lt;int,int\u0026gt;\u0026amp; a,const pair\u0026lt;int,int\u0026gt;\u0026amp; b) { return a.first*b.second \u0026gt; b.first*a.second; }; priority_queue\u0026lt;pair\u0026lt;int,int\u0026gt;,vector\u0026lt;pair\u0026lt;int,int\u0026gt;\u0026gt;, decltype(comparePair)\u0026gt;minheap; for(int i = 0;i\u0026lt;arr.size();i++) { for(int j=i+1;j\u0026lt;arr.size();j++) { minheap.push(make_pair(arr[i],arr[j])); } } vector\u0026lt;int\u0026gt;answer(2,0); while(k\u0026gt;1 \u0026amp;\u0026amp; !minheap.empty()) { k--; minheap.pop(); } answer[0] = minheap.top().first; answer[1] = minheap.top().second; return answer; } }; Complexity Analysis Time Complexity - O(n^2logn) Space Complexity - O(n^2) Time complexity of adding a node to the heap is O(logn) and we are adding n*(n-1)/2 nodes to the heap. So, the time complexity is O(n^2logn). Space complexity is O(n^2) because we are storing n*(n-1)/2 pairs in the heap. Explanation 1. Intuition Since we need to find the kth smallest fraction, we can use a min heap to store the fractions. For that we need to have all the possible fractions in the heap. We can generate all the possible fractions by iterating over the array and adding the fractions to the heap. 2. Implementation We need to have a min heap whose contents are pairs of integers.\nEach pair {a,b} in the heap represents the fraction a/b.\nWe need to define a custom comparator for the heap, because by default the heap will be a max heap.\nThe function comparePair checks if the fraction a/b is smaller than the fraction c/d.\nThe comparator returns false if a*d \u0026gt; b*c, which means that the fraction a/b is smaller than c/d.\nSince by default the heap is a max heap, we need to make sure that the comparator returns false if a*d \u0026gt; b*c.\nThen the node which has {a,b} will move up in the heap than the node which has {c,d}.\nWe will iterate over the array and generate all the possible fractions.\nFirst loop will set the numerator and the second loop will set the denominator.\nWe will add the fraction to the heap.\nWe will pop k-1 elements from the heap.\nThe kth element will be the kth smallest fraction.\nWe will return the kth smallest fraction as answer[0] and answer[1].\nAdditional Notes This problem can also be solved using binary search. We can use binary search to find the fraction that is the kth smallest. class Solution { public: vector\u0026lt;int\u0026gt; kthSmallestPrimeFraction(vector\u0026lt;int\u0026gt;\u0026amp; arr, int k) { const int n = arr.size(); double l = 0.0; double r = 1.0; while (l \u0026lt; r) { const double m = (l + r) / 2.0; int fractionsNoGreaterThanM = 0; int p = 0; int q = 1; // For each index i, find the first index j s.t. arr[i] / arr[j] \u0026lt;= m, // so fractionsNoGreaterThanM for index i will be n - j. for (int i = 0, j = 1; i \u0026lt; n; ++i) { while (j \u0026lt; n \u0026amp;\u0026amp; arr[i] \u0026gt; m * arr[j]) ++j; if (j == n) break; fractionsNoGreaterThanM += n - j; if (p * arr[j] \u0026lt; q * arr[i]) { p = arr[i]; q = arr[j]; } } if (fractionsNoGreaterThanM == k) return {p, q}; if (fractionsNoGreaterThanM \u0026gt; k) r = m; else l = m; } throw; } }; The above code uses binary search to find the kth smallest fraction. We start with the range [0,1] and find the middle value. We iterate over the array and find the number of fractions that are less than or equal to m. If the number of fractions is equal to k, we return the fraction. If the number of fractions is greater than k, we reduce the range to [l,m]. If the number of fractions is less than k, we increase the range to [m,r]. Time Complexity - O(nlogn) Space Complexity - O(1) This problem helps us to understand how to use a min heap to solve a problem that requires finding the kth smallest element.\n","date":"May 10, 2024","permalink":"/blog/posts/previous-solutions/problem-k-th-smallest-prime-fraction/","summary":"Problem Statement Link - Problem 786 Question You are given a sorted integer array arr containing 1 and prime numbers, where all the integers of arr are unique.","title":"Problem 786 K th Smallest Prime Fraction","type":"posts"},{"content":" Problem Statement Link - Problem 3075 Question You are given an array happiness of length n, and a positive integer k.\nThere are n children standing in a queue, where the ith child has happiness value happiness[i]. You want to select k children from these n children in k turns.\nIn each turn, when you select a child, the happiness value of all the children that have not been selected till now decreases by 1. Note that the happiness value cannot become negative and gets decremented only if it is positive.\nReturn the maximum sum of the happiness values of the selected children you can achieve by selecting k children.\nExample 1 Input: happiness = [1,2,3], k = 2 Output: 4 Explanation: We can pick 2 children in the following way: - Pick the child with the happiness value == 3. The happiness value of the remaining children becomes [0,1]. - Pick the child with the happiness value == 1. The happiness value of the remaining child becomes [0]. - Note that the happiness value cannot become less than 0. The sum of the happiness values of the selected children is 3 + 1 = 4. Example 2 Input: happiness = [1,1,1,1], k = 2 Output: 1 Explanation: We can pick 2 children in the following way: - Pick any child with the happiness value == 1. The happiness value of the remaining children becomes [0,0,0]. - Pick the child with the happiness value == 0. The happiness value of the remaining child becomes [0,0]. The sum of the happiness values of the selected children is 1 + 0 = 1. Example 3 Input: happiness = [2,3,4,5], k = 1 Output: 5 Explanation: We can pick 1 child in the following way: - Pick the child with the happiness value == 5. The happiness value of the remaining children becomes [1,2,3]. The sum of the happiness values of the selected children is 5. Constraints 1 \u0026lt;= n == happiness.length \u0026lt;= 2 * 10^5 1 \u0026lt;= happiness[i] \u0026lt;= 10^8 1 \u0026lt;= k \u0026lt;= n Solution class Solution { public: long long maximumHappinessSum(vector\u0026lt;int\u0026gt;\u0026amp; happiness, int k) { std::ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); priority_queue\u0026lt;int\u0026gt;heap; for(const int it:happiness) heap.push(it); long long count = 0; long long answer = 0; while(k\u0026gt;0 \u0026amp;\u0026amp; !heap.empty()) { answer = ((heap.top()-count)\u0026gt;=0)?answer+heap.top()-count:answer+0; heap.pop(); k--; count++; } return answer; } }; Complexity Analysis Time: O(nlogn) Space: O(n) Explanation 1. Intuition Since the order of selection does not matter, we can select the children with the highest happiness values first. this greedy approach will ensure that we maximize the sum of happiness values of the selected children. For this we need the array in sorted order, so we use a max heap to store the happiness values of the children. 2. Implementation We use a max heap to store the happiness values of the children. We iterate over the heap and select the children with the highest happiness values. We keep track of the count to ensure that the happiness value of the children that have not been selected decreases by 1. We will check if the difference between the happiness value and the count is greater than or equal to 0, if yes we add the difference to the answer, else we add 0. This makes sure that the happiness value does not become negative. We return the answer. Alternate Approach We can use the sorted vector to store the happiness values of the children. class Solution { public: long long maximumHappinessSum(vector\u0026lt;int\u0026gt;\u0026amp; happiness, int k) { ios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0); sort(happiness.begin(), happiness.end(), greater\u0026lt;int\u0026gt;()); long long sum = 0; for(int i = 0; i \u0026lt; k; i++) { happiness[i] = max(0, happiness[i]-i); sum += happiness[i]; } return sum; } }; This will be faster than the heap approach, as we do not need to maintain the heap.\nThis problem demonstrates the use of a max heap to solve a greedy problem.\n","date":"May 9, 2024","permalink":"/blog/posts/previous-solutions/problem-maximize-happiness-of-selected-children/","summary":"Problem Statement Link - Problem 3075 Question You are given an array happiness of length n, and a positive integer k.","title":"Problem 3075 Maximize Happiness of Selected Children","type":"posts"},{"content":" Problem Statement Link - Problem 506 Question You are given an integer array score of size n, where score[i] is the score of the ith athlete in a competition. All the scores are guaranteed to be unique.\nThe athletes are placed based on their scores, where the 1st place athlete has the highest score, the 2nd place athlete has the 2nd highest score, and so on. The placement of each athlete determines their rank:\nThe 1st place athlete\u0026rsquo;s rank is \u0026quot;Gold Medal\u0026quot;. The 2nd place athlete\u0026rsquo;s rank is \u0026quot;Silver Medal\u0026quot;. The 3rd place athlete\u0026rsquo;s rank is \u0026quot;Bronze Medal\u0026quot;. For the 4th place to the nth place athlete, their rank is their placement number (i.e., the xth place athlete\u0026rsquo;s rank is \u0026quot;x\u0026quot;). Return an array answer of size n where answer[i] is the rank of the ith athlete.\nExample 1 Input: score = [5,4,3,2,1] Output: [\u0026#34;Gold Medal\u0026#34;,\u0026#34;Silver Medal\u0026#34;,\u0026#34;Bronze Medal\u0026#34;,\u0026#34;4\u0026#34;,\u0026#34;5\u0026#34;] Explanation: The placements are [1st, 2nd, 3rd, 4th, 5th]. Example 2 Input: score = [10,3,8,9,4] Output: [\u0026#34;Gold Medal\u0026#34;,\u0026#34;5\u0026#34;,\u0026#34;Bronze Medal\u0026#34;,\u0026#34;Silver Medal\u0026#34;,\u0026#34;4\u0026#34;] Explanation: The placements are [1st, 5th, 3rd, 2nd, 4th]. Constraints n == score.length 1 \u0026lt;= n \u0026lt;= 10^4 0 \u0026lt;= score[i] \u0026lt;= 10^6 All the values in score are unique. Solution class Solution { public: vector\u0026lt;string\u0026gt; findRelativeRanks(vector\u0026lt;int\u0026gt;\u0026amp; score) { auto comparePair = [](const pair\u0026lt;int,int\u0026gt;\u0026amp; a,const pair\u0026lt;int,int\u0026gt;\u0026amp; b) { return a.first\u0026lt;b.first; }; priority_queue\u0026lt;pair\u0026lt;int,int\u0026gt;, vector\u0026lt;pair\u0026lt;int,int\u0026gt;\u0026gt;, decltype(comparePair)\u0026gt; maxHeap; for(int i = 0;i\u0026lt;score.size();i++) maxHeap.push(make_pair(score[i],i)); vector\u0026lt;string\u0026gt;answer(score.size()); pair\u0026lt;int,int\u0026gt; holder; int place = 0; vector\u0026lt;string\u0026gt;places = {\u0026#34;Gold Medal\u0026#34;,\u0026#34;Silver Medal\u0026#34;,\u0026#34;Bronze Medal\u0026#34;}; while(!maxHeap.empty() \u0026amp;\u0026amp; place \u0026lt;3) { holder = maxHeap.top(); maxHeap.pop(); answer[holder.second] = places[place]; place++; } while(!maxHeap.empty()) { holder = maxHeap.top(); maxHeap.pop(); answer[holder.second] = to_string(++place); } return answer; } }; Complexity Analysis Time: O(nlogn) Space: O(n) Explanation 1. Intuition Since the scores need to be relatively ordered in decreasing order, along with the index which they occured. We can use a priority queue to store the scores and their index. We would need to have a custom comparator to compare the scores. This needs to be a max heap, so that we can get the highest score first. 2. Implementation We can use a priority queue to store the scores and their index. We can use a custom comparator to compare the scores. The custom comparator comparePair compares the pair\u0026lt;score,index_which_it_occured\u0026gt;. The lambda function comparePair does a.first\u0026lt;b.first because internally the priority queue is a max heap, hence the highest score would be at the top. The custom comparator ensures that the the pair with highest score is at the top of the heap. The keyword decltype is used to get the type of the lambda function. Priority queue needs to have a callable object as a comparator, hence we pass the lambda function comparePair. We will first push the scores and their index into the priority queue. We will have a vector of strings answer to store the ranks of the athletes. We will have a variable place to keep track of the rank. We will have a vector of strings places to store the medals of the athletes. We will iterate the priority queue until the place is less than 3. We will pop the top element from the priority queue. We will assign the rank to the athlete based on the place. 1st place athlete\u0026rsquo;s rank is \u0026quot;Gold Medal\u0026quot;. 2nd place athlete\u0026rsquo;s rank is \u0026quot;Silver Medal\u0026quot;. 3rd place athlete\u0026rsquo;s rank is \u0026quot;Bronze Medal\u0026quot;. We will increment the place after assigning the rank each time. Then check if there are any more athletes left. If there are any athletes left, assign the rank based on the place. The ranks is a string hence use the to_string function to convert the integer to string. Return the answer vector. Alternate Solution A solution with a map can be used to store the scores and their index. class Solution { public: vector\u0026lt;string\u0026gt; findRelativeRanks(vector\u0026lt;int\u0026gt;\u0026amp; score) { int n = score.size(); map\u0026lt;int, int\u0026gt; mp1; vector\u0026lt;string\u0026gt; result(n); for (int i = 0; i \u0026lt; n; i++) { mp1[score[i]] = i; } sort(score.begin(), score.end(), greater\u0026lt;int\u0026gt;()); for (int i = 0; i \u0026lt; n; i++) { if (i == 0) { result[mp1[score[i]]] = \u0026#34;Gold Medal\u0026#34;; } else if (i == 1) { result[mp1[score[i]]] = \u0026#34;Silver Medal\u0026#34;; } else if (i == 2) { result[mp1[score[i]]] = \u0026#34;Bronze Medal\u0026#34;; } else { result[mp1[score[i]]] = to_string(i + 1); } } return result; } }; Time Complexity: O(nlogn) Space Complexity: O(n) A solution with built in comparator for priority queue can be used. class Solution { public: vector\u0026lt;string\u0026gt; findRelativeRanks(vector\u0026lt;int\u0026gt;\u0026amp; score) { std::ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); priority_queue\u0026lt;pair\u0026lt;int,int\u0026gt;\u0026gt; maxHeap; for(int i = 0;i\u0026lt;score.size();i++) maxHeap.push(make_pair(score[i],i)); vector\u0026lt;string\u0026gt;answer(score.size()); pair\u0026lt;int,int\u0026gt; holder; int place = 0; vector\u0026lt;string\u0026gt;places = {\u0026#34;Gold Medal\u0026#34;,\u0026#34;Silver Medal\u0026#34;,\u0026#34;Bronze Medal\u0026#34;}; while(!maxHeap.empty() \u0026amp;\u0026amp; place \u0026lt;3) { holder = maxHeap.top(); maxHeap.pop(); answer[holder.second] = places[place]; place++; } while(!maxHeap.empty()) { holder = maxHeap.top(); maxHeap.pop(); answer[holder.second] = to_string(++place); } return answer; } }; This problem demonstrtaes the use of priority queue and custom comparators to solve the problem. The alternate solutions are also provided for the same problem.\n","date":"May 8, 2024","permalink":"/blog/posts/previous-solutions/problem-relative-ranks/","summary":"Problem Statement Link - Problem 506 Question You are given an integer array score of size n, where score[i] is the score of the ith athlete in a competition.","title":"Problem 506 Relative Ranks","type":"posts"},{"content":" Problem Statement Link - Problem 2816 Question You are given the head of a non-empty linked list representing a non-negative integer without leading zeroes.\nReturn the head of the linked list after doubling it\nExample 1 Input graph LR A((1))--\u003eB((8)) B--\u003eC((9)) Output graph LR A((3))--\u003eB((7)) B--\u003eC((8)) Input: head = [1,8,9] Output: [3,7,8] Explanation: The figure above corresponds to the given linked list which represents the number 189. Hence, the returned linked list represents the number 189 * 2 = 378. Example 2 Input graph LR A((9))--\u003eB((9)) B--\u003eC((9)) Output graph LR A((1))--\u003eB((9)) B--\u003eC((9)) C--\u003eD((8)) Input: head = [9,9,9] Output: [1,9,9,8] Explanation: The figure above corresponds to the given linked list which represents the number 999. Hence, the returned linked list reprersents the number 999 * 2 = 1998. Constraints The number of nodes in the list is in the range [1, 10^4]. 0 \u0026lt;= Node.val \u0026lt;= 9 The input is generated such that the list represents a number that does not have leading zeros, except the number 0 itself. Solution /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ class Solution { public: ListNode* doubleIt(ListNode* head) { std::ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); stack\u0026lt;ListNode*\u0026gt;st; ListNode* temp = head; while(temp!=nullptr) { st.push(temp); temp=temp-\u0026gt;next; } int carry = 0, newVal = 0; while(!st.empty()) { temp = st.top(); st.pop(); newVal = 2*temp-\u0026gt;val + carry; carry = newVal/10; newVal = newVal%10; //cout\u0026lt;\u0026lt;carry\u0026lt;\u0026lt;newVal\u0026lt;\u0026lt;endl; temp-\u0026gt;val = newVal; } if(carry) { ListNode* newhead = new ListNode(carry,head); return newhead; } return head; } }; Complexity Time : O(n) Space : O(n) Explanation 1. Intuition We need to iterate the linked list in reverse order to double the number. From the last node we need to double the value and keep track of the carry. We can use a stack to store the nodes in reverse order. 2. Implementation Have a stack to store the nodes in reverse order. Push all the nodes into the stack. Pop the nodes from the stack and double the value of the node. Calculate the carry and the new value. Carry = NewValue/10, NewValue = NewValue%10. Update the value of the node. Do this for all the nodes. If there is a carry left after the last node, create a new node with the carry and return the new head. Else return the head of the linked list. This is a problem where FIFO principle of stack is used to reverse the linkedlist without manipulating any pointers.\n","date":"May 7, 2024","permalink":"/blog/posts/previous-solutions/problem-double-a-number-represented-as-a-linked-list/","summary":"Problem Statement Link - Problem 2816 Question You are given the head of a non-empty linked list representing a non-negative integer without leading zeroes.","title":"Problem 2816 Double a Number Represented as a Linked List","type":"posts"},{"content":" Problem Statement Link - Problem 2487 Question You are given the head of a linked list.\nRemove every node which has a node with a greater value anywhere to the right side of it.\nReturn the head of the modified linked list.\nExample 1 Input graph LR A((5))--\u003eB((2)) B--\u003eC((13)) C--\u003eD((3)) D--\u003eE((8)) Output graph LR A((13))--\u003eB((8)) Input: head = [5,2,13,3,8] Output: [13,8] Explanation: The nodes that should be removed are 5, 2 and 3. - Node 13 is to the right of node 5. - Node 13 is to the right of node 2. - Node 8 is to the right of node 3. Example 2 Input graph LR A((1))--\u003eB((1)) B--\u003eC((1)) C--\u003eD((1)) Output graph LR A((1))--\u003eB((1)) B--\u003eC((1)) C--\u003eD((1)) Input: head = [1,1,1,1] Output: [1,1,1,1] Explanation: Every node has value 1, so no nodes are removed. Constraints The number of the nodes in the given list is in the range [1, 10^5]. 1 \u0026lt;= Node.val \u0026lt;= 10^5 Solution /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ class Solution { public: ListNode* removeNodes(ListNode* head) { std::ios::sync_with_stdio(false); stack\u0026lt;ListNode*\u0026gt; st; ListNode* temp = head; while(temp != nullptr) { if(st.empty()) { st.push(temp); temp = temp-\u0026gt;next; } else { while(!st.empty() \u0026amp;\u0026amp; temp-\u0026gt;val \u0026gt; st.top()-\u0026gt;val) st.pop(); st.push(temp); temp=temp-\u0026gt;next; } } ListNode* newHead = nullptr; while(!st.empty()) { temp = st.top(); st.pop(); temp-\u0026gt;next = newHead; newHead = temp; } return newHead; } }; Complexity Time : O(n) Space : O(n) Explanation 1. Intuition We want to remove every node which has a node with value greater than current node to the right side of it. If we use a loop once and check for every node to the right side of it, it will take O(n^2) time. We can use a stack to store the nodes in decreasing order. This monotonically decreasing stack will help us to remove the nodes which have a greater value to the right side of it. The idea is to traverse the linked list and keep pushing the nodes into the stack. If the current node has a greater value than the top of the stack, we will pop the stack until the top of the stack has a greater value than the current node. After traversing the linked list, we will pop the stack and create a new linked list in reverse order. We need it in reverse order because the stack will have the nodes from the end of the linked list to the start of the linked list. 2. Implementation We will create a stack to store the nodes. We will traverse the linked list and push the nodes into the stack. If the stack is empty, we will push the current node into the stack. If the stack is not empty, we will check if the current node has a greater value than the top of the stack. If the current node has a greater value than the top of the stack, we will pop the stack until the top of the stack has a greater value than the current node. After traversing the linked list, we will pop the stack and create a new linked list in reverse order. We will return the head of the new linked list. Note: This problem showcases the use of monotonic stack\n","date":"May 6, 2024","permalink":"/blog/posts/previous-solutions/problem-remove-nodes-from-linked-list/","summary":"Problem Statement Link - Problem 2487 Question You are given the head of a linked list.","title":"Problem 2487 Remove Nodes From Linked List","type":"posts"},{"content":" Problem Statement Link - Problem 237 Question There is a singly-linked list head and we want to delete a node node in it.\nYou are given the node to be deleted node. You will not be given access to the first node of head.\nAll the values of the linked list are unique, and it is guaranteed that the given node node is not the last node in the linked list.\nDelete the given node. Note that by deleting the node, we mean that :\nThe value of the given node should not exist in the linked list. The number of nodes in the linked list should decrease by one. All the values before node should be in the same order. All the values after node should be in the same order. Example 1 Input: head = [4,5,1,9], node = 5 Output: [4,1,9] Explanation: You are given the second node with value 5, the linked list should become 4 -\u0026gt; 1 -\u0026gt; 9 after calling your function. Before deletion graph LR A((4)) --\u003e B((5)) B --\u003e C((1)) C --\u003e D((9)) After deletion graph LR A((4)) --\u003e C((1)) C --\u003e D((9)) Example 2 Input: head = [4,5,1,9], node = 1 Output: [4,5,9] Explanation: You are given the third node with value 1, the linked list should become 4 -\u0026gt; 5 -\u0026gt; 9 after calling your function. Before deletion graph LR A((4)) --\u003e B((5)) B --\u003e C((1)) C --\u003e D((9)) After deletion graph LR A((4)) --\u003e B((5)) B --\u003e D((9)) Constraints The number of the nodes in the given list is in the range [2, 1000]. -1000 \u0026lt;= Node.val \u0026lt;= 1000 The value of each node in the list is unique. The node to be deleted is in the list and is not a tail node. Solution /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */ class Solution { public: void deleteNode(ListNode* node) { ListNode* toDel = node-\u0026gt;next; node-\u0026gt;val = toDel-\u0026gt;val; node-\u0026gt;next = toDel-\u0026gt;next; delete toDel; } }; Complexity Analysis Time complexity : O(1) Space complexity : O(1) Explanation 1. Intuition We are given the node to be deleted and we can\u0026rsquo;t access the head of the linked list. We can\u0026rsquo;t delete the node directly as we don\u0026rsquo;t have access to the previous node. The idea is to copy the value of the next node to the current node and then delete the next node. 2. Code explained We store the next node in a temporary pointer toDel. We copy the value of the next node to the current node. We update the next pointer of the current node to the next of the next node. We delete the next node. This is a demonstration of Linked List manipulation.\n","date":"May 5, 2024","permalink":"/blog/posts/previous-solutions/problem-delete-node-in-a-linked-list/","summary":"Problem Statement Link - Problem 237 Question There is a singly-linked list head and we want to delete a node node in it.","title":"Problem 237 Delete Node in a Linked List","type":"posts"},{"content":" Problem Statement Link - Problem 881 Question You are given an array people where people[i] is the weight of the ith person, and an infinite number of boats where each boat can carry a maximum weight of limit. Each boat carries at most two people at the same time, provided the sum of the weight of those people is at most limit.\nReturn the minimum number of boats to carry every given person.\nExample 1 Input: people = [1,2], limit = 3 Output: 1 Explanation: 1 boat (1, 2) Example 2 Input: people = [3,2,2,1], limit = 3 Output: 3 Explanation: 3 boats (1, 2), (2) and (3) Example 3 Input: people = [3,5,3,4], limit = 5 Output: 4 Explanation: 4 boats (3), (3), (4), (5) Constraints 1 \u0026lt;= people.length \u0026lt;= 5 * 10^4 1 \u0026lt;= people[i] \u0026lt;= limit \u0026lt;= 3 * 10^4 Solution class Solution { public: int numRescueBoats(vector\u0026lt;int\u0026gt;\u0026amp; people, int limit) { std::ios_base::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); sort(people.begin(),people.end()); int left = 0,right = people.size()-1; int answer = 0; while(left\u0026lt;=right) { if(people[left]+people[right]\u0026gt;limit) { answer++; right--; } else { answer++; left++; right--; } } return answer; } }; Complexity Analysis Time : O(nlogn) Space : O(1) Explanation 1. Intuition We can see that the number of boats needed at minimum is n/2 where n is the number of people. Maximum number of boats needed is n where each person is in a separate boat. The idea is to give the heaviest person a boat and then check if the lightest person can be accomodated in the same boat. If the lightest person can be accomodated then we can move to the next lightest person. If the lightest person cannot be accomodated then we need to give the heaviest person a separate boat. 2. Code explained Sort the given vector. Initialize two pointers left and right at the start and end of the vector. Initialize the answer variable to 0. Iterate over the vector until left is less than or equal to right. If the sum of the weights of the people at left and right is greater than the limit then we need to give the person at right a separate boat. If the sum of the weights of the people at left and right is less than or equal to the limit then we can accomodate both the people in the same boat. Increment the answer variable accordingly. Return the answer variable. Note : This is a very simple problem and can be solved using the two pointer approach. The idea is to sort the given vector and then use two pointers to iterate over the vector. The time complexity of this approach is O(nlogn) where n is the number of people. The space complexity is O(1).\n","date":"May 4, 2024","permalink":"/blog/posts/previous-solutions/problem-boats-to-save-people/","summary":"Problem Statement Link - Problem 881 Question You are given an array people where people[i] is the weight of the ith person, and an infinite number of boats where each boat can carry a maximum weight of limit.","title":"Problem 881 Boats to Save People","type":"posts"},{"content":" Problem Statement Link - Problem 2000 Question Given a 0-indexed string word and a character ch, reverse the segment of word that starts at index 0 and ends at the index of the first occurrence of ch (inclusive). If the character ch does not exist in word, do nothing.\nFor example, if word = \u0026quot;abcdefd\u0026quot; and ch = \u0026quot;d\u0026quot;, then you should reverse the segment that starts at 0 and ends at 3 (inclusive). The resulting string will be \u0026quot;dcbaefd\u0026quot;.\nReturn the resulting string.\nExample 1 Input: word = \u0026#34;abcdefd\u0026#34;, ch = \u0026#34;d\u0026#34; Output: \u0026#34;dcbaefd\u0026#34; Explanation: The first occurrence of \u0026#34;d\u0026#34; is at index 3. Reverse the part of word from 0 to 3 (inclusive), the resulting string is \u0026#34;dcbaefd\u0026#34;. Example 2 Input: word = \u0026#34;xyxzxe\u0026#34;, ch = \u0026#34;z\u0026#34; Output: \u0026#34;zxyxxe\u0026#34; Explanation: The first and only occurrence of \u0026#34;z\u0026#34; is at index 3. Reverse the part of word from 0 to 3 (inclusive), the resulting string is \u0026#34;zxyxxe\u0026#34;. Example 3 Input: word = \u0026#34;abcd\u0026#34;, ch = \u0026#34;z\u0026#34; Output: \u0026#34;abcd\u0026#34; Explanation: \u0026#34;z\u0026#34; does not exist in word. You should not do any reverse operation, the resulting string is \u0026#34;abcd\u0026#34;. Constraints 1 \u0026lt;= word.length \u0026lt;= 250 word consists of lowercase English letters. ch is a lowercase English letter. Solution class Solution { public: string reversePrefix(string word, char ch) { std::ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); int prefixIndex = INT_MIN; for(int i = 0;i\u0026lt;word.size();i++) { if(word[i]==ch) { prefixIndex = i; break; } } if(prefixIndex == INT_MIN)\\ return word; string ans = \u0026#34;\u0026#34;; for(int i = prefixIndex;i\u0026gt;=0;i--) ans += word[i]; for(int i = prefixIndex+1;i\u0026lt;word.size();i++) ans += word[i]; return ans; } }; Complexity Analysis Time - O(N) Space - O(N) Explanation Iterate through the string and check if the character ch exists in word. If not return the word as it is. If it exisits swap construct a new string ans in the following fashion. Append characters from prefixIndex to 0, then append characters from prefixIndex +1 to word.size(). Return the ans string. Note A solution using STL functions is as follows class Solution { public: string reversePrefix(string word, char ch) { int j = word.find(ch); if (j != -1) { reverse(word.begin(), word.begin() + j + 1); } return word; } }; Showcases the string manipulation.\n","date":"May 1, 2024","permalink":"/blog/posts/previous-solutions/problem-reverse-prefix-of-word/","summary":"Problem Statement Link - Problem 2000 Question Given a 0-indexed string word and a character ch, reverse the segment of word that starts at index 0 and ends at the index of the first occurrence of ch (inclusive).","title":"Problem 2000 Reverse Prefix of Word","type":"posts"},{"content":" Problem Statement Link: Problem 1289 Question Given an n x n integer matrix grid, return the minimum sum of a falling path with non-zero shifts.\nA falling path with non-zero shifts is a choice of exactly one element from each row of grid such that no two elements chosen in adjacent rows are in the same column.\nExample 1 1 2 3 4 5 6 7 8 9 Input: grid = [[1,2,3],[4,5,6],[7,8,9]] Output: 13 Explanation: The possible falling paths are: [1,5,9], [1,5,7], [1,6,7], [1,6,8], [2,4,8], [2,4,9], [2,6,7], [2,6,8], [3,4,8], [3,4,9], [3,5,7], [3,5,9] The falling path with the smallest sum is [1,5,7], so the answer is 13. Example 2 7 Input: grid = [[7]] Output: 7 Constraints n == grid.length == grid[i].length 1 \u0026lt;= n \u0026lt;= 200 -99 \u0026lt;= grid[i][j] \u0026lt;= 99 Solution class Solution { public: int minFallingPathSum(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; grid) { std::ios::sync_with_stdio(false); vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;dp(grid.size(),vector\u0026lt;int\u0026gt;(grid[0].size(),-1)); int rows = grid.size(), cols = grid[0].size(); int result = INT_MAX,temp; for(int j =0;j\u0026lt;cols;j++) dp[0][j] = grid[0][j]; for(int i = 1;i\u0026lt;rows;i++) { for(int j = 0;j\u0026lt;cols;j++) { temp = INT_MAX; for(int k = 0;k\u0026lt;cols;k++) { if(k!=j) { temp = min(temp, grid[i][j]+dp[i-1][k]); } } dp[i][j] = temp; } } for(int j = 0;j\u0026lt;cols;j++) result = min(result,dp[rows-1][j]); return result; } }; Complexity Time : O(Rows * Cols^2) Space : O(Rows * Cols) Explaination We will use a 2D dp array to store the minimum sum of the falling path ending at the cell dp[i][j]. The minimum falling path sum of first row will be same as first row of grid, hence we initialize dp[0][j] = grid[0][j]. For each cell dp[i][j] we will iterate over the previous row and find the minimum sum of the falling path ending at the cell dp[i][j]. We will find the minimmum sum of falling path which is not from the same column, hence we use if (k != j) condition. The answer will be the minimum value stored at the final row of dp matrix. This shows the usage of iterative DP to solve a grid problem.\nWe can also use Dijkstras Algorithm to solve the same problem.\n","date":"April 26, 2024","permalink":"/blog/posts/previous-solutions/problem-minimum-falling-path-sum-ii/","summary":"Problem Statement Link: Problem 1289 Question Given an n x n integer matrix grid, return the minimum sum of a falling path with non-zero shifts.","title":"Problem 1289 Minimum Falling Path Sum II","type":"posts"},{"content":" Problem Statement Link - Problem 1137 Question The Tribonacci sequence T(n) is defined as follows:\nT(0) = 0, T(1) = 1, T(2) = 1, and T(n+3) = T(n) + T(n+1) + T(n+2) for n \u0026gt;= 0.\nGiven n, return the value of T(n).\nNote to self This is a straight forward Recursion Problem. We can convert this to DP by using memoization. We will use an array to store the intermediate values to prevent repeated calculations. Example 1 Input: n = 4 Output: 4 Explanation: T_3 = 0 + 1 + 1 = 2 T_4 = 1 + 1 + 2 = 4 Example 2 Input: n = 25 Output: 1389537 Constraints 0 \u0026lt;= n \u0026lt;= 37 The answer is guaranteed to fit within a 32-bit integer, ie. answer \u0026lt;= 2^31 - 1. Solution class Solution { public: int tribonacci(int n) { if(!n) return 0; if(n==1) return 1; if(n==2) return 1; vector\u0026lt;int\u0026gt;dp(n+1); dp[0]= 0; dp[1] = 1; dp[2] = 1; for(int i=3;i\u0026lt;=n;i++) dp[i]= dp[i-1]+dp[i-2]+dp[i-3]; return dp[n]; } }; Complexity Time: O(n) Space: O(n) Explaination We will use the DP array to store the intermediate values. We will store 0,1,1 as first 3 values. Then inside a loop from 3 to n, we will calculate the value of T(n) using the formula T(n) = T(n-1) + T(n-2) + T(n-3). We will return the value of T(n) at the end. DP without using array It is still memoization class Solution { public: int tribonacci(int n) { if(!n) return 0; if(n==1) return 1; if(n==2) return 1; int a=0,b=1,c=1; for(int i=3;i\u0026lt;=n;i++) { int temp = a+b+c; a=b; b=c; c=temp; } return c; } }; Time: O(n)\nSpace: O(1)\nWe can also solve this using recursion but it will be slow as it will have a time complexity of O(3^n).\nWe can also solve this using matrix exponentiation but it will be an overkill for this problem.\nThis is a demonstration of memoization technique used in DP. With this we can convert a recursive method into dynamic programming method.\n","date":"April 24, 2024","permalink":"/blog/posts/previous-solutions/problem-nth-tribonacci-number/","summary":"Problem Statement Link - Problem 1137 Question The Tribonacci sequence T(n) is defined as follows:","title":"Problem 1137 Nth Tribonacci Number","type":"posts"},{"content":" Problem Statement Link - Problem 752 Question You have a lock in front of you with 4 circular wheels. Each wheel has 10 slots: '0', '1', '2', '3', '4', '5', '6', '7', '8', '9'. The wheels can rotate freely and wrap around: for example we can turn '9' to be '0', or '0' to be '9'. Each move consists of turning one wheel one slot.\nThe lock initially starts at '0000', a string representing the state of the 4 wheels.\nYou are given a list of deadends dead ends, meaning if the lock displays any of these codes, the wheels of the lock will stop turning and you will be unable to open it.\nGiven a target representing the value of the wheels that will unlock the lock, return the minimum total number of turns required to open the lock, or -1 if it is impossible.\nNote What they want us to find is the shortest path from the start node to the target node. The start node is '0000' and the target node is the target string. There will be an edge between two nodes if they differ by one digit. There are no outgoing edges from the deadend nodes. We can reach the target by changing the digits of the start node one by one, We can change them in either direction. The logic what we will be using is of BFS. BFS will always give us the shortest path. Note that the starting node also maybe a deadend. Example 1 Input: deadends = [\u0026#34;0201\u0026#34;,\u0026#34;0101\u0026#34;,\u0026#34;0102\u0026#34;,\u0026#34;1212\u0026#34;,\u0026#34;2002\u0026#34;], target = \u0026#34;0202\u0026#34; Output: 6 Explanation: A sequence of valid moves would be \u0026#34;0000\u0026#34; -\u0026gt; \u0026#34;1000\u0026#34; -\u0026gt; \u0026#34;1100\u0026#34; -\u0026gt; \u0026#34;1200\u0026#34; -\u0026gt; \u0026#34;1201\u0026#34; -\u0026gt; \u0026#34;1202\u0026#34; -\u0026gt; \u0026#34;0202\u0026#34;. Note that a sequence like \u0026#34;0000\u0026#34; -\u0026gt; \u0026#34;0001\u0026#34; -\u0026gt; \u0026#34;0002\u0026#34; -\u0026gt; \u0026#34;0102\u0026#34; -\u0026gt; \u0026#34;0202\u0026#34; would be invalid, because the wheels of the lock become stuck after the display becomes the dead end \u0026#34;0102\u0026#34;. Example 2 Input: deadends = [\u0026#34;8888\u0026#34;], target = \u0026#34;0009\u0026#34; Output: 1 Explanation: We can turn the last wheel in reverse to move from \u0026#34;0000\u0026#34; -\u0026gt; \u0026#34;0009\u0026#34;. Example 3 Input: deadends = [\u0026#34;8887\u0026#34;,\u0026#34;8889\u0026#34;,\u0026#34;8878\u0026#34;,\u0026#34;8898\u0026#34;,\u0026#34;8788\u0026#34;,\u0026#34;8988\u0026#34;,\u0026#34;7888\u0026#34;,\u0026#34;9888\u0026#34;], target = \u0026#34;8888\u0026#34; Output: -1 Explanation: We cannot reach the target without getting stuck. Constraints 1 \u0026lt;= deadends.length \u0026lt;= 500 deadends[i].length == 4 target.length == 4 target will not be in the list deadends. target and deadends[i] consist of digits only. Solution class Solution { public: int openLock(vector\u0026lt;string\u0026gt;\u0026amp; deadends, string target) { std::ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); unordered_set\u0026lt;string\u0026gt; dead(deadends.begin(),deadends.end()); if(dead.find(\u0026#34;0000\u0026#34;) != dead.end()) return -1; if(target == \u0026#34;0000\u0026#34;) return 0; int steps = 0; queue\u0026lt;string\u0026gt; q; q.push(\u0026#34;0000\u0026#34;); char actual; while(!q.empty()) { steps++; for(int size = q.size();size\u0026gt;0;size--) { string passwd = q.front(); q.pop(); for(int i= 0;i\u0026lt;4;i++) { actual = passwd[i]; passwd[i] = (passwd[i]==\u0026#39;9\u0026#39;)?\u0026#39;0\u0026#39;:passwd[i]+1; if(passwd == target) return steps; if(dead.find(passwd) == dead.end()) { q.push(passwd); dead.insert(passwd); } passwd[i] = actual; passwd[i] = (passwd[i]==\u0026#39;0\u0026#39;)?\u0026#39;9\u0026#39;:passwd[i]-1; if(passwd == target) return steps; if(dead.find(passwd) == dead.end()) { q.push(passwd); dead.insert(passwd); } passwd[i] = actual; } } } return -1; } }; Complexity Analysis Time complexity - O(10000) = O(1) - As we are iterating over all the possible combinations of the lock. Space complexity - O(10000) = O(1) - As we are storing all the possible combinations of the lock in the queue. Explanation First we create a unordered_set of deadends which will help us to check if the current combination is a deadend or not. We add all the deadends to the set. This makes sure that immidiate children of the deadends are not added to the queue. We check if the target is already a deadend or not. We check if the target is the start node itself. We create a queue and push the start node to it. We will keep track on number steps needed to reach the target. We will iterate over the current queue size. This is because we need to check only the current level nodes. We will iterate over the current node and change the digits one by one. If the child node is the target we return the number of steps. If child node is not target and is not a deadend or not visited till now, we will add it to the queue and mark it as visited. We will do the same for the other direction of the digit. If we are not able to reach the target we return -1. Note - This is a very good problem to understand the concept of BFS. We can also solve this problem using DFS but BFS is more efficient in this case.\n","date":"April 22, 2024","permalink":"/blog/posts/previous-solutions/problem-open-the-lock/","summary":"Problem Statement Link - Problem 752 Question You have a lock in front of you with 4 circular wheels.","title":"Problem 752 Open the Lock","type":"posts"},{"content":" Problem Statement Link - Problem 1971 Question There is a bi-directional graph with n vertices, where each vertex is labeled from 0 to n-1 (inclusive). The edges in the graph are represented as a 2D integer array edges, where each edges[i] = [ui, vi] denotes a bi-directional edge between vertex ui and vertex vi. Every vertex pair is connected by at most one edge, and no vertex has an edge to itself.\nYou want to determine if there is a valid path that exists from vertex source to vertex destination.\nGiven edges and the integers n, source, and destination, return true if there is a valid path from source to destination, or false otherwise.\nExample 1 graph LR A((0))\u003c--\u003eB((1)) B((1))\u003c--\u003eC((2)) C((2))\u003c--\u003eA((0)) Input: n = 3, edges = [[0,1],[1,2],[2,0]], source = 0, destination = 2 Output: true Explanation: There are two paths from vertex 0 to vertex 2: - 0 → 1 → 2 - 0 → 2 Example 2 graph TD A((0))\u003c--\u003eB((1)) C((2))\u003c--\u003eA((0)) D((3))\u003c--\u003eE((4)) E((4))\u003c--\u003eF((5)) F((5))\u003c--\u003eD((3)) Input: n = 6, edges = [[0,1],[0,2],[3,5],[5,4],[4,3]], source = 0, destination = 5 Output: false Explanation: There is no path from vertex 0 to vertex 5. Edge Case graph TD A((0)) Input: n = 1, edges = [], source = 0, destination = 0 Output = true Explanation: We are already in destination node. Constraints 1 \u0026lt;= n \u0026lt;= 2 * 10^5 0 \u0026lt;= edges.length \u0026lt;= 2 * 10^5 edges[i].length == 2 0 \u0026lt;= ui, vi \u0026lt;= n - 1 ui != vi 0 \u0026lt;= source, destination \u0026lt;= n - 1 There are no duplicate edges. There are no self edges Solution class Solution { public: bool dfs(unordered_map\u0026lt;int,vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; graph, int curr, int dest, unordered_set\u0026lt;int\u0026gt;\u0026amp; visited) { if(curr == dest) return true; visited.insert(curr); for(int next:graph[curr]) { if(visited.find(next) == visited.end()) if( dfs(graph,next,dest,visited)) return true; } return false; } bool validPath(int n, vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; edges, int source, int destination) { unordered_map\u0026lt;int, vector\u0026lt;int\u0026gt;\u0026gt; graph; for (const auto\u0026amp; edge : edges) { graph[edge[0]].push_back(edge[1]); graph[edge[1]].push_back(edge[0]); } unordered_set\u0026lt;int\u0026gt; visited; return dfs(graph, source, destination, visited); } }; Complexity Time : O(V + E), DFS visits each node and checks each edge atleast once. Space : O(V + E), the map stores each vertex V and corresponding edges E. Explanation We are given a vector of vector of int which denote the edges of a graph, the source vertex and destination vertex. Graph is bidirectional and there are no Self-Edges (From given). First we create an adjacency list graph which stores the vertex and the edges which is connected to them. We keep track of visited nodes in an unordered set visited. The DFS function then first checks if the current node is destination. If yes then we return true. Else we will append it to visited set, then try to find if any path exists from the connected nodes of current node. We will explore all the unvisited conntected nodes. If no path is found we return false. This shows the dfs method of graph traversal when a graph is represented in adjacency list format.\n","date":"April 21, 2024","permalink":"/blog/posts/previous-solutions/problem-find-if-path-exists-in-graph/","summary":"Problem Statement Link - Problem 1971 Question There is a bi-directional graph with n vertices, where each vertex is labeled from 0 to n-1 (inclusive).","title":"Problem 1971 Find if Path Exists in Graph","type":"posts"},{"content":" Problem Statement Link - Problem 1992 Question You are given a 0-indexed m x n binary matrix land where a 0 represents a hectare of forested land and a 1 represents a hectare of farmland.\nTo keep the land organized, there are designated rectangular areas of hectares that consist entirely of farmland. These rectangular areas are called groups. No two groups are adjacent, meaning farmland in one group is not four-directionally adjacent to another farmland in a different group.\nland can be represented by a coordinate system where the top left corner of land is (0, 0) and the bottom right corner of land is (m-1, n-1). Find the coordinates of the top left and bottom right corner of each group of farmland. A group of farmland with a top left corner at (r1, c1) and a bottom right corner at (r2, c2) is represented by the 4-length array [r1, c1, r2, c2].\nReturn a 2D array containing the 4-length arrays described above for each group of farmland in land. If there are no groups of farmland, return an empty array. You may return the answer in any order.\nExample 1 Input: land = [[1,0,0],[0,1,1],[0,1,1]] Output: [[0,0,0,0],[1,1,2,2]] Explanation: The first group has a top left corner at land[0][0] and a bottom right corner at land[0][0]. The second group has a top left corner at land[1][1] and a bottom right corner at land[2][2]. Example 2 Input: land = [[1,1],[1,1]] Output: [[0,0,1,1]] Explanation: The first group has a top left corner at land[0][0] and a bottom right corner at land[1][1]. Example 3 Input: land = [[0]] Output: [] Explanation: There are no groups of farmland. Constraints m == land.length n == land[i].length 1 \u0026lt;= m, n \u0026lt;= 300 land consists of only 0's and 1's. Groups of farmland are rectangular in shape. Solution class Solution { public: void dfs(int i, int j, int\u0026amp; r1, int\u0026amp; c1, int\u0026amp; r2, int\u0026amp; c2,vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; land){ if(i \u0026lt; 0 || j \u0026lt; 0 || i \u0026gt;= land.size() || j \u0026gt;= land[0].size() || land[i][j] != 1) return; land[i][j] = 0; r1=min(r1, i), c1=min(c1, j), r2=max(r2, i), c2=max(c2, j); dfs(i+1,j, r1, c1, r2, c2, land); dfs(i,j+1, r1, c1, r2, c2, land); // No need to check top and left because it is given that it is always a rectangle. //dfs(i-1,j, r1, c1, r2, c2, land); //dfs(i,j-1, r1, c1, r2, c2, land); } vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; findFarmland(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; land) { std::ios::sync_with_stdio(false); int n=land.size(); int m=land[0].size(); int r1,r2,c1,c2; vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; answer; for(int i=0; i\u0026lt;n; i++) for(int j=0; j\u0026lt;m; j++){ if(land[i][j]==1){ r1=i, c1=j, r2=i, c2=j; dfs(i, j, r1, c1, r2, c2, land); answer.push_back({r1, c1, r2, c2}); } } return answer; } }; Complexity Time complexity : O(n*m) Space complexity : O(n*m) Explaination We will use the DFS technique to find the farmland. This is very similar to the number of islands problem. Check it Out . We will iterate over the matrix given only if the current cell is 1. In the dfs function, we will check if the current cell is in bounds and is 1. If it is, we will mark it as 0 and update the r1, c1, r2, c2 values. The r1, c1 will be the minimum values of the current cell and the r2, c2 will be the maximum values of the current cell. r1, c1 will be the top left corner and r2, c2 will be the bottom right corner of the farmland. We will call the dfs function recursively on the right and bottom cells. We need not to check the top and left cells because it is given that the farmland is always a rectangle. Once the dfs function is ended, we will push the r1, c1, r2, c2 values to the answer array. This demonstrates the use of DFS to traverse a 2D matrix and find the components or groups.\n","date":"April 20, 2024","permalink":"/blog/posts/previous-solutions/problem-find-all-groups-of-farmland/","summary":"Problem Statement Link - Problem 1992 Question You are given a 0-indexed m x n binary matrix land where a 0 represents a hectare of forested land and a 1 represents a hectare of farmland.","title":"Problem 1992 Find All Groups of Farmland","type":"posts"},{"content":" Problem Statement Link - Problem 200 Question Given an m x n 2D binary grid grid which represents a map of '1's (land) and '0's (water), return the number of islands.\nAn island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.\nNote to self They use characters not integers for 1 and 0. This is a classic dfs problem. Example 1 Input:\ngrid = [ [\u0026#34;1\u0026#34;,\u0026#34;1\u0026#34;,\u0026#34;1\u0026#34;,\u0026#34;1\u0026#34;,\u0026#34;0\u0026#34;], [\u0026#34;1\u0026#34;,\u0026#34;1\u0026#34;,\u0026#34;0\u0026#34;,\u0026#34;1\u0026#34;,\u0026#34;0\u0026#34;], [\u0026#34;1\u0026#34;,\u0026#34;1\u0026#34;,\u0026#34;0\u0026#34;,\u0026#34;0\u0026#34;,\u0026#34;0\u0026#34;], [\u0026#34;0\u0026#34;,\u0026#34;0\u0026#34;,\u0026#34;0\u0026#34;,\u0026#34;0\u0026#34;,\u0026#34;0\u0026#34;] ] Output:\n1 Example 2 Input:\ngrid = [ [\u0026#34;1\u0026#34;,\u0026#34;1\u0026#34;,\u0026#34;0\u0026#34;,\u0026#34;0\u0026#34;,\u0026#34;0\u0026#34;], [\u0026#34;1\u0026#34;,\u0026#34;1\u0026#34;,\u0026#34;0\u0026#34;,\u0026#34;0\u0026#34;,\u0026#34;0\u0026#34;], [\u0026#34;0\u0026#34;,\u0026#34;0\u0026#34;,\u0026#34;1\u0026#34;,\u0026#34;0\u0026#34;,\u0026#34;0\u0026#34;], [\u0026#34;0\u0026#34;,\u0026#34;0\u0026#34;,\u0026#34;0\u0026#34;,\u0026#34;1\u0026#34;,\u0026#34;1\u0026#34;] ] Output:\n3 Constraints m == grid.length n == grid[i].length 1 \u0026lt;= m, n \u0026lt;= 300 grid[i][j] is '0' or '1'. Solution class Solution { public: void checkIsland(int row,int col,vector\u0026lt;vector\u0026lt;char\u0026gt;\u0026gt;\u0026amp; grid) { if(row \u0026lt; 0 || col \u0026lt; 0 || row \u0026gt;= grid.size() || col \u0026gt;= grid[0].size() || grid[row][col] != \u0026#39;1\u0026#39;) return; grid[row][col] = \u0026#39;0\u0026#39;; checkIsland(row - 1, col,grid); checkIsland(row + 1, col,grid); checkIsland(row, col - 1,grid); checkIsland(row, col + 1,grid); } int numIslands(vector\u0026lt;vector\u0026lt;char\u0026gt;\u0026gt;\u0026amp; grid) { std::ios::sync_with_stdio(false); if(grid.empty() || grid[0].empty()) return 0; int rows = grid.size(); int cols = grid[0].size(); int islands = 0; for(int row = 0; row \u0026lt; rows; row++) { for(int col = 0; col \u0026lt; cols; col++) { if(grid[row][col] == \u0026#39;1\u0026#39;) { checkIsland(row, col,grid); islands++; } } } return islands; } }; Complexity Time : O(m*n) Space : O(m*n) Explaination We use the classic dfs approach to solve this. The logic is to check if the current cell is in bounds, and is '1'. If it is then the cell is marked as visited and call the function recursively on all the 4 directions. This recursive call checks if its adjacent cells are '0' or '1'. If they all are Zeroes then the call will end and the count of islands Islands will be incremented. If the current cell has an unvisited land neighbour then we extend our search there. So whenever the checkIsland function is ended by the base case it means it has found a valid island. This demonstrates the use of DFS to traverse a 2D matrix and find the components or groups.\n","date":"April 19, 2024","permalink":"/blog/posts/previous-solutions/problem-number-of-islands/","summary":"Problem Statement Link - Problem 200 Question Given an m x n 2D binary grid grid which represents a map of '1's (land) and '0's (water), return the number of islands.","title":"Problem 200 Number of Islands","type":"posts"},{"content":" Problem Statement Link - Problem 463 Question You are given row x col grid representing a map where grid[i][j] = 1 represents land and grid[i][j] = 0 represents water.\nGrid cells are connected horizontally/vertically (not diagonally). The grid is completely surrounded by water, and there is exactly one island (i.e., one or more connected land cells).\nThe island doesn\u0026rsquo;t have \u0026ldquo;lakes\u0026rdquo;, meaning the water inside isn\u0026rsquo;t connected to the water around the island. One cell is a square with side length 1. The grid is rectangular, width and height don\u0026rsquo;t exceed 100. Determine the perimeter of the island.\nExample 1 Input: grid = [[0,1,0,0],[1,1,1,0],[0,1,0,0],[1,1,0,0]] Output: 16 Example 2 Input: grid = [[1]] Output: 4 Example 3 Input: grid = [[1,0]] Output: 4 Constraints row == grid.length col == grid[i].length 1 \u0026lt;= row, col \u0026lt;= 100 grid[i][j] is 0 or 1. There is exactly one island in grid. Solution class Solution { public: int islandPerimeter(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; grid) { int row = grid.size(), col = grid[0].size(); int peri = 0; for(int i=0;i\u0026lt;row;i++) { for(int j=0;j\u0026lt;col;j++) { if(grid[i][j]\u0026amp;1) { peri+=4; if(i\u0026gt;0 \u0026amp;\u0026amp; (grid[i-1][j] \u0026amp; 1)) peri-=2; if(j\u0026gt;0 \u0026amp;\u0026amp; (grid[i][j-1] \u0026amp; 1)) peri-=2; } } } return peri; } }; Complexity Time : O(N*M) Space : O(1) Explanation We iterate over the grid. If the cell is land then add 4 to the perimeter. Then we check the left and top of the cell. If they are land then we subtract 2 from the perimeter each. This is because when two lands are adjacent then they share a side and hence the perimeter is reduced by 2. Finally return the perimeter. This problem demonstrates the traversal of a matrix and checking the adjacent cells.\n","date":"April 18, 2024","permalink":"/blog/posts/previous-solutions/problem-island-perimeter/","summary":"Problem Statement Link - Problem 463 Question You are given row x col grid representing a map where grid[i][j] = 1 represents land and grid[i][j] = 0 represents water.","title":"Problem 463 Island Perimeter","type":"posts"},{"content":" Problem Statement Link - Problem 988 Question You are given the root of a binary tree where each node has a value in the range [0, 25] representing the letters 'a' to 'z'.\nReturn the lexicographically smallest string that starts at a leaf of this tree and ends at the root.\nAs a reminder, any shorter prefix of a string is lexicographically smaller.\nFor example, \u0026quot;ab\u0026quot; is lexicographically smaller than \u0026quot;aba\u0026quot;. A leaf of a node is a node that has no children.\nExample 1 graph TD A[0] --\u003e B[1] A --\u003e C[2] B --\u003e D[3] B --\u003e E[4] C --\u003e F[3] C --\u003e G[4] Input: root = [0,1,2,3,4,3,4] Output: \u0026#34;dba\u0026#34; Example 2 graph TD A[25] --\u003e B[1] B --\u003e C[1] B --\u003e D[3] A --\u003e E[3] E --\u003e F[0] E --\u003e G[2] Input: root = [25,1,3,1,3,0,2] Output: \u0026#34;adz\u0026#34; Example 3 graph TD A[2] --\u003e B[2] A --\u003e C[1] B --\u003e D[1] C--\u003e E[0] D--\u003eF[0] Input: root = [2,2,1,null,1,0,null,0] Output: \u0026#34;abc\u0026#34; Important Edge Case graph TD A[0] --\u003e B[1] Input: root = [0,null,1] Output: \u0026#34;ba\u0026#34; Constraints The number of nodes in the tree is in the range [1, 8500]. 0 \u0026lt;= Node.val \u0026lt;= 25 Solution /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: void dfs(TreeNode* root, string str, string\u0026amp; smallest) { if(root == NULL) return; str+= char(\u0026#39;a\u0026#39;+root-\u0026gt;val); if(root-\u0026gt;left == NULL \u0026amp;\u0026amp; root-\u0026gt;right == NULL) { reverse(str.begin(),str.end()); if(smallest.empty() || str\u0026lt;smallest) smallest = str; reverse(str.begin(),str.end()); } dfs(root-\u0026gt;left,str,smallest); dfs(root-\u0026gt;right,str,smallest); } string smallestFromLeaf(TreeNode* root) { string small; dfs(root,\u0026#34;\u0026#34;,small); return small; } }; Complexity Time : O(N) Space : O(N) Explanation We perform a DFS traversal of the tree. First we start from the root of the tree and traverse down. We use a string called smallest to keep track of the smallest string from leafnode to rootnode found so far. Base Case for recursion - if root is NULL then just return. We append the character to the string str which is the character at the current node. String str actually stores the current path which is being developed from rootnode to leafnode. If we reach a leafnode then we reverse the str and check if its the lexographically smallest string which we saw so far. If yes then update the smallest. Then reverse str again so that we can continue exploring the path. Then we recursively explore the left subtree and right subtree looking for leaf nodes. This solution effectively demonstrates the usage of DFS to build a string from a tree following the given set of rules.\n","date":"April 17, 2024","permalink":"/blog/posts/previous-solutions/problem-smallest-string-starting-from-leaf/","summary":"Problem Statement Link - Problem 988 Question You are given the root of a binary tree where each node has a value in the range [0, 25] representing the letters 'a' to 'z'.","title":"Problem 988 Smallest String Starting From Leaf","type":"posts"},{"content":" Problem Statement Link - Problem 623 Question Given the root of a binary tree and two integers val and depth, add a row of nodes with value val at the given depth depth.\nNote that the root node is at depth 1.\nThe adding rule is:\nGiven the integer depth, for each not null tree node cur at the depth depth - 1, create two tree nodes with value val as cur's left subtree root and right subtree root. cur's original left subtree should be the left subtree of the new left subtree root. cur's original right subtree should be the right subtree of the new right subtree root. If depth == 1 that means there is no depth depth - 1 at all, then create a tree node with value val as the new root of the whole original tree, and the original tree is the new root\u0026rsquo;s left subtree. Example 1 Input: root = [4,2,6,3,1,5], val = 1, depth = 2 Output: [4,1,1,2,null,null,6,3,1,5] Example 2 Input: root = [4,2,null,3,1], val = 1, depth = 3 Output: [4,2,null,1,1,3,null,null,1] Constraints The number of nodes in the tree is in the range [1, 10^4]. The depth of the tree is in the range [1, 10^4]. -100 \u0026lt;= Node.val \u0026lt;= 100 -10^5 \u0026lt;= val \u0026lt;= 10^5 1 \u0026lt;= depth \u0026lt;= the depth of tree + 1 Solution /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(NULL), right(NULL) {} * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: void dfs(TreeNode* root,int val,int currDepth,int depth) { if(root == NULL) return; if(currDepth == depth-1) { root-\u0026gt;left = new TreeNode(val,root-\u0026gt;left,NULL); root-\u0026gt;right = new TreeNode(val,NULL,root-\u0026gt;right); return; } dfs(root-\u0026gt;left,val,currDepth+1,depth); dfs(root-\u0026gt;right,val,currDepth+1,depth); } TreeNode* addOneRow(TreeNode* root, int val, int depth) { if(depth == 1) { return new TreeNode(val,root,NULL); } dfs(root,val,1,depth); return root; } }; Complexity Time : O(N) Space : O(N) Explaination The provided code is a C++ solution for adding a new row of nodes with a given value to a binary tree at a specified depth. The solution uses a depth-first search (DFS) approach to traverse the tree and add the new nodes. Here\u0026rsquo;s a breakdown of the approach and logic:\nApproach Depth-First Search (DFS): The solution uses a DFS approach to traverse the binary tree. DFS is chosen because it allows us to explore each path from the root to a leaf node in a systematic manner, which is crucial for adding nodes at a specific depth.\nAdding Nodes at the Specified Depth: The dfs function is designed to add new nodes at the specified depth. It takes four parameters: the current node (root), the value to be added to the new nodes (val), the current depth (currDepth), and the target depth (depth).\nBase Case: The base case for the DFS is when the current depth equals the target depth minus one. At this point, the function creates new nodes with the given value and adds them as the left and right children of the current node. This effectively adds a new row of nodes at the specified depth.\nRecursive Calls: For each node, the function makes recursive calls to itself for the left and right children of the current node, incrementing the current depth by one. This allows the function to explore all nodes at the specified depth and add the new nodes.\nHandling the Root Node: If the target depth is 1, the addOneRow function creates a new root node with the given value and the original root as its right child. This effectively adds a new row of nodes at the root level.\nLogic DFS Traversal: The DFS traversal starts from the root and explores each path from the root to a leaf node. The traversal is controlled by the currDepth and depth parameters, ensuring that nodes are added only at the specified depth.\nAdding New Nodes: When the DFS reaches the specified depth, it adds new nodes with the given value as the left and right children of the current node. This is done by creating new TreeNode instances with the given value and the existing left and right children of the current node.\nReturning the Modified Tree: After adding the new nodes, the addOneRow function returns the modified tree. If the target depth is 1, it returns a new root node; otherwise, it returns the original root node.\nWhy This Approach Works ? Systematic Exploration: DFS ensures that we explore all nodes in the tree in a systematic manner, allowing us to add new nodes at the specified depth.\nDepth Control: By comparing currDepth with depth - 1, we can precisely control when to add new nodes, ensuring that they are added only at the specified depth.\nFlexibility: This approach can handle adding a new row of nodes at any depth within the tree, making it versatile for different scenarios.\nThis solution effectively demonstrates how to use DFS to modify a binary tree by adding a new row of nodes at a specified depth.\n","date":"April 16, 2024","permalink":"/blog/posts/previous-solutions/problem-add-one-row-to-tree/","summary":"Problem Statement Link - Problem 623 Question Given the root of a binary tree and two integers val and depth, add a row of nodes with value val at the given depth depth.","title":"Problem 623 Add One Row to Tree","type":"posts"},{"content":" Problem Statement Link - Problem 129 Question You are given the root of a binary tree containing digits from 0 to 9 only.\nEach root-to-leaf path in the tree represents a number.\nFor example, the root-to-leaf path 1 -\u0026gt; 2 -\u0026gt; 3 represents the number 123. Return the total sum of all root-to-leaf numbers. Test cases are generated so that the answer will fit in a 32-bit integer.\nA leaf node is a node with no children.\nExample 1 Input: root = [1,2,3] Output: 25 Explanation: The root-to-leaf path 1-\u0026gt;2 represents the number 12. The root-to-leaf path 1-\u0026gt;3 represents the number 13. Therefore, sum = 12 + 13 = 25. Example 2 Input: root = [4,9,0,5,1] Output: 1026 Explanation: The root-to-leaf path 4-\u0026gt;9-\u0026gt;5 represents the number 495. The root-to-leaf path 4-\u0026gt;9-\u0026gt;1 represents the number 491. The root-to-leaf path 4-\u0026gt;0 represents the number 40. Therefore, sum = 495 + 491 + 40 = 1026. Constraints Constraints: The number of nodes in the tree is in the range [1, 1000]. 0 \u0026lt;= Node.val \u0026lt;= 9 The depth of the tree will not exceed 10. Solution /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: int dfs(TreeNode* root, int path) { if(root==nullptr) return 0; path = path*10 + root-\u0026gt;val; if(root-\u0026gt;left == nullptr \u0026amp;\u0026amp; root-\u0026gt;right == nullptr) return path; return dfs(root-\u0026gt;left,path)+dfs(root-\u0026gt;right,path); } int sumNumbers(TreeNode* root) { return dfs(root,0); } }; Complexity Time : O(N) Space : O(N) Explanation Depth-First Search (DFS): The solution uses a depth-first search (DFS) approach to traverse the binary tree. DFS is chosen because it allows us to explore each path from the root to a leaf node in a systematic manner. Path Representation: As we traverse the tree, we keep track of the current path from the root to the current node. This path is represented as an integer, where each digit in the path corresponds to the value of a node in the path. Appending Node Values: For each node we visit, we append its value to the current path. This is done by multiplying the current path by 10 (to shift the digits to the left) and adding the node\u0026rsquo;s value. This operation effectively appends the node\u0026rsquo;s value to the end of the path. Base Case: The base case for the DFS is when we reach a leaf node (a node with no children). At this point, the path represents a number, and we return this number. Recursive Calls: For each non-leaf node, we make recursive calls to the DFS function for its left and right children, passing along the updated path. This allows us to explore all possible paths from the root to the leaves. Summing Numbers: The sum of all numbers represented by the paths from the root to the leaves is calculated by adding up the numbers returned by the recursive calls. Why this technique works ? Systematic Exploration: DFS ensures that we explore all possible paths from the root to the leaves in a systematic manner. This is crucial for calculating the sum of all numbers represented by these paths. Path Representation: By representing the path as an integer, we can easily append the value of each node to the path and calculate the number represented by the path. This representation is efficient and straightforward. Base Case Handling: The base case (reaching a leaf node) allows us to calculate the number represented by the path from the root to the leaf. This is the key step in solving the problem. Recursive Summing: By making recursive calls and summing the results, we ensure that the sum of all numbers represented by the paths from the root to the leaves is calculated correctly. This technique works because it systematically explores all paths from the root to the leaves of the binary tree, calculates the number represented by each path, and sums these numbers to find the total sum of all root-to-leaf numbers.\n","date":"April 15, 2024","permalink":"/blog/posts/previous-solutions/problem-sum-root-to-leaf-numbers/","summary":"Problem Statement Link - Problem 129 Question You are given the root of a binary tree containing digits from 0 to 9 only.","title":"Problem 129 Sum Root to Leaf Numbers","type":"posts"},{"content":" Raspberry Pi Zero Headless WiFi Setup Using Linux The following instructions will ultimately enable your Pi Zero to connect the WiFi to the router during every boot up, for a headless management.\nAppendix Prerequisite Enabling USB ethernet gadget mode on Pi Things to do once connected to Pi via USB 3.1. Enabling Internet access in Raspberry Pi 3.2. SSH into Raspberry Pi 3.3. Change locale settings 3.4. Update the OS 3.5. WiFi configuration for auto connecting to the access point 1. Prerequisite a) Raspberry Pi Zero v1.3\nb) USB data cable\nc) Raspbian OS\nd) A charger\ne) Manjaro Linux ( mentioned as host OS in this article )\nf) Raspberry Pi Imager tool\ng) SD card\n2. Enabling USB ether net gadget mode on Pi To enable the gadget mode, edit config.txt and cmdline.txt files in thebootpartition of the SD card.\\\nAdd dtoverlay=dwc2 to config.txt and\nAdd modules-load=dwc2,g_ether after the rootwait in cmdline.txt\nNote: Leave a space before and after the add modules-load=dwc2,g_ether line.\nMake an empty ssh file inside the same partition to enable SSH on boot.\nNow connect the USB data cable to the USB port of the Pi and plug it in the PC\u0026rsquo;s\nUSB port.\nImportant ! In the newer version of Raspbian there is no default pi user. We have to create it ourselves. Following steps will instruct you how to create that default user.\nCreate an empty file called userconf in the boot partition. touch useconf Now copy paste the following into the file pi:$6$/4.VdYgDm7RJ0qM1$FwXCeQgDKkqrOU3RIRuDSKpauAbBvP11msq9X58c8Que2l1Dwq3vdJMgiZlQSbEXGaY5esVHGBNbCxKLVNqZW1 The above will create a default user named pi and password is raspberry. You can change it later on. Without this you wont be able to SSH into the raspberry pi zero.\n3. Things to do once connected to Pi via USB 3.1 Enabling Internet access in Raspberry Pi Before enabling the internet, make sure that the Pi is connected as a USB gadget. Check sudo dmesg to confirm it. Look for lines similar to\n[ 343.853507] usb 1-4: new full-speed USB device number 3 using xhci_hcd [ 345.088725] usb 1-4: new high-speed USB device number 4 using xhci_hcd [ 345.243731] usb 1-4: New USB device found, idVendor=0525, idProduct=a4a2, bcdDevice= 5.10 [ 345.243740] usb 1-4: New USB device strings: Mfr=1, Product=2, SerialNumber=0 [ 345.243743] usb 1-4: Product: RNDIS/Ethernet Gadget [ 345.243746] usb 1-4: Manufacturer: Linux 5.10.17+ with 20980000.usb [ 345.463183] cdc_subset: probe of 1-4:1.0 failed with error -22 [ 345.464195] cdc_subset 1-4:1.1 usb0: register \u0026#39;cdc_subset\u0026#39; at usb-0000:03:00.3-4, Linux Device, e2:38:73:2d:01:39 [ 345.464248] usbcore: registered new interface driver cdc_subset [ 345.464297] cdc_ether: probe of 1-4:1.0 failed with error -16 [ 345.464337] usbcore: registered new interface driver cdc_ether [ 345.743346] bpfilter: Loaded bpfilter_umh pid 4407 [ 345.743711] Started bpfilter Note:\nGive at least 30 seconds or more before trying the dmesg\nIf the last line says something like\n[ 887.699447] usb 1-4: USB disconnect, device number 4 [ 887.699969] cdc_subset 1-4:1.1 usb0: unregister \u0026#39;cdc_subset\u0026#39; usb-0000:03:00.3-4, Linux Device that means the USB gadget mode was enabled and for some reason it got disconnected.\nIf you get this, check whether the USB cable was connected to the USB port on the Pi, not on the power port.\nOnce confirmed that everything is working fine, goto gnome-network-manager gui and change the USB ethernet\u0026rsquo;s IPv4 setting to shared to other computers.\nDisconnect and then reconnect the USB ethernet in the gui. If that doesn\u0026rsquo;t allow you to ssh into the Pi, you might also need to dis/reconnect the PCI ethernet option.\nNow you should be able to SSH into the Internet ready Pi.\n3.2 SSH into Raspberry Pi ssh pi@IP_ADDRESS password: raspberry replace the IP_ADDRESS with the IP Address of the Raspberry Pi zero.\n3.3 Change locale settings To eliminate perl: LC errors during package installations; sudo dpkg-reconfigure locales select the appropriate locale. For example; en_US.UTF-8\nSet timezone sudo ln -sf /usr/share/timezone/Country/Region /etc/localtime Expand file system expand the file system by using\nsudo raspi-config Now its time to shutdown the Pi to take effect the changes.\nReboot seems to be breaking the USB ether net gadget mode for some reason. Hence you need to shutdown the system.\nNote :\nCheck dmesg again . If you see some messages similar to below, reboot the host linux OS. Only then re-connect the Pi.\n[ 1131.255131] ------------[ cut here ]------------ [ 1131.255137] NETDEV WATCHDOG: enx1a4d1a4fb05e (cdc_ether): transmit queue 0 timed out [ 1131.255158] WARNING: CPU: 6 PID: 0 at net/sched/sch_generic.c:467 dev_watchdog+0x24f/0x260 . . . [ 1131.255535] ---[ end trace 07a143fded20143c ]--- I got this message even after a reboot. In that case disconnect the Pi and check the SD card for any file system errors. Reboot the host OS again and reconnect the Pi.\nThen follow the instructions on 3.1 .\n3.4 Update the OS It\u0026rsquo;s better to setup the WiFi connection and then upgrade the OS. It can be done by referring to\nsudo apt update sudo apt upgrade Shutdown and unplug or re plug the Pi. Follow 3.1 .\nNow we need to setup the WiFi to automatically connect to the access point during the next reboot.\n3.5 WiFi configuration for auto connecting to the access point You can add the WiFi Configuration using raspi-config after SSH-ing via USB.\narp -a This will display the IP address of the USB Ethernet ( usually its of form 10.42.0.x ) SSH into the board. Use the following command to enter the Raspi configuration\nsudo raspi-config Then connect to WiFi via the Connection options by entering the SSID and Password of your network.\nOR\nAdd these lines to /etc/wpa_supplicant/wpa_supplicant.conf;\ncountry=\u0026#34;your country code\u0026#34; network={ scan_ssid=1 ssid=\u0026#34;wifi name\u0026#34; psk=\u0026#34;wifi password\u0026#34; } Now shutdown the Pi. Connect the WiFi adapter and power cable then turn it on.\n","date":"April 15, 2024","permalink":"/blog/posts/raspberrypi/raspberrypi_zero_setup/","summary":"Raspberry Pi Zero Headless WiFi Setup Using Linux The following instructions will ultimately enable your Pi Zero to connect the WiFi to the router during every boot up, for a headless management.","title":"RaspberryPi_Zero_Setup","type":"posts"},{"content":" Hello! I\u0026rsquo;m Krishnatejaswi S, a passionate Computer Science and Engineering student from Bangalore, India. My journey in the world of technology has been both challenging and rewarding, and I\u0026rsquo;m excited to share my experiences and projects with you.\nAcademic Background I\u0026rsquo;m currently pursuing my B.E degree in Computer Science and Engineering at RV College of Engineering, where I\u0026rsquo;ve had the opportunity to dive deep into various technologies and programming languages. My academic and research projects have allowed me to explore and master languages like Python and C++, and I\u0026rsquo;m always eager to learn and experiment with new technologies. Portfolio I\u0026rsquo;ve worked on a variety of projects that have helped me grow as a developer. Check out my portfolio to see some of my work. From web development to machine learning, I\u0026rsquo;ve tackled projects that challenge me and push my boundaries.\nPassion for Coding My passion for coding extends beyond the classroom. I\u0026rsquo;m particularly interested in exploring the cutting-edge technologies that are shaping the future of the tech industry. Some of the areas I\u0026rsquo;m currently exploring include:\nOpenCV: A facinating library to work with image processing in python. Ollama: A platform that\u0026rsquo;s revolutionizing the way we interact with AI. Generative AI: Creating content and models that can generate human-like text and images. JavaScript, Next.js: Building dynamic and responsive web applications. PyTorch: Diving into the world of machine learning and AI. Contact Me If you\u0026rsquo;re interested in my work, have questions, or would like to collaborate on a project, feel free to contact me . I\u0026rsquo;m always open to new connections and opportunities.\nThank you for visiting my About page. I look forward to sharing more of my journey with you!\nYou can also connect me via Linktree ","date":"April 14, 2024","permalink":"/blog/about/about/","summary":"Hello!","title":"About","type":"about"}]